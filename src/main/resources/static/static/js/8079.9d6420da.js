"use strict";(self["webpackChunkeco_friendly"]=self["webpackChunkeco_friendly"]||[]).push([[8079],{5312:function(e,t,i){i.d(t,{N:function(){return s}});const s={convertToGEGeometry:n,exportPoint:a,exportPolygon:l,exportPolyline:c,exportMultipoint:f,exportExtent:m};function n(e,t){return null==t?null:e.convertJSONToGeometry(t)}class r{constructor(e,t,i){this.x=e,this.y=t,this.spatialReference=i,this.z=void 0,this.m=void 0}}function a(e,t,i){const s=new r(e.getPointX(t),e.getPointY(t),i),n=e.hasZ(t),a=e.hasM(t);return n&&(s.z=e.getPointZ(t)),a&&(s.m=e.getPointM(t)),s}class o{constructor(e,t,i,s){this.rings=e,this.spatialReference=t,this.hasZ=void 0,this.hasM=void 0,i&&(this.hasZ=i),s&&(this.hasM=s)}}function l(e,t,i){return new o(e.exportPaths(t),i,e.hasZ(t),e.hasM(t))}class u{constructor(e,t,i,s){this.paths=e,this.spatialReference=t,this.hasZ=void 0,this.hasM=void 0,i&&(this.hasZ=i),s&&(this.hasM=s)}}function c(e,t,i){return new u(e.exportPaths(t),i,e.hasZ(t),e.hasM(t))}class h{constructor(e,t,i,s){this.points=e,this.spatialReference=t,this.hasZ=void 0,this.hasM=void 0,i&&(this.hasZ=i),s&&(this.hasM=s)}}function f(e,t,i){return new h(e.exportPoints(t),i,e.hasZ(t),e.hasM(t))}class d{constructor(e,t,i,s,n){this.xmin=e,this.ymin=t,this.xmax=i,this.ymax=s,this.spatialReference=n,this.zmin=void 0,this.zmax=void 0,this.mmin=void 0,this.mmax=void 0}}function m(e,t,i){const s=e.hasZ(t),n=e.hasM(t),r=new d(e.getXMin(t),e.getYMin(t),e.getXMax(t),e.getYMax(t),i);if(s){const i=e.getZExtent(t);r.zmin=i.vmin,r.zmax=i.vmax}if(n){const i=e.getMExtent(t);r.mmin=i.vmin,r.mmax=i.vmax}return r}},6884:function(e,t,i){i.d(t,{Y:function(){return r}});var s=i(8693);function n(e,t){return e?t?4:3:t?3:2}function r(e,t,i,r,l){if((0,s.Wi)(t)||!t.lengths.length)return null;const u="upperLeft"===l?.originPosition?-1:1;e.lengths.length&&(e.lengths.length=0),e.coords.length&&(e.coords.length=0);const c=e.coords,h=[],f=i?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:d,coords:m}=t,g=n(i,r);let p=0;for(const s of d){const e=a(f,m,p,s,i,r,u);e&&h.push(e),p+=s*g}if(h.sort(((e,t)=>{let s=u*e[2]-u*t[2];return 0===s&&i&&(s=e[4]-t[4]),s})),h.length){let e=6*h[0][2];c[0]=h[0][0]/e,c[1]=h[0][1]/e,i&&(e=6*h[0][4],c[2]=0!==e?h[0][3]/e:0),(c[0]<f[0]||c[0]>f[1]||c[1]<f[2]||c[1]>f[3]||i&&(c[2]<f[4]||c[2]>f[5]))&&(c.length=0)}if(!c.length){const e=t.lengths[0]?o(m,0,d[0],i,r):null;if(!e)return null;c[0]=e[0],c[1]=e[1],i&&e.length>2&&(c[2]=e[2])}return e}function a(e,t,i,s,r,a,o=1){const l=n(r,a);let u=i,c=i+l,h=0,f=0,d=0,m=0,g=0;for(let n=0,y=s-1;n<y;n++,u+=l,c+=l){const i=t[u],s=t[u+1],n=t[u+2],a=t[c],o=t[c+1],l=t[c+2];let p=i*o-a*s;m+=p,h+=(i+a)*p,f+=(s+o)*p,r&&(p=i*l-a*n,d+=(n+l)*p,g+=p),i<e[0]&&(e[0]=i),i>e[1]&&(e[1]=i),s<e[2]&&(e[2]=s),s>e[3]&&(e[3]=s),r&&(n<e[4]&&(e[4]=n),n>e[5]&&(e[5]=n))}if(m*o>0&&(m*=-1),g*o>0&&(g*=-1),!m)return null;const p=[h,f,.5*m];return r&&(p[3]=d,p[4]=.5*g),p}function o(e,t,i,s,r){const a=n(s,r);let o=t,f=t+a,d=0,m=0,g=0,p=0;for(let n=0,y=i-1;n<y;n++,o+=a,f+=a){const t=e[o],i=e[o+1],n=e[o+2],r=e[f],a=e[f+1],y=e[f+2],x=s?u(t,i,n,r,a,y):l(t,i,r,a);if(x)if(d+=x,s){const e=h(t,i,n,r,a,y);m+=x*e[0],g+=x*e[1],p+=x*e[2]}else{const e=c(t,i,r,a);m+=x*e[0],g+=x*e[1]}}return d>0?s?[m/d,g/d,p/d]:[m/d,g/d]:i>0?s?[e[t],e[t+1],e[t+2]]:[e[t],e[t+1]]:null}function l(e,t,i,s){const n=i-e,r=s-t;return Math.sqrt(n*n+r*r)}function u(e,t,i,s,n,r){const a=s-e,o=n-t,l=r-i;return Math.sqrt(a*a+o*o+l*l)}function c(e,t,i,s){return[e+.5*(i-e),t+.5*(s-t)]}function h(e,t,i,s,n,r){return[e+.5*(s-e),t+.5*(n-t),i+.5*(r-i)]}},48079:function(e,t,i){i.d(t,{y:function(){return p},r:function(){return h}});i(26699);var s=i(8693),n=i(11666),r=i(36936),a=i(857),o=i(54597),l=i(47914),u=i(73124);class c{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&!s.includes("*")){this.outFields=s;let e=0;for(const t of s){const s=(0,l.hr)(t),n=this.fieldsIndex.get(s),r=n?null:(0,l.Jc)(s,i),a=n?n.name:(0,l.nu)(t)||"FIELD_EXP_"+e++;this._fieldDataCache.set(t,{alias:a,clause:r})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach((e=>this.getAttributes(e))),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){const s=i?i.name:t;let n=null;return this._fieldDataCache.has(s)?n=this._fieldDataCache.get(s).clause:i||(n=(0,l.Jc)(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:n})),i?this.featureAdapter.getAttribute(e,s):n.calculateValue(e,this.featureAdapter)}getNormalizedValue(e,t){const i=t.normalizationType,s=t.normalizationTotal;let n=this.getFieldValue(e,t.field,t.fieldInfo);if(i&&Number.isFinite(n)){const r=this.getFieldValue(e,t.normalizationField,t.normalizationFieldInfo);n=(0,u.fk)(n,i,r,s)}return n}getExpressionValue(e,t,i,s){const n={attributes:this.featureAdapter.getAttributes(e),layer:{fields:this.fieldsIndex.fields}},r=s.createExecContext(n,i);return s.executeFunction(t,r)}getExpressionValues(e,t,i,s){const n={fields:this.fieldsIndex.fields};return e.map((e=>{const r={attributes:this.featureAdapter.getAttributes(e),layer:n},a=s.createExecContext(r,i);return s.executeFunction(t,a)}))}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:(0,l.Jc)(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testFeature(e,this.featureAdapter)}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:(0,l.Jc)(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testSet(e,this.featureAdapter)}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:t,clause:n}=this._fieldDataCache.get(s);i[t]=n?n.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,t)}return i}_processAttributesForDistinctValues(e){if((0,s.Wi)(e)||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const s of t){const{alias:t}=this._fieldDataCache.get(s);i.push(e[t])}else for(const s in e)i.push(e[s]);const n=`${(t||["*"]).join(",")}=${i.join(",")}`;let r=this._returnDistinctMap.get(n)||0;return this._returnDistinctMap.set(n,++r),r>1?null:e}}var h,f=i(65341),d=i(1029),m=i(10523),g=i(21361);class p{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new c(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query,n=t?.length;if(!n)return 1;const r=new Map,a=new Map,o=new Set;for(const l of s){const{statisticType:s}=l,n="exceedslimit"!==s?l.onStatisticField:void 0;if(!a.has(n)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,r);i.push(t)}a.set(n,this._calculateUniqueValues(i,e.returnDistinctValues))}const u=a.get(n);for(const t in u){const{data:s,items:n}=u[t],r=s.join(",");i&&!e.validateItems(n,i)||o.add(r)}}return o.size}async createQueryResponse(){let e;return e=this.query.outStatistics?this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry&&((0,o.JY)(this.query.outSR)&&!(0,o.fS)(this.query.geometry.spatialReference,this.query.outSR)?e.queryGeometry=(0,d.S2)({spatialReference:this.query.outSR,...(0,f.iV)(this.query.geometry,this.query.geometry.spatialReference,this.query.outSR)}):e.queryGeometry=(0,d.S2)({spatialReference:this.query.outSR,...this.query.geometry})),e}createSnappingResponse(e,t){const i=this.featureAdapter,n=x(this.hasZ,this.hasM),{x:r,y:a}=e.point,o="number"==typeof e.distance?e.distance:e.distance.x,l="number"==typeof e.distance?e.distance:e.distance.y,u={candidates:[]},c="esriGeometryPolygon"===this.geometryType,f=this._getPointCreator(e.point,this.spatialReference,t);for(const d of this.items){const t=i.getGeometry(d);if((0,s.Wi)(t))continue;const{coords:m,lengths:g}=t;if(e.types&h.EDGE){let e=0;for(let t=0;t<g.length;t++){const s=g[t];for(let t=0;t<s;t++,e+=n){const c=m[e],h=m[e+1];if(t!==s-1){const t=m[e+n],s=m[e+n+1],{x:g,y:p}=y(r,a,c,h,t,s),x=(r-g)/o,I=(a-p)/l,_=x*x+I*I;_<=1&&u.candidates.push({type:"edge",objectId:i.getObjectId(d),distance:Math.sqrt(_),target:f(g,p),start:f(c,h),end:f(t,s)})}}}}if(e.types&h.VERTEX){const e=c?m.length-n:m.length;for(let t=0;t<e;t+=n){const e=m[t],s=m[t+1],n=(r-e)/o,c=(a-s)/l,h=n*n+c*c;h<=1&&u.candidates.push({type:"vertex",objectId:i.getObjectId(d),distance:Math.sqrt(h),target:f(e,s)})}}}return u.candidates.sort(((e,t)=>e.distance-t.distance)),u}_getPointCreator(e,t,i){const n=(0,s.pC)(i)&&!(0,o.fS)(t,i)?e=>(0,f.iV)(e,t,i):e=>e;return null!=e.z&&null!=e.m?(t,i)=>n({x:t,y:i,z:e.z,m:e.m}):null!=e.z?(t,i)=>n({x:t,y:i,z:e.z}):null!=e.m?(t,i)=>n({x:t,y:i,m:e.m}):(e,t)=>n({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:r,minValue:a,maxValue:o,scale:l}=e,c=this.fieldsIndex.isDateField(t),h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:r,scale:l}),f=(0,u.S5)({normalizationType:n,normalizationField:s,minValue:a,maxValue:o}),d=this.fieldsIndex.get(t),g={value:.5,fieldType:d?.type},p=(0,m.qN)(d)?(0,u.H0)({values:h,supportsNullCount:f,percentileParams:g}):(0,u.i5)({values:h,minValue:a,maxValue:o,useSampleStdDev:!n,supportsNullCount:f,percentileParams:g});return(0,u.F_)(p,c)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domain:s,returnAllCodedValues:n,scale:r}=e,a=await this._getDataValues({field:t,valueExpression:i,scale:r}),o=(0,u.eT)(a);return(0,u.Qm)(o,s,n)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:r,classificationMethod:a,standardDeviationInterval:o,minValue:l,maxValue:c,numClasses:h,scale:f}=e,d=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:r,scale:f}),m=(0,u.G2)(d,{field:t,normalizationField:s,normalizationType:n,normalizationTotal:r,classificationMethod:a,standardDeviationInterval:o,minValue:l,maxValue:c,numClasses:h});return(0,u.DL)(m,a)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:r,classificationMethod:a,standardDeviationInterval:o,minValue:l,maxValue:c,numBins:h,scale:f}=e,d=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:r,scale:f});return(0,u.oF)(d,{field:t,normalizationField:s,normalizationType:n,normalizationTotal:r,classificationMethod:a,standardDeviationInterval:o,minValue:l,maxValue:c,numBins:h})}_sortFeatures(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const t=s.split(" "),n=t[0],r=this.fieldsIndex.get(n),a=t[1]&&"desc"===t[1].toLowerCase(),o=(0,u.Lq)(r?.type,a);e.sort(((e,t)=>{const s=i(e,n,r),a=i(t,n,r);return o(s,a)}))}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:s,hasZ:n,objectIdField:r,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:h,resultOffset:f,returnZ:m,returnM:g}=e,p=null!=h&&t.length>(f||0)+h,y=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:p,features:this._createFeatures(e,t),fields:y,geometryType:i,hasM:s&&g,hasZ:n&&m,objectIdFieldName:r,spatialReference:(0,d.S2)(u||o),transform:c&&(0,a.vY)(c)||null}}_createFeatures(e,t){const i=new c(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:n}=this,{orderByFields:r,quantizationParameters:o,returnGeometry:l,returnCentroid:u,maxAllowableOffset:h,resultOffset:f,resultRecordCount:m,returnZ:g=!1,returnM:p=!1}=e,y=n&&g,x=s&&p;let I=[],_=0;const F=[...t];if(this._sortFeatures(F,r,((e,t,s)=>i.getFieldValue(e,t,s))),l||u){const e=(0,a.vY)(o);if(l&&!u)for(const t of F)I[_++]={attributes:i.getAttributes(t),geometry:(0,d.Op)(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),h,e,y,x)};else if(!l&&u)for(const t of F)I[_++]={attributes:i.getAttributes(t),centroid:(0,d.EG)(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of F)I[_++]={attributes:i.getAttributes(t),centroid:(0,d.EG)(this,this.featureAdapter.getCentroid(t,this),e),geometry:(0,d.Op)(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),h,e,y,x)}}else for(const a of F){const e=i.getAttributes(a);e&&(I[_++]={attributes:e})}const T=f||0;if(null!=m){const e=T+m;I=I.slice(T,Math.min(I.length,e))}return I}_createExceedsLimitQueryResponse(e){let t=!1,i=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const s of e.outStatistics)if("exceedslimit"===s.statisticType){i=null!=s.maxPointCount?s.maxPointCount:Number.POSITIVE_INFINITY,n=null!=s.maxRecordCount?s.maxRecordCount:Number.POSITIVE_INFINITY,r=null!=s.maxVertexCount?s.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)t=this.items.length>i;else if(this.items.length>n)t=!0;else{const e=this.hasZ?this.hasM?4:3:this.hasM?3:2,i=this.featureAdapter;t=this.items.reduce(((e,t)=>{const n=i.getGeometry(t);return e+((0,s.pC)(n)&&n.coords.length||0)}),0)/e>r}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],s=new Map,n=new Map,r=new Map,a=new Map,o=new c(e,this.featureAdapter,this.fieldsIndex),l=e.outStatistics,{groupByFieldsForStatistics:u,having:h,orderByFields:f}=e,d=u&&u.length,m=!!d,g=m&&u[0],p=m&&!this.fieldsIndex.get(g);for(const c of l){const{outStatisticFieldName:e,statisticType:l}=c,f=c,y="exceedslimit"!==l?c.onStatisticField:void 0,x="percentile_disc"===l||"percentile_cont"===l,I="EnvelopeAggregate"===l||"CentroidAggregate"===l||"ConvexHullAggregate"===l,_=m&&1===d&&(y===g||p)&&"count"===l;if(m){if(!r.has(y)){const e=[];for(const t of u){const i=this._getAttributeValues(o,t,s);e.push(i)}r.set(y,this._calculateUniqueValues(e,o.returnDistinctValues))}const t=r.get(y);for(const i in t){const{count:n,data:r,items:l,itemPositions:c}=t[i],d=r.join(",");if(!h||o.validateItems(l,h)){const t=a.get(d)||{attributes:{}};if(I){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(f,l);t.aggregateGeometries[i]=e}else{let i=null;if(_)i=n;else{const e=this._getAttributeValues(o,y,s),t=c.map((t=>e[t]));i=x&&"statisticParameters"in f?this._getPercentileValue(f,t):this._getStatisticValue(f,t,null,o.returnDistinctValues)}t.attributes[e]=i}u.forEach(((e,i)=>t.attributes[this.fieldsIndex.get(e)?e:`EXPR_${i+1}`]=r[i])),a.set(d,t)}}}else if(I){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(f,this.items);t.aggregateGeometries[i]=e}else{const i=this._getAttributeValues(o,y,s);t.attributes[e]=x&&"statisticParameters"in f?this._getPercentileValue(f,i):this._getStatisticValue(f,i,n,o.returnDistinctValues)}i.push({name:e,alias:e,type:"esriFieldTypeDouble"})}const y=m?Array.from(a.values()):[t];return this._sortFeatures(y,f,((e,t)=>e.attributes[t])),{fields:i,features:y}}async _getAggregateGeometry(e,t){const s=await Promise.all([i.e(4174),i.e(4438)]).then(i.bind(i,21813)),{statisticType:a,outStatisticFieldName:o}=e,{featureAdapter:l,spatialReference:u,geometryType:c,hasZ:h,hasM:f}=this,m=t.map((e=>(0,d.Op)(c,h,f,l.getGeometry(e)))),g=s.convexHull(u,m,!0)[0],p={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===a){const e=g?(0,r._w)(g):(0,r.aO)(s.union(u,m));p.aggregateGeometries={...e,spatialReference:u},p.outStatisticFieldName=o||"extent"}else if("CentroidAggregate"===a){const e=g?(0,n.tO)(g):(0,n.$G)((0,r.aO)(s.union(u,m)));p.aggregateGeometries={x:e[0],y:e[1],spatialReference:u},p.outStatisticFieldName=o||"centroid"}else"ConvexHullAggregate"===a&&(p.aggregateGeometries=g,p.outStatisticFieldName=o||"convexHull");return p}_getStatisticValue(e,t,i,s){const{onStatisticField:n,statisticType:r}=e;let a=null;return a=i?.has(n)?i.get(n):(0,m.qN)(this.fieldsIndex.get(n))?(0,u.H0)({values:t,returnDistinct:s}):(0,u.i5)({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(n,a),a["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:n}=e,{value:r,orderBy:a}=s,o=this.fieldsIndex.get(i);return(0,u.XL)(t,{value:r,orderBy:a,fieldType:o?.type,isDiscrete:"percentile_disc"===n})}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),n=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,n),n}_getAttributeNormalizedValues(e,t){return this.items.map((i=>e.getNormalizedValue(i,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal})))}async _getAttributeExpressionValues(e,t,i){const{arcadeUtils:s}=await(0,g.LC)(),n=s.createFunction(t),r=i&&s.getViewInfo(i);return e.getExpressionValues(this.items,n,r,s)}_calculateUniqueValues(e,t){const i={},s=this.items,n=s.length;for(let r=0;r<n;r++){const n=s[r],a=[];for(const t of e)a.push(t[r]);const o=a.join(",");t?null==i[o]&&(i[o]={count:1,data:a,items:[n],itemPositions:[r]}):null==i[o]?i[o]={count:1,data:a,items:[n],itemPositions:[r]}:(i[o].count++,i[o].items.push(n),i[o].itemPositions.push(r))}return i}async _getDataValues(e){const t=new c(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:s,normalizationField:n,normalizationType:r,normalizationTotal:a,scale:o}=e,l=i?{viewingMode:"map",scale:o,spatialReference:this.query.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(t,i,l):this._getAttributeNormalizedValues(t,{field:s,normalizationField:n,normalizationType:r,normalizationTotal:a})}}function y(e,t,i,s,n,r){const a=n-i,o=r-s,l=a*a+o*o,u=(e-i)*a+(t-s)*o,c=Math.min(1,Math.max(0,u/l));return{x:i+a*c,y:s+o*c}}function x(e,t){return e?t?4:3:t?3:2}!function(e){e[e.NONE=0]="NONE",e[e.EDGE=1]="EDGE",e[e.VERTEX=2]="VERTEX"}(h||(h={}))},47914:function(e,t,i){i.d(t,{nu:function(){return p},hr:function(){return g},Jc:function(){return d},G3:function(){return y},Of:function(){return m},z4:function(){return f},hO:function(){return h}});var s=i(22130),n=i(90046),r=i(64441);class a{constructor(e,t){this._cache=new n.Z(e),this._invalidCache=new n.Z(t)}get(e,t){const i=`${t.uid}:${e}`,s=this._cache.get(i);if(s)return s;if(void 0!==this._invalidCache.get(i))return null;try{const s=r.WhereClause.create(e,t);return this._cache.put(i,s),s}catch{return this._invalidCache.put(i,null),null}}}const o=new a(50,500),l="feature-store:unsupported-query",u=" as ",c=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function h(e,t){if(!t)return!0;const i=o.get(t,e);if(!i)throw new s.Z(l,"invalid SQL expression",{where:t});if(!i.isStandardized)throw new s.Z(l,"where clause is not standard",{where:t});return m(e,i.fieldNames,"where clause contains missing fields"),!0}function f(e,t,i){if(!t)return!0;const n=o.get(t,e);if(!n)throw new s.Z(l,"invalid SQL expression",{having:t});if(!n.isAggregate)throw new s.Z(l,"having does not contain a valid aggregate function",{having:t});const r=n.fieldNames;if(m(e,r,"having contains missing fields"),!n.getExpressions().every((t=>{const{aggregateType:s,field:n}=t,r=e.has(n)&&e.get(n).name;return i.some((t=>{const{onStatisticField:i,statisticType:n}=t;return(e.has(i)&&e.get(i).name)===r&&n.toLowerCase().trim()===s}))})))throw new s.Z(l,"expressions in having should also exist in outStatistics",{having:t});return!0}function d(e,t){return e?o.get(e,t):null}function m(e,t,i,n=!0){const r=[];for(const a of t)if("*"!==a&&!e.has(a))if(n){const t=g(a);try{const i=d(t,e);if(!i)throw new s.Z(l,"invalid SQL expression",{where:t});if(!i.isStandardized)throw new s.Z(l,"expression is not standard",{clause:i});m(e,i.fieldNames,"expression contains missing fields")}catch(f){const t=f&&f.details;if(t&&(t.clause||t.where))throw f;t&&t.missingFields?r.push(...t.missingFields):r.push(a)}}else r.push(a);if(r.length)throw new s.Z(l,i,{missingFields:r})}function g(e){return e.split(u)[0]}function p(e){return e.split(u)[1]}function y(e,t){const i=t.get(e);return!!i&&!c.has(i.type)}},65341:function(e,t,i){i.d(t,{_W:function(){return f},iV:function(){return g},oj:function(){return x}});var s=i(8693),n=i(47608),r=i(5312),a=i(54597),o=i(31957);const l=[0,0];function u(e,t){if(!t)return null;if("x"in t){const i={x:0,y:0};return[i.x,i.y]=e(t.x,t.y,l),null!=t.z&&(i.z=t.z),null!=t.m&&(i.m=t.m),i}if("xmin"in t){const i={xmin:0,ymin:0,xmax:0,ymax:0};return[i.xmin,i.ymin]=e(t.xmin,t.ymin,l),[i.xmax,i.ymax]=e(t.xmax,t.ymax,l),t.hasZ&&(i.zmin=t.zmin,i.zmax=t.zmax,i.hasZ=!0),t.hasM&&(i.mmin=t.mmin,i.mmax=t.mmax,i.hasM=!0),i}return"rings"in t?{rings:c(t.rings,e),hasM:t.hasM,hasZ:t.hasZ}:"paths"in t?{paths:c(t.paths,e),hasM:t.hasM,hasZ:t.hasZ}:"points"in t?{points:h(t.points,e),hasM:t.hasM,hasZ:t.hasZ}:void 0}function c(e,t){const i=[];for(const s of e)i.push(h(s,t));return i}function h(e,t){const i=[];for(const s of e){const e=t(s[0],s[1],[0,0]);i.push(e),s.length>2&&e.push(s[2]),s.length>3&&e.push(s[3])}return i}async function f(e,t){if(!t)return;const i=Array.isArray(e)?e.map((e=>(0,s.pC)(e.geometry)&&e.geometry.spatialReference)):[e];await(0,n.iQ)(i.map((e=>({source:e,dest:t}))))}const d=u.bind(null,o.hG),m=u.bind(null,o.R6);function g(e,t,i,s){if(!e)return e;if(i||(i=t,t=e.spatialReference),!(0,a.JY)(t)||!(0,a.JY)(i)||(0,a.fS)(t,i))return e;if((0,o.Q8)(t,i)){const t=(0,a.sS)(i)?d(e):m(e);return t.spatialReference=i,t}return(0,n.oj)(r.N,[e],t,i,null,s)[0]}class p{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(e,t,i){if(!e||!e.length||!t||!i||(0,a.fS)(t,i))return e;const s={geometries:e,inSpatialReference:t,outSpatialReference:i,resolve:null};return this._jobs.push(s),new Promise((e=>{s.resolve=e,null===this._timer&&(this._timer=setTimeout(this._process,10))}))}_process(){this._timer=null;const e=this._jobs.shift();if(!e)return;const{geometries:t,inSpatialReference:i,outSpatialReference:s,resolve:l}=e;(0,o.Q8)(i,s)?(0,a.sS)(s)?l(t.map(d)):l(t.map(m)):l((0,n.oj)(r.N,t,i,s,null,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const y=new p;function x(e,t,i){return y.push(e,t,i)}},1029:function(e,t,i){i.d(t,{EG:function(){return I},Op:function(){return _},S2:function(){return V},Up:function(){return F},j6:function(){return T},vF:function(){return m}});var s=i(38511),n=i(8693),r=i(61293),a=i(36936),o=i(90421),l=i(33482),u=i(54597),c=(i(6884),i(76338)),h=i(10297),f=i(65341);const d=new s.X({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),m=Object.freeze({}),g=new h.Z,p=new h.Z,y=new h.Z,x={esriGeometryPoint:c.fQ,esriGeometryPolyline:c.J6,esriGeometryPolygon:c.eG,esriGeometryMultipoint:c.Iv};function I(e,t,i,s=e.hasZ,r=e.hasM){if((0,n.Wi)(t))return null;const a=e.hasZ&&s,o=e.hasM&&r;if(i){const n=(0,c.Nh)(y,t,e.hasZ,e.hasM,"esriGeometryPoint",i,s,r);return(0,c.fQ)(n,a,o)}return(0,c.fQ)(t,a,o)}function _(e,t,i,s,r,a,o=t,l=i){const u=t&&o,h=i&&l,f=(0,n.pC)(s)?"coords"in s?s:s.geometry:null;if((0,n.Wi)(f))return null;if(r){let s=(0,c.zj)(p,f,t,i,e,r,o,l);return a&&(s=(0,c.Nh)(y,s,u,h,e,a)),x[e](s,u,h)}if(a){const s=(0,c.Nh)(y,f,t,i,e,a,o,l);return x[e](s,u,h)}return(0,c.hY)(g,f,t,i,o,l),x[e](g,u,h)}async function F(e,t,i){const{outFields:s,orderByFields:n,groupByFieldsForStatistics:r,outStatistics:a}=e;if(s)for(let o=0;o<s.length;o++)s[o]=s[o].trim();if(n)for(let o=0;o<n.length;o++)n[o]=n[o].trim();if(r)for(let o=0;o<r.length;o++)r[o]=r[o].trim();if(a)for(let o=0;o<a.length;o++)a[o].onStatisticField&&(a[o].onStatisticField=a[o].onStatisticField.trim());return e.geometry&&!e.outSR&&(e.outSR=e.geometry.spatialReference),T(e,t,i)}async function T(e,t,i){if(!e)return null;let{where:s}=e;if(e.where=s=s&&s.trim(),(!s||/^1 *= *1$/.test(s)||t&&t===s)&&(e.where=null),!e.geometry)return e;let r=await S(e);if(e.distance=0,e.units=null,"esriSpatialRelEnvelopeIntersects"===e.spatialRel){const{spatialReference:t}=e.geometry;r=(0,a.aO)(r),r.spatialReference=t}e.geometry=r,await(0,f._W)(r.spatialReference,i);const u=(await(0,l.aX)((0,o.im)(r)))[0];if((0,n.Wi)(u))throw m;const c=u.toJSON(),h=await(0,f.iV)(c,c.spatialReference,i);if(!h)throw m;return h.spatialReference=i,e.geometry=h,e}async function S(e){const{geometry:t,distance:i,units:s}=e;if(null==i||"vertexAttributes"in t)return t;const n=t.spatialReference,a=s?d.fromJSON(s):(0,r.qE)(n),o=n&&((0,u.sT)(n)||(0,u.sS)(n))?t:await(0,f._W)(n,u.Zn).then((()=>(0,f.iV)(t,u.Zn)));return(await v())(o.spatialReference,o,i,a)}async function v(){return(await Promise.all([i.e(4174),i.e(4438)]).then(i.bind(i,21813))).geodesicBuffer}function V(e){return e&&N in e?JSON.parse(JSON.stringify(e,b)):e}const N="_geVersion",b=(e,t)=>e!==N?t:void 0}}]);
//# sourceMappingURL=8079.9d6420da.js.map