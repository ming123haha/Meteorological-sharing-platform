{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { ShaderOutput as e } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js\";\nimport { SliceDraw as o } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { Transform as t } from \"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";\nimport { VertexColor as r } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";\nimport { OutputDepth as a } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { OutputHighlight as i } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { multipassTerrainTest as n } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { symbolAlphaCutoff as l } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { ColorConversion as c } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { addProjViewLocalOrigin as d, addCameraPosition as s } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float2PassUniform as p } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as u } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as v } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as m } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { TransparencyPassType as f } from \"../views/3d/webgl-engine/lib/basicInterfaces.js\";\nimport { VertexAttribute as h } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { Style as w } from \"../views/3d/webgl-engine/materials/PatternStyle.js\";\nconst b = .70710678118,\n      y = b,\n      S = .08715574274;\n\nfunction j(j) {\n  const P = new m(),\n        T = j.hasMultipassTerrain && (j.output === e.Color || j.output === e.Alpha);\n  j.draped || P.extensions.add(\"GL_OES_standard_derivatives\");\n  const C = j.output === e.Depth,\n        {\n    vertex: D,\n    fragment: R\n  } = P;\n  d(P, j), P.include(t, {\n    hasModelTransformation: !1,\n    linearDepth: C\n  }), P.include(r, j), C && (P.include(a, j), D.uniforms.add(new p(\"nearFar\", (e, o) => o.camera.nearFar)), P.varyings.add(\"linearDepth\", \"float\")), j.draped ? D.uniforms.add(new u(\"worldToScreenRatio\", (e, o) => 1 / o.screenToPCSRatio)) : P.attributes.add(h.BOUNDINGRECT, \"mat3\"), P.attributes.add(h.POSITION, \"vec3\"), P.attributes.add(h.UVMAPSPACE, \"vec4\"), P.varyings.add(\"vpos\", \"vec3\"), P.varyings.add(\"vuv\", \"vec2\"), T && P.varyings.add(\"depth\", \"float\");\n  const $ = j.style === w.ForwardDiagonal || j.style === w.BackwardDiagonal || j.style === w.DiagonalCross;\n  return $ && D.code.add(v`\n      const mat2 rotate45 = mat2(${v.float(b)}, ${v.float(-y)},\n                                 ${v.float(y)}, ${v.float(b)});\n    `), j.draped || (s(D, j), D.uniforms.add(new u(\"worldToScreenPerDistanceRatio\", (e, o) => 1 / o.camera.perScreenPixelRatio)), D.code.add(v`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\nfloat projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\nreturn center + halfVector * clamp(projectedLength, -1.0, 1.0);\n}`), D.code.add(v`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\nfloat d = dot(planeNormal, planePoint);\nfloat t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\nreturn rayOrigin + t * rayDir;\n}`), D.code.add(v`\n      float boundingRectDistanceToCamera() {\n        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);\n        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);\n        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ${v.float(S)};\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, cameraPosition, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - cameraPosition);\n      }\n    `)), D.code.add(v`\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ${$ ? \" * rotate45\" : \"\"};\n      vec2 uvCellOrigin = uvMapSpace.zw ${$ ? \" * rotate45\" : \"\"};\n\n      ${j.draped ? \"\" : v`\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;\n          `}\n\n      // Logarithmically discretize ratio to avoid jittering\n      float step = 0.1;\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n\n      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${v.float(j.patternSpacing)});\n      return uvOffset + (uv * discreteWorldToScreenRatio);\n    }\n  `), D.code.add(v`\n    void main(void) {\n      vuv = scaledUV();\n      vpos = position;\n      ${T ? \"depth = (view * vec4(vpos, 1.0)).z;\" : \"\"}\n      forwardNormalizedVertexColor();\n      gl_Position = ${C ? v`transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);` : v`transformPosition(proj, view, vpos);`}\n    }\n  `), P.include(o, j), R.include(c), j.draped && R.uniforms.add(new u(\"texelSize\", (e, o) => 1 / o.camera.pixelRatio)), j.output === e.Highlight && P.include(i), T && P.include(n, j), j.output !== e.Highlight && (R.code.add(v`\n      const float lineWidth = ${v.float(j.lineWidth)};\n      const float spacing = ${v.float(j.patternSpacing)};\n      const float spacingINV = ${v.float(1 / j.patternSpacing)};\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    `), j.draped || R.code.add(v`const int maxSamples = 5;\nfloat sample(float p) {\nvec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\nfloat fwidth = dxdy.x + dxdy.y;\nivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\nvec2 invSamples = 1.0 / vec2(samples);\nfloat accumulator = 0.0;\nfor (int j = 0; j < maxSamples; j++) {\nif(j >= samples.y) {\nbreak;\n}\nfor (int i = 0; i < maxSamples; i++) {\nif(i >= samples.x) {\nbreak;\n}\nvec2 step = vec2(i,j) * invSamples - 0.5;\naccumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n}\n}\naccumulator /= float(samples.x * samples.y);\nreturn accumulator;\n}`)), R.uniforms.add(new g(\"uColor\", e => e.color)), R.code.add(v`\n    void main() {\n      discardBySlice(vpos);\n      ${T ? \"terrainDepthTest(gl_FragCoord, depth);\" : \"\"}\n      vec4 color = ${j.hasVertexColors ? \"vColor * uColor;\" : \"uColor;\"}\n      color = highlightSlice(color, vpos);\n\n      ${j.output !== e.Highlight ? v`color.a *= ${x(j)};` : \"\"}\n\n      if (color.a < ${v.float(l)}) {\n        discard;\n      }\n\n      ${j.output === e.Alpha ? v`gl_FragColor = vec4(color.a);` : \"\"}\n\n      ${j.output === e.Color ? v`gl_FragColor = color; ${j.transparencyPassType === f.Color ? \"gl_FragColor = premultiplyAlpha(gl_FragColor);\" : \"\"}` : \"\"}\n      ${j.output === e.Highlight ? v`outputHighlight();` : \"\"}\n      ${j.output === e.Depth ? v`outputDepth(linearDepth);` : \"\"};\n    }\n  `), P;\n}\n\nfunction x(e) {\n  function o(o) {\n    return e.draped ? v`coverage(vuv.${o}, texelSize)` : v`sample(vuv.${o})`;\n  }\n\n  switch (e.style) {\n    case w.ForwardDiagonal:\n    case w.Horizontal:\n      return o(\"y\");\n\n    case w.BackwardDiagonal:\n    case w.Vertical:\n      return o(\"x\");\n\n    case w.DiagonalCross:\n    case w.Cross:\n      return v`\n        1.0 - (1.0 - ${o(\"x\")}) * (1.0 - ${o(\"y\")})\n      `;\n\n    default:\n      return \"0.0\";\n  }\n}\n\nconst P = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: j\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { P, j as b };","map":{"version":3,"names":["ShaderOutput","e","SliceDraw","o","Transform","t","VertexColor","r","OutputDepth","a","OutputHighlight","i","multipassTerrainTest","n","symbolAlphaCutoff","l","ColorConversion","c","addProjViewLocalOrigin","d","addCameraPosition","s","Float2PassUniform","p","Float4PassUniform","g","FloatPassUniform","u","glsl","v","ShaderBuilder","m","TransparencyPassType","f","VertexAttribute","h","Style","w","b","y","S","j","P","T","hasMultipassTerrain","output","Color","Alpha","draped","extensions","add","C","Depth","vertex","D","fragment","R","include","hasModelTransformation","linearDepth","uniforms","camera","nearFar","varyings","screenToPCSRatio","attributes","BOUNDINGRECT","POSITION","UVMAPSPACE","$","style","ForwardDiagonal","BackwardDiagonal","DiagonalCross","code","float","perScreenPixelRatio","patternSpacing","pixelRatio","Highlight","lineWidth","color","hasVertexColors","x","transparencyPassType","Horizontal","Vertical","Cross","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/chunks/Pattern.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{ShaderOutput as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js\";import{SliceDraw as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{Transform as t}from\"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";import{VertexColor as r}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";import{OutputDepth as a}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{OutputHighlight as i}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{multipassTerrainTest as n}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{symbolAlphaCutoff as l}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";import{ColorConversion as c}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{addProjViewLocalOrigin as d,addCameraPosition as s}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float2PassUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as v}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as m}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{TransparencyPassType as f}from\"../views/3d/webgl-engine/lib/basicInterfaces.js\";import{VertexAttribute as h}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{Style as w}from\"../views/3d/webgl-engine/materials/PatternStyle.js\";const b=.70710678118,y=b,S=.08715574274;function j(j){const P=new m,T=j.hasMultipassTerrain&&(j.output===e.Color||j.output===e.Alpha);j.draped||P.extensions.add(\"GL_OES_standard_derivatives\");const C=j.output===e.Depth,{vertex:D,fragment:R}=P;d(P,j),P.include(t,{hasModelTransformation:!1,linearDepth:C}),P.include(r,j),C&&(P.include(a,j),D.uniforms.add(new p(\"nearFar\",((e,o)=>o.camera.nearFar))),P.varyings.add(\"linearDepth\",\"float\")),j.draped?D.uniforms.add(new u(\"worldToScreenRatio\",((e,o)=>1/o.screenToPCSRatio))):P.attributes.add(h.BOUNDINGRECT,\"mat3\"),P.attributes.add(h.POSITION,\"vec3\"),P.attributes.add(h.UVMAPSPACE,\"vec4\"),P.varyings.add(\"vpos\",\"vec3\"),P.varyings.add(\"vuv\",\"vec2\"),T&&P.varyings.add(\"depth\",\"float\");const $=j.style===w.ForwardDiagonal||j.style===w.BackwardDiagonal||j.style===w.DiagonalCross;return $&&D.code.add(v`\n      const mat2 rotate45 = mat2(${v.float(b)}, ${v.float(-y)},\n                                 ${v.float(y)}, ${v.float(b)});\n    `),j.draped||(s(D,j),D.uniforms.add(new u(\"worldToScreenPerDistanceRatio\",((e,o)=>1/o.camera.perScreenPixelRatio))),D.code.add(v`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\nfloat projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\nreturn center + halfVector * clamp(projectedLength, -1.0, 1.0);\n}`),D.code.add(v`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\nfloat d = dot(planeNormal, planePoint);\nfloat t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\nreturn rayOrigin + t * rayDir;\n}`),D.code.add(v`\n      float boundingRectDistanceToCamera() {\n        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);\n        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);\n        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ${v.float(S)};\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, cameraPosition, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - cameraPosition);\n      }\n    `)),D.code.add(v`\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ${$?\" * rotate45\":\"\"};\n      vec2 uvCellOrigin = uvMapSpace.zw ${$?\" * rotate45\":\"\"};\n\n      ${j.draped?\"\":v`\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;\n          `}\n\n      // Logarithmically discretize ratio to avoid jittering\n      float step = 0.1;\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n\n      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${v.float(j.patternSpacing)});\n      return uvOffset + (uv * discreteWorldToScreenRatio);\n    }\n  `),D.code.add(v`\n    void main(void) {\n      vuv = scaledUV();\n      vpos = position;\n      ${T?\"depth = (view * vec4(vpos, 1.0)).z;\":\"\"}\n      forwardNormalizedVertexColor();\n      gl_Position = ${C?v`transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);`:v`transformPosition(proj, view, vpos);`}\n    }\n  `),P.include(o,j),R.include(c),j.draped&&R.uniforms.add(new u(\"texelSize\",((e,o)=>1/o.camera.pixelRatio))),j.output===e.Highlight&&P.include(i),T&&P.include(n,j),j.output!==e.Highlight&&(R.code.add(v`\n      const float lineWidth = ${v.float(j.lineWidth)};\n      const float spacing = ${v.float(j.patternSpacing)};\n      const float spacingINV = ${v.float(1/j.patternSpacing)};\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    `),j.draped||R.code.add(v`const int maxSamples = 5;\nfloat sample(float p) {\nvec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\nfloat fwidth = dxdy.x + dxdy.y;\nivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\nvec2 invSamples = 1.0 / vec2(samples);\nfloat accumulator = 0.0;\nfor (int j = 0; j < maxSamples; j++) {\nif(j >= samples.y) {\nbreak;\n}\nfor (int i = 0; i < maxSamples; i++) {\nif(i >= samples.x) {\nbreak;\n}\nvec2 step = vec2(i,j) * invSamples - 0.5;\naccumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n}\n}\naccumulator /= float(samples.x * samples.y);\nreturn accumulator;\n}`)),R.uniforms.add(new g(\"uColor\",(e=>e.color))),R.code.add(v`\n    void main() {\n      discardBySlice(vpos);\n      ${T?\"terrainDepthTest(gl_FragCoord, depth);\":\"\"}\n      vec4 color = ${j.hasVertexColors?\"vColor * uColor;\":\"uColor;\"}\n      color = highlightSlice(color, vpos);\n\n      ${j.output!==e.Highlight?v`color.a *= ${x(j)};`:\"\"}\n\n      if (color.a < ${v.float(l)}) {\n        discard;\n      }\n\n      ${j.output===e.Alpha?v`gl_FragColor = vec4(color.a);`:\"\"}\n\n      ${j.output===e.Color?v`gl_FragColor = color; ${j.transparencyPassType===f.Color?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}`:\"\"}\n      ${j.output===e.Highlight?v`outputHighlight();`:\"\"}\n      ${j.output===e.Depth?v`outputDepth(linearDepth);`:\"\"};\n    }\n  `),P}function x(e){function o(o){return e.draped?v`coverage(vuv.${o}, texelSize)`:v`sample(vuv.${o})`}switch(e.style){case w.ForwardDiagonal:case w.Horizontal:return o(\"y\");case w.BackwardDiagonal:case w.Vertical:return o(\"x\");case w.DiagonalCross:case w.Cross:return v`\n        1.0 - (1.0 - ${o(\"x\")}) * (1.0 - ${o(\"y\")})\n      `;default:return\"0.0\"}}const P=Object.freeze(Object.defineProperty({__proto__:null,build:j},Symbol.toStringTag,{value:\"Module\"}));export{P,j as b};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,YAAY,IAAIC,CAAvB,QAA6B,oEAA7B;AAAkG,SAAOC,SAAS,IAAIC,CAApB,QAA0B,2DAA1B;AAAsF,SAAOC,SAAS,IAAIC,CAApB,QAA0B,+DAA1B;AAA0F,SAAOC,WAAW,IAAIC,CAAtB,QAA4B,4EAA5B;AAAyG,SAAOC,WAAW,IAAIC,CAAtB,QAA4B,wEAA5B;AAAqG,SAAOC,eAAe,IAAIC,CAA1B,QAAgC,4EAAhC;AAA6G,SAAOC,oBAAoB,IAAIC,CAA/B,QAAqC,kFAArC;AAAwH,SAAOC,iBAAiB,IAAIC,CAA5B,QAAkC,iEAAlC;AAAoG,SAAOC,eAAe,IAAIC,CAA1B,QAAgC,0EAAhC;AAA2G,SAAOC,sBAAsB,IAAIC,CAAjC,EAAmCC,iBAAiB,IAAIC,CAAxD,QAA8D,+DAA9D;AAA8H,SAAOC,iBAAiB,IAAIC,CAA5B,QAAkC,kEAAlC;AAAqG,SAAOC,iBAAiB,IAAIC,CAA5B,QAAkC,kEAAlC;AAAqG,SAAOC,gBAAgB,IAAIC,CAA3B,QAAiC,iEAAjC;AAAmG,SAAOC,IAAI,IAAIC,CAAf,QAAqB,2DAArB;AAAiF,SAAOC,aAAa,IAAIC,CAAxB,QAA8B,8DAA9B;AAA6F,SAAOC,oBAAoB,IAAIC,CAA/B,QAAqC,iDAArC;AAAuF,SAAOC,eAAe,IAAIC,CAA1B,QAAgC,iDAAhC;AAAkF,SAAOC,KAAK,IAAIC,CAAhB,QAAsB,oDAAtB;AAA2E,MAAMC,CAAC,GAAC,YAAR;AAAA,MAAqBC,CAAC,GAACD,CAAvB;AAAA,MAAyBE,CAAC,GAAC,YAA3B;;AAAwC,SAASC,CAAT,CAAWA,CAAX,EAAa;EAAC,MAAMC,CAAC,GAAC,IAAIX,CAAJ,EAAR;EAAA,MAAcY,CAAC,GAACF,CAAC,CAACG,mBAAF,KAAwBH,CAAC,CAACI,MAAF,KAAW5C,CAAC,CAAC6C,KAAb,IAAoBL,CAAC,CAACI,MAAF,KAAW5C,CAAC,CAAC8C,KAAzD,CAAhB;EAAgFN,CAAC,CAACO,MAAF,IAAUN,CAAC,CAACO,UAAF,CAAaC,GAAb,CAAiB,6BAAjB,CAAV;EAA0D,MAAMC,CAAC,GAACV,CAAC,CAACI,MAAF,KAAW5C,CAAC,CAACmD,KAArB;EAAA,MAA2B;IAACC,MAAM,EAACC,CAAR;IAAUC,QAAQ,EAACC;EAAnB,IAAsBd,CAAjD;EAAmDvB,CAAC,CAACuB,CAAD,EAAGD,CAAH,CAAD,EAAOC,CAAC,CAACe,OAAF,CAAUpD,CAAV,EAAY;IAACqD,sBAAsB,EAAC,CAAC,CAAzB;IAA2BC,WAAW,EAACR;EAAvC,CAAZ,CAAP,EAA8DT,CAAC,CAACe,OAAF,CAAUlD,CAAV,EAAYkC,CAAZ,CAA9D,EAA6EU,CAAC,KAAGT,CAAC,CAACe,OAAF,CAAUhD,CAAV,EAAYgC,CAAZ,GAAea,CAAC,CAACM,QAAF,CAAWV,GAAX,CAAe,IAAI3B,CAAJ,CAAM,SAAN,EAAiB,CAACtB,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAAC0D,MAAF,CAASC,OAAjC,CAAf,CAAf,EAA0EpB,CAAC,CAACqB,QAAF,CAAWb,GAAX,CAAe,aAAf,EAA6B,OAA7B,CAA7E,CAA9E,EAAkMT,CAAC,CAACO,MAAF,GAASM,CAAC,CAACM,QAAF,CAAWV,GAAX,CAAe,IAAIvB,CAAJ,CAAM,oBAAN,EAA4B,CAAC1B,CAAD,EAAGE,CAAH,KAAO,IAAEA,CAAC,CAAC6D,gBAAvC,CAAf,CAAT,GAAmFtB,CAAC,CAACuB,UAAF,CAAaf,GAAb,CAAiBf,CAAC,CAAC+B,YAAnB,EAAgC,MAAhC,CAArR,EAA6TxB,CAAC,CAACuB,UAAF,CAAaf,GAAb,CAAiBf,CAAC,CAACgC,QAAnB,EAA4B,MAA5B,CAA7T,EAAiWzB,CAAC,CAACuB,UAAF,CAAaf,GAAb,CAAiBf,CAAC,CAACiC,UAAnB,EAA8B,MAA9B,CAAjW,EAAuY1B,CAAC,CAACqB,QAAF,CAAWb,GAAX,CAAe,MAAf,EAAsB,MAAtB,CAAvY,EAAqaR,CAAC,CAACqB,QAAF,CAAWb,GAAX,CAAe,KAAf,EAAqB,MAArB,CAAra,EAAkcP,CAAC,IAAED,CAAC,CAACqB,QAAF,CAAWb,GAAX,CAAe,OAAf,EAAuB,OAAvB,CAArc;EAAqe,MAAMmB,CAAC,GAAC5B,CAAC,CAAC6B,KAAF,KAAUjC,CAAC,CAACkC,eAAZ,IAA6B9B,CAAC,CAAC6B,KAAF,KAAUjC,CAAC,CAACmC,gBAAzC,IAA2D/B,CAAC,CAAC6B,KAAF,KAAUjC,CAAC,CAACoC,aAA/E;EAA6F,OAAOJ,CAAC,IAAEf,CAAC,CAACoB,IAAF,CAAOxB,GAAP,CAAWrB,CAAE;AAC7iF,mCAAmCA,CAAC,CAAC8C,KAAF,CAAQrC,CAAR,CAAW,KAAIT,CAAC,CAAC8C,KAAF,CAAQ,CAACpC,CAAT,CAAY;AAC9D,mCAAmCV,CAAC,CAAC8C,KAAF,CAAQpC,CAAR,CAAW,KAAIV,CAAC,CAAC8C,KAAF,CAAQrC,CAAR,CAAW;AAC7D,KAHgiF,CAAH,EAGthFG,CAAC,CAACO,MAAF,KAAW3B,CAAC,CAACiC,CAAD,EAAGb,CAAH,CAAD,EAAOa,CAAC,CAACM,QAAF,CAAWV,GAAX,CAAe,IAAIvB,CAAJ,CAAM,+BAAN,EAAuC,CAAC1B,CAAD,EAAGE,CAAH,KAAO,IAAEA,CAAC,CAAC0D,MAAF,CAASe,mBAAzD,CAAf,CAAP,EAAsGtB,CAAC,CAACoB,IAAF,CAAOxB,GAAP,CAAWrB,CAAE;AACrI;AACA;AACA,EAHwH,CAAtG,EAGdyB,CAAC,CAACoB,IAAF,CAAOxB,GAAP,CAAWrB,CAAE;AACjB;AACA;AACA;AACA,EAJI,CAHc,EAOdyB,CAAC,CAACoB,IAAF,CAAOxB,GAAP,CAAWrB,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+BA,CAAC,CAAC8C,KAAF,CAAQnC,CAAR,CAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KA9BI,CAPG,CAHshF,EAwCrhFc,CAAC,CAACoB,IAAF,CAAOxB,GAAP,CAAWrB,CAAE;AACrB;AACA,gCAAgCwC,CAAC,GAAC,aAAD,GAAe,EAAG;AACnD,0CAA0CA,CAAC,GAAC,aAAD,GAAe,EAAG;AAC7D;AACA,QAAQ5B,CAAC,CAACO,MAAF,GAAS,EAAT,GAAYnB,CAAE;AACtB;AACA;AACA,WAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuEA,CAAC,CAAC8C,KAAF,CAAQlC,CAAC,CAACoC,cAAV,CAA0B;AACjG;AACA;AACA,GAnBQ,CAxCqhF,EA2DxhFvB,CAAC,CAACoB,IAAF,CAAOxB,GAAP,CAAWrB,CAAE;AAClB;AACA;AACA;AACA,QAAQc,CAAC,GAAC,qCAAD,GAAuC,EAAG;AACnD;AACA,sBAAsBQ,CAAC,GAACtB,CAAE,qEAAH,GAAwEA,CAAE,sCAAsC;AACvI;AACA,GARK,CA3DwhF,EAmExhFa,CAAC,CAACe,OAAF,CAAUtD,CAAV,EAAYsC,CAAZ,CAnEwhF,EAmEzgFe,CAAC,CAACC,OAAF,CAAUxC,CAAV,CAnEygF,EAmE5/EwB,CAAC,CAACO,MAAF,IAAUQ,CAAC,CAACI,QAAF,CAAWV,GAAX,CAAe,IAAIvB,CAAJ,CAAM,WAAN,EAAmB,CAAC1B,CAAD,EAAGE,CAAH,KAAO,IAAEA,CAAC,CAAC0D,MAAF,CAASiB,UAArC,CAAf,CAnEk/E,EAmEh7ErC,CAAC,CAACI,MAAF,KAAW5C,CAAC,CAAC8E,SAAb,IAAwBrC,CAAC,CAACe,OAAF,CAAU9C,CAAV,CAnEw5E,EAmE34EgC,CAAC,IAAED,CAAC,CAACe,OAAF,CAAU5C,CAAV,EAAY4B,CAAZ,CAnEw4E,EAmEz3EA,CAAC,CAACI,MAAF,KAAW5C,CAAC,CAAC8E,SAAb,KAAyBvB,CAAC,CAACkB,IAAF,CAAOxB,GAAP,CAAWrB,CAAE;AAC1M,gCAAgCA,CAAC,CAAC8C,KAAF,CAAQlC,CAAC,CAACuC,SAAV,CAAqB;AACrD,8BAA8BnD,CAAC,CAAC8C,KAAF,CAAQlC,CAAC,CAACoC,cAAV,CAA0B;AACxD,iCAAiChD,CAAC,CAAC8C,KAAF,CAAQ,IAAElC,CAAC,CAACoC,cAAZ,CAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAnB6L,GAmBtLpC,CAAC,CAACO,MAAF,IAAUQ,CAAC,CAACkB,IAAF,CAAOxB,GAAP,CAAWrB,CAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EArBiB,CAnBmJ,CAnEy3E,EA2GxhF2B,CAAC,CAACI,QAAF,CAAWV,GAAX,CAAe,IAAIzB,CAAJ,CAAM,QAAN,EAAgBxB,CAAC,IAAEA,CAAC,CAACgF,KAArB,CAAf,CA3GwhF,EA2G3+EzB,CAAC,CAACkB,IAAF,CAAOxB,GAAP,CAAWrB,CAAE;AAC/D;AACA;AACA,QAAQc,CAAC,GAAC,wCAAD,GAA0C,EAAG;AACtD,qBAAqBF,CAAC,CAACyC,eAAF,GAAkB,kBAAlB,GAAqC,SAAU;AACpE;AACA;AACA,QAAQzC,CAAC,CAACI,MAAF,KAAW5C,CAAC,CAAC8E,SAAb,GAAuBlD,CAAE,cAAasD,CAAC,CAAC1C,CAAD,CAAI,GAA3C,GAA8C,EAAG;AACzD;AACA,sBAAsBZ,CAAC,CAAC8C,KAAF,CAAQ5D,CAAR,CAAW;AACjC;AACA;AACA;AACA,QAAQ0B,CAAC,CAACI,MAAF,KAAW5C,CAAC,CAAC8C,KAAb,GAAmBlB,CAAE,+BAArB,GAAoD,EAAG;AAC/D;AACA,QAAQY,CAAC,CAACI,MAAF,KAAW5C,CAAC,CAAC6C,KAAb,GAAmBjB,CAAE,yBAAwBY,CAAC,CAAC2C,oBAAF,KAAyBnD,CAAC,CAACa,KAA3B,GAAiC,gDAAjC,GAAkF,EAAG,EAAlI,GAAoI,EAAG;AAC/I,QAAQL,CAAC,CAACI,MAAF,KAAW5C,CAAC,CAAC8E,SAAb,GAAuBlD,CAAE,oBAAzB,GAA6C,EAAG;AACxD,QAAQY,CAAC,CAACI,MAAF,KAAW5C,CAAC,CAACmD,KAAb,GAAmBvB,CAAE,2BAArB,GAAgD,EAAG;AAC3D;AACA,GAnBkD,CA3G2+E,EA8HxhFa,CA9HihF;AA8H/gF;;AAAA,SAASyC,CAAT,CAAWlF,CAAX,EAAa;EAAC,SAASE,CAAT,CAAWA,CAAX,EAAa;IAAC,OAAOF,CAAC,CAAC+C,MAAF,GAASnB,CAAE,gBAAe1B,CAAE,cAA5B,GAA0C0B,CAAE,cAAa1B,CAAE,GAAlE;EAAqE;;EAAA,QAAOF,CAAC,CAACqE,KAAT;IAAgB,KAAKjC,CAAC,CAACkC,eAAP;IAAuB,KAAKlC,CAAC,CAACgD,UAAP;MAAkB,OAAOlF,CAAC,CAAC,GAAD,CAAR;;IAAc,KAAKkC,CAAC,CAACmC,gBAAP;IAAwB,KAAKnC,CAAC,CAACiD,QAAP;MAAgB,OAAOnF,CAAC,CAAC,GAAD,CAAR;;IAAc,KAAKkC,CAAC,CAACoC,aAAP;IAAqB,KAAKpC,CAAC,CAACkD,KAAP;MAAa,OAAO1D,CAAE;AAChR,uBAAuB1B,CAAC,CAAC,GAAD,CAAM,cAAaA,CAAC,CAAC,GAAD,CAAM;AAClD,OAFuQ;;IAE/P;MAAQ,OAAM,KAAN;EAFwF;AAE3E;;AAAA,MAAMuC,CAAC,GAAC8C,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,cAAP,CAAsB;EAACC,SAAS,EAAC,IAAX;EAAgBC,KAAK,EAACnD;AAAtB,CAAtB,EAA+CoD,MAAM,CAACC,WAAtD,EAAkE;EAACC,KAAK,EAAC;AAAP,CAAlE,CAAd,CAAR;AAA2G,SAAOrD,CAAP,EAASD,CAAC,IAAIH,CAAd"},"metadata":{},"sourceType":"module"}