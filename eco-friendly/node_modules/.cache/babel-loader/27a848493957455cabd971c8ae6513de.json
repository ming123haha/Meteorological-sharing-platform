{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { PrecipitationType as e } from \"../views/3d/environment/PrecipitationTechniqueConfiguration.js\";\nimport { Float3Uniform as t } from \"../views/3d/webgl-engine/core/shaderModules/Float3Uniform.js\";\nimport { FloatUniform as o } from \"../views/3d/webgl-engine/core/shaderModules/FloatUniform.js\";\nimport { glsl as i } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as r } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { Matrix4Uniform as a } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4Uniform.js\";\nimport { ShaderBuilder as n } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { VertexAttribute as s } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\n\nfunction d(d) {\n  const c = new n();\n  return c.attributes.add(s.POSITION, \"vec3\"), c.attributes.add(s.INSTANCEFEATUREATTRIBUTE, \"float\"), c.vertex.uniforms.add(new t(\"cameraPosition\")), c.vertex.uniforms.add(new t(\"offset\")), c.vertex.uniforms.add(new o(\"width\")), c.vertex.uniforms.add(new r(\"proj\", (e, t) => t.camera.projectionMatrix)), c.vertex.uniforms.add(new a(\"view\")), c.vertex.uniforms.add(new o(\"time\")), c.varyings.add(\"vUv\", \"vec2\"), c.vertex.code.add(i`\n    vec3 hash31(float p){\n      vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yzx + 33.33);\n      return fract((p3.xxy + p3.yzz) * p3.zyx);\n    }\n\n    float hash11(float p){\n      p = fract(p * 0.1031);\n      p *= p + 33.33;\n      p *= p + p;\n      return fract(p);\n    }\n\n    //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n    vec3 rotateVectorByQuaternion(vec3 v, vec4 q){\n      return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n    }\n\n    void main(void) {\n\n      vUv = position.xz;\n\n      vec3 rand = hash31(instanceFeatureAttribute);\n\n      // Set random position for all particles\n      // The hash function space is not high resolution so offset particles by an additional random value\n      // This creates grids of 1000 particles which are shifted by random hundreths of the tile width\n      // overlaying multiple identical but offset grids\n      vec3 randomPosition = 2.0 * (rand + (0.01 + 0.01 * rand) * floor(0.001 * instanceFeatureAttribute)) - 1.0;\n\n      // Random orientation of rain drops\n      float angle = 3.1415 * hash11(instanceFeatureAttribute);\n\n      vec3 up = vec3(0, 0, 1);\n\n      // Gravity and wind direction\n      vec3 direction = normalize(cameraPosition);\n\n      vec3 tangent = normalize(cross(direction, up));\n\n      // Gravity\n      vec3 animatedPos = randomPosition + direction * -time;\n\n      // Rain particles fall straight down and are randomly oriented\n      // Snow particles have random sinusoid trajectories and are rotated to face the camera\n      ${d.type === e.Rain ? i`\n            // Random rotation for particle\n            vec3 rotationAxis = up;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n            vec3 transformedPos = rotateVectorByQuaternion(vec3(0.2, 0.2, 4.0) * (position - vec3(0.5, 0.0, 0.5)), quat);\n\n            // Rotate particle to planetary position\n            rotationAxis = tangent;\n            angle = 0.5 * -acos(dot(direction, up));\n            quat = vec4(rotationAxis * sin(angle), cos(angle));\n            transformedPos = rotateVectorByQuaternion(transformedPos, quat);\n\n            vec4 pos = mat4(mat3(view)) * vec4(transformedPos + (mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * pos;\n      ` : i`\n            vec3 rotationAxis = direction;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n\n            tangent = rotateVectorByQuaternion(tangent, quat);\n            // Random sinusoid from friction\n            animatedPos += tangent * 0.25 * sin(dot(animatedPos, direction));\n            vec4 pos = mat4(mat3(view)) * vec4((mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * (0.5 * vec4(position.xzy, 0.0) + pos);\n      `}\n    }\n  `), c.fragment.uniforms.add(new o(\"opacity\")), c.fragment.uniforms.add(new t(\"particleColor\")), c.fragment.code.add(i`\n    void main() {\n\n      // Cut off corners of the triangle\n      if(vUv.x < 0.0 || vUv.y < 0.0){\n        discard;\n      }\n\n      float d = length(vUv - vec2(0.5));\n\n      ${d.type === e.Rain ? i`d = 0.35 * smoothstep(0.5, 0.0, d);` : i`d = smoothstep(0.5, 0.1, d);`}\n      gl_FragColor = opacity * vec4(particleColor * d, d);\n    }\n  `), c;\n}\n\nconst c = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: d\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { c as P, d as b };","map":{"version":3,"names":["PrecipitationType","e","Float3Uniform","t","FloatUniform","o","glsl","i","Matrix4PassUniform","r","Matrix4Uniform","a","ShaderBuilder","n","VertexAttribute","s","d","c","attributes","add","POSITION","INSTANCEFEATUREATTRIBUTE","vertex","uniforms","camera","projectionMatrix","varyings","code","type","Rain","fragment","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","P","b"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/chunks/Precipitation.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{PrecipitationType as e}from\"../views/3d/environment/PrecipitationTechniqueConfiguration.js\";import{Float3Uniform as t}from\"../views/3d/webgl-engine/core/shaderModules/Float3Uniform.js\";import{FloatUniform as o}from\"../views/3d/webgl-engine/core/shaderModules/FloatUniform.js\";import{glsl as i}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as r}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{Matrix4Uniform as a}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4Uniform.js\";import{ShaderBuilder as n}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{VertexAttribute as s}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function d(d){const c=new n;return c.attributes.add(s.POSITION,\"vec3\"),c.attributes.add(s.INSTANCEFEATUREATTRIBUTE,\"float\"),c.vertex.uniforms.add(new t(\"cameraPosition\")),c.vertex.uniforms.add(new t(\"offset\")),c.vertex.uniforms.add(new o(\"width\")),c.vertex.uniforms.add(new r(\"proj\",((e,t)=>t.camera.projectionMatrix))),c.vertex.uniforms.add(new a(\"view\")),c.vertex.uniforms.add(new o(\"time\")),c.varyings.add(\"vUv\",\"vec2\"),c.vertex.code.add(i`\n    vec3 hash31(float p){\n      vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yzx + 33.33);\n      return fract((p3.xxy + p3.yzz) * p3.zyx);\n    }\n\n    float hash11(float p){\n      p = fract(p * 0.1031);\n      p *= p + 33.33;\n      p *= p + p;\n      return fract(p);\n    }\n\n    //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n    vec3 rotateVectorByQuaternion(vec3 v, vec4 q){\n      return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n    }\n\n    void main(void) {\n\n      vUv = position.xz;\n\n      vec3 rand = hash31(instanceFeatureAttribute);\n\n      // Set random position for all particles\n      // The hash function space is not high resolution so offset particles by an additional random value\n      // This creates grids of 1000 particles which are shifted by random hundreths of the tile width\n      // overlaying multiple identical but offset grids\n      vec3 randomPosition = 2.0 * (rand + (0.01 + 0.01 * rand) * floor(0.001 * instanceFeatureAttribute)) - 1.0;\n\n      // Random orientation of rain drops\n      float angle = 3.1415 * hash11(instanceFeatureAttribute);\n\n      vec3 up = vec3(0, 0, 1);\n\n      // Gravity and wind direction\n      vec3 direction = normalize(cameraPosition);\n\n      vec3 tangent = normalize(cross(direction, up));\n\n      // Gravity\n      vec3 animatedPos = randomPosition + direction * -time;\n\n      // Rain particles fall straight down and are randomly oriented\n      // Snow particles have random sinusoid trajectories and are rotated to face the camera\n      ${d.type===e.Rain?i`\n            // Random rotation for particle\n            vec3 rotationAxis = up;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n            vec3 transformedPos = rotateVectorByQuaternion(vec3(0.2, 0.2, 4.0) * (position - vec3(0.5, 0.0, 0.5)), quat);\n\n            // Rotate particle to planetary position\n            rotationAxis = tangent;\n            angle = 0.5 * -acos(dot(direction, up));\n            quat = vec4(rotationAxis * sin(angle), cos(angle));\n            transformedPos = rotateVectorByQuaternion(transformedPos, quat);\n\n            vec4 pos = mat4(mat3(view)) * vec4(transformedPos + (mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * pos;\n      `:i`\n            vec3 rotationAxis = direction;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n\n            tangent = rotateVectorByQuaternion(tangent, quat);\n            // Random sinusoid from friction\n            animatedPos += tangent * 0.25 * sin(dot(animatedPos, direction));\n            vec4 pos = mat4(mat3(view)) * vec4((mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * (0.5 * vec4(position.xzy, 0.0) + pos);\n      `}\n    }\n  `),c.fragment.uniforms.add(new o(\"opacity\")),c.fragment.uniforms.add(new t(\"particleColor\")),c.fragment.code.add(i`\n    void main() {\n\n      // Cut off corners of the triangle\n      if(vUv.x < 0.0 || vUv.y < 0.0){\n        discard;\n      }\n\n      float d = length(vUv - vec2(0.5));\n\n      ${d.type===e.Rain?i`d = 0.35 * smoothstep(0.5, 0.0, d);`:i`d = smoothstep(0.5, 0.1, d);`}\n      gl_FragColor = opacity * vec4(particleColor * d, d);\n    }\n  `),c}const c=Object.freeze(Object.defineProperty({__proto__:null,build:d},Symbol.toStringTag,{value:\"Module\"}));export{c as P,d as b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}