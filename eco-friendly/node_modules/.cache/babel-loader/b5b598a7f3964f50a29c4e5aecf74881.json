{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { isSome as e } from \"../core/maybe.js\";\nimport { a as i } from \"./vec2.js\";\nimport { a as o } from \"./vec2f64.js\";\nimport { Z as r } from \"./vec4f64.js\";\nimport { SliceDraw as t } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { AlignPixel as a } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";\nimport { HUD as l } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";\nimport { multipassGeometryTest as n } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";\nimport { addScreenSizePerspectiveAlignment as s } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";\nimport { Float2PassUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as p } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as g } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { VertexAttribute as h } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\n\nfunction S(o) {\n  const r = new g();\n  r.include(a), r.include(l, o), r.include(t, o), r.attributes.add(h.UV0, \"vec2\");\n  const {\n    vertex: S,\n    fragment: u\n  } = r;\n  return S.uniforms.add([new c(\"viewport\", (e, i) => i.camera.fullViewport), new f(\"lineSize\", (e, i) => Math.ceil(e.size) * i.camera.pixelRatio), new d(\"pixelToNDC\", (e, o) => i(m, 2 / o.camera.fullViewport[2], 2 / o.camera.fullViewport[3])), new f(\"borderSize\", (i, o) => e(i.borderColor) ? o.camera.pixelRatio : 0), new d(\"screenOffset\", (e, o) => i(m, e.screenOffset[0] * o.camera.pixelRatio, e.screenOffset[1] * o.camera.pixelRatio))]), r.varyings.add(\"coverageSampling\", \"vec4\"), r.varyings.add(\"lineSizes\", \"vec2\"), o.hasMultipassGeometry && r.varyings.add(\"depth\", \"float\"), o.hasScreenSizePerspective && s(S), S.code.add(p`\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 endPoint = projectPositionHUD(projectAux);\n\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n    ${o.occlusionTestEnabled ? p`\n      if (!testVisibilityHUD(endPoint)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }` : \"\"}\n\n    ${o.hasScreenSizePerspective ? p`\n      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n        ` : p`\n      vec2 screenOffsetScaled = screenOffset;\n        `}\n      // Add view dependent polygon offset to get exact same original starting point. This is mostly\n      // used to get the correct depth value\n      vec3 posView = (view * vec4(position, 1.0)).xyz;\n      ${o.hasMultipassGeometry ? \"depth = posView.z;\" : \"\"}\n\n      applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n      vec4 startPoint = proj * vec4(posView, 1.0);\n      // Apply screen offset to both start and end point\n      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n      startPoint.xy += screenOffsetNorm * startPoint.w;\n      endPoint.xy += screenOffsetNorm * endPoint.w;\n      // Align start and end to pixel origin\n      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${o.depthHudEnabled ? o.depthHudAlignStartEnabled ? p`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);` : p`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);` : \"\"}\n      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n      // The direction of the line in screen space\n      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${o.hasScreenSizePerspective ? p`\n      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n        ` : p`\n      float lineSizeScaled = lineSize;\n      float borderSizeScaled = borderSize;\n        `}\n      float halfPixelSize = lineSizeScaled * 0.5;\n      // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned\n      // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,\n      // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel\n      // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).\n      float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n      float halfPixelSizeInt = floor(halfWholePixelSize);\n\n      // Sub-pixel offset if we need to grow sub-pixels to the left\n      float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n\n      // Pixel offset aligning to whole pixels and adding subpixel offset if needed\n      float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n\n      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n      float padding = 1.0 + borderSizeScaled;\n      vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n      // Offset x/y from the center of the line in screen space\n      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n      // Compute a coverage varying which we can use in the fragment shader to determine\n      // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n      // This works by computing two coordinates that can be linearly interpolated and then\n      // subtracted to find out how far away from the line edge we are.\n      float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n      float halfBorderSize = 0.5 * borderSizeScaled;\n      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n      coverageSampling = vec4(\n        // Edge coordinate\n        outerEdgeCoverageSampler,\n\n        // Border edge coordinate\n        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n        // Line offset\n        halfPixelSize - 0.5,\n\n        // Border offset\n        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n      );\n\n      lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n\n      gl_Position = projectedPosition;\n    }\n  `), u.uniforms.add([new c(\"uColor\", e => v(e.color)), new c(\"borderColor\", e => v(e.borderColor))]), o.hasMultipassGeometry && (u.include(n, o), u.uniforms.add(new d(\"inverseViewport\", (e, i) => i.inverseViewport))), u.code.add(p`\n    void main() {\n      ${o.hasMultipassGeometry ? \"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\" : \"\"}\n\n      // Mix between line and border coverage offsets depending on whether we need\n      // a border (based on the sidedness).\n      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n      // Mix between border and line color based on the line coverage (conceptually the line\n      // blends on top of the border background).\n      //\n      // Anti-alias by blending final result using the full (including optional border) coverage\n      // and the color alpha\n      float borderAlpha = uColor.a * borderColor.a * coverage.y;\n      float colorAlpha = uColor.a * coverage.x;\n\n      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n\n    ${o.depthHudEnabled ? p`\n      if (finalAlpha < 0.01) {\n        discard;\n      }\n      ` : p`\n      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\n      gl_FragColor = vec4(finalRgb, finalAlpha);\n      `}\n  }\n  `), r;\n}\n\nfunction v(i) {\n  return e(i) ? i : r;\n}\n\nconst m = o(),\n      u = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: S\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { u as L, S as b };","map":{"version":3,"names":["isSome","e","a","i","o","Z","r","SliceDraw","t","AlignPixel","HUD","l","multipassGeometryTest","n","addScreenSizePerspectiveAlignment","s","Float2PassUniform","d","Float4PassUniform","c","FloatPassUniform","f","glsl","p","ShaderBuilder","g","VertexAttribute","h","S","include","attributes","add","UV0","vertex","fragment","u","uniforms","camera","fullViewport","Math","ceil","size","pixelRatio","m","borderColor","screenOffset","varyings","hasMultipassGeometry","hasScreenSizePerspective","code","occlusionTestEnabled","depthHudEnabled","depthHudAlignStartEnabled","v","color","inverseViewport","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","L","b"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/chunks/LineCallout.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{isSome as e}from\"../core/maybe.js\";import{a as i}from\"./vec2.js\";import{a as o}from\"./vec2f64.js\";import{Z as r}from\"./vec4f64.js\";import{SliceDraw as t}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{AlignPixel as a}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";import{HUD as l}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";import{multipassGeometryTest as n}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";import{addScreenSizePerspectiveAlignment as s}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";import{Float2PassUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as p}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as g}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{VertexAttribute as h}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function S(o){const r=new g;r.include(a),r.include(l,o),r.include(t,o),r.attributes.add(h.UV0,\"vec2\");const{vertex:S,fragment:u}=r;return S.uniforms.add([new c(\"viewport\",((e,i)=>i.camera.fullViewport)),new f(\"lineSize\",((e,i)=>Math.ceil(e.size)*i.camera.pixelRatio)),new d(\"pixelToNDC\",((e,o)=>i(m,2/o.camera.fullViewport[2],2/o.camera.fullViewport[3]))),new f(\"borderSize\",((i,o)=>e(i.borderColor)?o.camera.pixelRatio:0)),new d(\"screenOffset\",((e,o)=>i(m,e.screenOffset[0]*o.camera.pixelRatio,e.screenOffset[1]*o.camera.pixelRatio)))]),r.varyings.add(\"coverageSampling\",\"vec4\"),r.varyings.add(\"lineSizes\",\"vec2\"),o.hasMultipassGeometry&&r.varyings.add(\"depth\",\"float\"),o.hasScreenSizePerspective&&s(S),S.code.add(p`\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 endPoint = projectPositionHUD(projectAux);\n\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n    ${o.occlusionTestEnabled?p`\n      if (!testVisibilityHUD(endPoint)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }`:\"\"}\n\n    ${o.hasScreenSizePerspective?p`\n      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n        `:p`\n      vec2 screenOffsetScaled = screenOffset;\n        `}\n      // Add view dependent polygon offset to get exact same original starting point. This is mostly\n      // used to get the correct depth value\n      vec3 posView = (view * vec4(position, 1.0)).xyz;\n      ${o.hasMultipassGeometry?\"depth = posView.z;\":\"\"}\n\n      applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n      vec4 startPoint = proj * vec4(posView, 1.0);\n      // Apply screen offset to both start and end point\n      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n      startPoint.xy += screenOffsetNorm * startPoint.w;\n      endPoint.xy += screenOffsetNorm * endPoint.w;\n      // Align start and end to pixel origin\n      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${o.depthHudEnabled?o.depthHudAlignStartEnabled?p`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);`:p`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);`:\"\"}\n      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n      // The direction of the line in screen space\n      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${o.hasScreenSizePerspective?p`\n      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n        `:p`\n      float lineSizeScaled = lineSize;\n      float borderSizeScaled = borderSize;\n        `}\n      float halfPixelSize = lineSizeScaled * 0.5;\n      // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned\n      // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,\n      // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel\n      // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).\n      float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n      float halfPixelSizeInt = floor(halfWholePixelSize);\n\n      // Sub-pixel offset if we need to grow sub-pixels to the left\n      float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n\n      // Pixel offset aligning to whole pixels and adding subpixel offset if needed\n      float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n\n      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n      float padding = 1.0 + borderSizeScaled;\n      vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n      // Offset x/y from the center of the line in screen space\n      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n      // Compute a coverage varying which we can use in the fragment shader to determine\n      // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n      // This works by computing two coordinates that can be linearly interpolated and then\n      // subtracted to find out how far away from the line edge we are.\n      float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n      float halfBorderSize = 0.5 * borderSizeScaled;\n      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n      coverageSampling = vec4(\n        // Edge coordinate\n        outerEdgeCoverageSampler,\n\n        // Border edge coordinate\n        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n        // Line offset\n        halfPixelSize - 0.5,\n\n        // Border offset\n        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n      );\n\n      lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n\n      gl_Position = projectedPosition;\n    }\n  `),u.uniforms.add([new c(\"uColor\",(e=>v(e.color))),new c(\"borderColor\",(e=>v(e.borderColor)))]),o.hasMultipassGeometry&&(u.include(n,o),u.uniforms.add(new d(\"inverseViewport\",((e,i)=>i.inverseViewport)))),u.code.add(p`\n    void main() {\n      ${o.hasMultipassGeometry?\"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\":\"\"}\n\n      // Mix between line and border coverage offsets depending on whether we need\n      // a border (based on the sidedness).\n      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n      // Mix between border and line color based on the line coverage (conceptually the line\n      // blends on top of the border background).\n      //\n      // Anti-alias by blending final result using the full (including optional border) coverage\n      // and the color alpha\n      float borderAlpha = uColor.a * borderColor.a * coverage.y;\n      float colorAlpha = uColor.a * coverage.x;\n\n      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n\n    ${o.depthHudEnabled?p`\n      if (finalAlpha < 0.01) {\n        discard;\n      }\n      `:p`\n      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\n      gl_FragColor = vec4(finalRgb, finalAlpha);\n      `}\n  }\n  `),r}function v(i){return e(i)?i:r}const m=o(),u=Object.freeze(Object.defineProperty({__proto__:null,build:S},Symbol.toStringTag,{value:\"Module\"}));export{u as L,S as b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}