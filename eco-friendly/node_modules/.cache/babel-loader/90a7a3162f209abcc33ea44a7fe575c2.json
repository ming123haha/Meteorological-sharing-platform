{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { clamp as o } from \"../../../../../../core/mathUtils.js\";\nimport { isSome as t } from \"../../../../../../core/maybe.js\";\nimport { a } from \"../../../../../../chunks/vec2.js\";\nimport { Z as e, a as r } from \"../../../../../../chunks/vec2f64.js\";\nimport { earth as i } from \"../../../../../../geometry/support/Ellipsoid.js\";\nimport { FadeInOutStages as c } from \"../../../../environment/CloudsCompositionParameters.js\";\nimport { BooleanPassUniform as n } from \"../../shaderModules/BooleanPassUniform.js\";\nimport { Float2PassUniform as d } from \"../../shaderModules/Float2PassUniform.js\";\nimport { Float3PassUniform as l } from \"../../shaderModules/Float3PassUniform.js\";\nimport { FloatPassUniform as s } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as u } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as m } from \"../../shaderModules/Matrix4PassUniform.js\";\nimport { TextureCubePassUniform as C } from \"../../shaderModules/TextureCubePassUniform.js\";\n\nfunction v(r) {\n  const v = r.fragment;\n  v.uniforms.add([new m(\"rotationMatrixClouds\", (o, t) => t.clouds.parallax.transform), new m(\"rotationMatrixCloudsCrossFade\", (o, t) => t.clouds.parallaxNew.transform), new l(\"anchorPosition\", (o, t) => t.clouds.parallax.anchorPointClouds), new l(\"anchorPositionCrossFade\", (o, t) => t.clouds.parallaxNew.anchorPointClouds), new d(\"cloudVariables\", (o, r) => t(r.clouds.data) ? a(h, r.clouds.data.coverage, r.clouds.data.absorption) : e), new s(\"cloudsHeight\", (o, t) => t.clouds.parallax.cloudsHeight), new s(\"radiusCurvatureCorrectionFactor\", (o, t) => t.clouds.parallax.radiusCurvatureCorrectionFactor), new s(\"totalFadeInOut\", (t, a) => a.clouds.fadeInOut.stage === c.FINISHED ? a.clouds.fadeInOutHeight.factor + Math.max(o(a.clouds.fadeIn.factor, 0, 1)) : a.clouds.fadeInOutHeight.factor + Math.max(o(a.clouds.fadeInOut.factor, 0, 1))), new s(\"crossFadeAnchorFactor\", (t, a) => o(a.clouds.crossFade.factor, 0, 1)), new C(\"cubeMap\", (o, a) => t(a.clouds.data) ? a.clouds.data.cubeMap.colorTexture : null), new n(\"crossFade\", (o, t) => t.clouds.crossFade.enabled)]), v.constants.add(\"planetRadius\", \"float\", i.radius), v.code.add(u`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)\n{\nfloat radiusClouds = planetRadius + cloudsHeight;\nfloat B = 2.0 * dot(cameraPosition, dir);\nfloat C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;\nfloat det = B * B - 4.0 * C;\nfloat pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));\nvec3 intersectionPont = cameraPosition + dir * pointIntDist;\nintersectionPont =  intersectionPont - spherePos;\nreturn intersectionPont;\n}`), v.code.add(u`vec3 correctForPlanetCurvature(vec3 dir)\n{\ndir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;\nreturn dir;\n}`), v.code.add(u`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)\n{\nreturn (rotMat * vec4(inVec, 0.0)).xyz;\n}`), v.uniforms.add([new l(\"lightingMainDirection\", (o, t) => t.lighting.lightingMainDirection), new l(\"lightingMainIntensity\", (o, t) => t.lighting.mainLight.intensity)]), v.code.add(u`const float SUNSET_TRANSITION_FACTOR = 0.3;\nconst vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);\nconst float RIM_SCATTERING_FACTOR = 140.0;\nconst float BACKLIGHT_FACTOR = 0.2;\nconst float BACKLIGHT_SCATTERING_FACTOR = 10.0;\nconst float BACKLIGHT_TRANSITION_FACTOR = 0.3;\nvec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)\n{\nfloat upDotLight = dot(normalize(cameraPosition), normalize(lightingMainDirection));\nfloat dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(lightingMainDirection)), 0.0);\nfloat sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);\nvec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);\nvec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);\nvec3 combinedLight = clamp((lightingMainIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));\nvec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));\nfloat scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);\nfloat rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);\nvec3 directSunScattering = RIM_COLOR * rimLightIntensity * pow(dirDotLight, RIM_SCATTERING_FACTOR) * scatteringMod;\nfloat additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;\nreturn vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);\n}`), v.code.add(u`vec4 getCloudData(vec3 rayDir)\n{\nvec4 cloudData = textureCube(cubeMap, rayDir);\nfloat mu = dot(rayDir, vec3(0, 0, 1));\nreturn mix(vec4(vec3(clamp(1.0 - cloudVariables.y, 0.6, 1.0)), 0.0), cloudData, smoothstep(-0.01, mix(0.0, 0.075, cloudVariables.x), abs(mu)));\n}`), v.code.add(u`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected);\nfloat totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudData.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);\n}`), v.code.add(u`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected);\nvec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\nintersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);\nworldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));\nworldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\ncloudData = getCloudData(worldRayRotatedCorrected);\nvec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\ncloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);\nfloat totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudColor.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(cloudColor.rgb, totalTransmittance);\n}`), v.code.add(u`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)\n{\nreturn crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);\n}`);\n}\n\nconst h = r();\nexport { v as CloudsParallaxShading };","map":{"version":3,"names":["clamp","o","isSome","t","a","Z","e","r","earth","i","FadeInOutStages","c","BooleanPassUniform","n","Float2PassUniform","d","Float3PassUniform","l","FloatPassUniform","s","glsl","u","Matrix4PassUniform","m","TextureCubePassUniform","C","v","fragment","uniforms","add","clouds","parallax","transform","parallaxNew","anchorPointClouds","data","h","coverage","absorption","cloudsHeight","radiusCurvatureCorrectionFactor","fadeInOut","stage","FINISHED","fadeInOutHeight","factor","Math","max","fadeIn","crossFade","cubeMap","colorTexture","enabled","constants","radius","code","lighting","lightingMainDirection","mainLight","intensity","CloudsParallaxShading"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{clamp as o}from\"../../../../../../core/mathUtils.js\";import{isSome as t}from\"../../../../../../core/maybe.js\";import{a}from\"../../../../../../chunks/vec2.js\";import{Z as e,a as r}from\"../../../../../../chunks/vec2f64.js\";import{earth as i}from\"../../../../../../geometry/support/Ellipsoid.js\";import{FadeInOutStages as c}from\"../../../../environment/CloudsCompositionParameters.js\";import{BooleanPassUniform as n}from\"../../shaderModules/BooleanPassUniform.js\";import{Float2PassUniform as d}from\"../../shaderModules/Float2PassUniform.js\";import{Float3PassUniform as l}from\"../../shaderModules/Float3PassUniform.js\";import{FloatPassUniform as s}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as u}from\"../../shaderModules/interfaces.js\";import{Matrix4PassUniform as m}from\"../../shaderModules/Matrix4PassUniform.js\";import{TextureCubePassUniform as C}from\"../../shaderModules/TextureCubePassUniform.js\";function v(r){const v=r.fragment;v.uniforms.add([new m(\"rotationMatrixClouds\",((o,t)=>t.clouds.parallax.transform)),new m(\"rotationMatrixCloudsCrossFade\",((o,t)=>t.clouds.parallaxNew.transform)),new l(\"anchorPosition\",((o,t)=>t.clouds.parallax.anchorPointClouds)),new l(\"anchorPositionCrossFade\",((o,t)=>t.clouds.parallaxNew.anchorPointClouds)),new d(\"cloudVariables\",((o,r)=>t(r.clouds.data)?a(h,r.clouds.data.coverage,r.clouds.data.absorption):e)),new s(\"cloudsHeight\",((o,t)=>t.clouds.parallax.cloudsHeight)),new s(\"radiusCurvatureCorrectionFactor\",((o,t)=>t.clouds.parallax.radiusCurvatureCorrectionFactor)),new s(\"totalFadeInOut\",((t,a)=>a.clouds.fadeInOut.stage===c.FINISHED?a.clouds.fadeInOutHeight.factor+Math.max(o(a.clouds.fadeIn.factor,0,1)):a.clouds.fadeInOutHeight.factor+Math.max(o(a.clouds.fadeInOut.factor,0,1)))),new s(\"crossFadeAnchorFactor\",((t,a)=>o(a.clouds.crossFade.factor,0,1))),new C(\"cubeMap\",((o,a)=>t(a.clouds.data)?a.clouds.data.cubeMap.colorTexture:null)),new n(\"crossFade\",((o,t)=>t.clouds.crossFade.enabled))]),v.constants.add(\"planetRadius\",\"float\",i.radius),v.code.add(u`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)\n{\nfloat radiusClouds = planetRadius + cloudsHeight;\nfloat B = 2.0 * dot(cameraPosition, dir);\nfloat C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;\nfloat det = B * B - 4.0 * C;\nfloat pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));\nvec3 intersectionPont = cameraPosition + dir * pointIntDist;\nintersectionPont =  intersectionPont - spherePos;\nreturn intersectionPont;\n}`),v.code.add(u`vec3 correctForPlanetCurvature(vec3 dir)\n{\ndir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;\nreturn dir;\n}`),v.code.add(u`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)\n{\nreturn (rotMat * vec4(inVec, 0.0)).xyz;\n}`),v.uniforms.add([new l(\"lightingMainDirection\",((o,t)=>t.lighting.lightingMainDirection)),new l(\"lightingMainIntensity\",((o,t)=>t.lighting.mainLight.intensity))]),v.code.add(u`const float SUNSET_TRANSITION_FACTOR = 0.3;\nconst vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);\nconst float RIM_SCATTERING_FACTOR = 140.0;\nconst float BACKLIGHT_FACTOR = 0.2;\nconst float BACKLIGHT_SCATTERING_FACTOR = 10.0;\nconst float BACKLIGHT_TRANSITION_FACTOR = 0.3;\nvec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)\n{\nfloat upDotLight = dot(normalize(cameraPosition), normalize(lightingMainDirection));\nfloat dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(lightingMainDirection)), 0.0);\nfloat sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);\nvec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);\nvec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);\nvec3 combinedLight = clamp((lightingMainIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));\nvec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));\nfloat scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);\nfloat rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);\nvec3 directSunScattering = RIM_COLOR * rimLightIntensity * pow(dirDotLight, RIM_SCATTERING_FACTOR) * scatteringMod;\nfloat additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;\nreturn vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);\n}`),v.code.add(u`vec4 getCloudData(vec3 rayDir)\n{\nvec4 cloudData = textureCube(cubeMap, rayDir);\nfloat mu = dot(rayDir, vec3(0, 0, 1));\nreturn mix(vec4(vec3(clamp(1.0 - cloudVariables.y, 0.6, 1.0)), 0.0), cloudData, smoothstep(-0.01, mix(0.0, 0.075, cloudVariables.x), abs(mu)));\n}`),v.code.add(u`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected);\nfloat totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudData.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);\n}`),v.code.add(u`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected);\nvec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\nintersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);\nworldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));\nworldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\ncloudData = getCloudData(worldRayRotatedCorrected);\nvec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\ncloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);\nfloat totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudColor.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(cloudColor.rgb, totalTransmittance);\n}`),v.code.add(u`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)\n{\nreturn crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);\n}`)}const h=r();export{v as CloudsParallaxShading};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}