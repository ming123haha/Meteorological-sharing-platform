{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { a as e } from \"./mat4.js\";\nimport { c as t } from \"./mat4f64.js\";\nimport { TextureCoordinateAttribute as a, TextureCoordinateAttributeType as r } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";\nimport { ReadLinearDepth as i } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";\nimport { Gamma as o } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js\";\nimport { Float2PassUniform as n } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float2Uniform as s } from \"../views/3d/webgl-engine/core/shaderModules/Float2Uniform.js\";\nimport { Float3PassUniform as l } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { Float3Uniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Float3Uniform.js\";\nimport { Float4Uniform as h } from \"../views/3d/webgl-engine/core/shaderModules/Float4Uniform.js\";\nimport { FloatUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/FloatUniform.js\";\nimport { glsl as m } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as p } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as g } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DUniform.js\";\nimport { VertexAttribute as u } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\n\nfunction v(t) {\n  const v = new g();\n  v.attributes.add(u.POSITION, \"vec2\"), v.include(a, {\n    textureCoordinateType: r.Default\n  }), v.varyings.add(\"worldRay\", \"vec3\"), v.varyings.add(\"eyeDir\", \"vec3\");\n  const {\n    vertex: x,\n    fragment: D\n  } = v;\n  return x.uniforms.add([new p(\"inverseProjectionMatrix\", (e, t) => t.camera.inverseProjectionMatrix), new p(\"inverseViewMatrix\", (t, a) => e(y, a.camera.viewMatrix))]), x.code.add(m`void main(void) {\nvec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1, 1)).xyz;\neyeDir = posViewNear;\nworldRay = (inverseViewMatrix * vec4(posViewNear, 0)).xyz;\nforwardTextureCoordinates();\ngl_Position = vec4(position, 1, 1);\n}`), D.uniforms.add([new l(\"lightingMainDirection\", (e, t) => t.lighting.lightingMainDirection), new s(\"radii\"), new d(\"scaleHeight\"), new c(\"cameraPosition\"), new h(\"heightParameters\"), new d(\"innerFadeDistance\"), new d(\"altitudeFade\"), new f(\"depthTex\"), new c(\"betaRayleigh\"), new c(\"betaCombined\"), new d(\"betaMie\"), new d(\"hazeStrength\")]), v.include(o), t.haze && (D.include(i), D.uniforms.add(new n(\"nearFar\", (e, t) => t.camera.nearFar))), D.code.add(m`vec2 sphereIntersect(vec3 start, vec3 dir, float radius, bool planet) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = planet ? heightParameters[1] - radius * radius : heightParameters[2];\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}`), D.code.add(m`float chapmanApproximation(float X, float h, float cosZenith) {\nfloat c = sqrt(X + h);\nfloat cExpH = c * exp(-h);\nif (cosZenith >= 0.0) {\nreturn cExpH / (c * cosZenith + 1.0);\n} else {\nfloat x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);\nfloat c0 = sqrt(x0);\nreturn 2.0 * c0 * exp(X - x0) - cExpH / (1.0 - c * cosZenith);\n}\n}`), D.code.add(m`float getOpticalDepth(vec3 position, vec3 dir, float h) {\nreturn scaleHeight * chapmanApproximation(radii[0] / scaleHeight, h, dot(normalize(position), dir));\n}`), D.code.add(m`\n    const int STEPS = 6;\n\n    float getGlow(float dist, float radius, float intensity) {\n      return pow(radius / max(dist, 1e-6), intensity);\n    }\n\n    vec3 getAtmosphereColour(vec3 cameraPos, vec3 rayDir, vec3 lightDir, float terrainDepth) {\n      float reducedPlanetRadius = radii[0] - 20000.0;\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, reducedPlanetRadius, true);\n      vec2 rayAtmosphereIntersect = sphereIntersect(cameraPos, rayDir, radii[1], false);\n      bool hitsAtmosphere = (rayAtmosphereIntersect.x <= rayAtmosphereIntersect.y) && rayAtmosphereIntersect.x > 0.0;\n      bool insideAtmosphere = heightParameters[0] < radii[1];\n\n      if (!(hitsAtmosphere || insideAtmosphere)) {\n        return vec3(0);\n      }\n\n      bool hitsPlanet = (rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0;\n\n      float start = insideAtmosphere ? 0.0 : rayAtmosphereIntersect.x;\n\n      if (heightParameters[0] < reducedPlanetRadius) {\n        // Long light rays from the night side of the planet lead to numerical instability\n        // Do not render the atmosphere in such cases\n        if (dot(rayDir, normalize(cameraPos)) < -0.025) {\n          return vec3(0);\n        }\n        start = rayPlanetIntersect.y;\n      }\n\n      float end = hitsPlanet ? rayPlanetIntersect.x : rayAtmosphereIntersect.y;\n      float maxEnd = end;\n\n      ${t.haze ? m`if (terrainDepth != -1.0) { end = terrainDepth; }` : \"\"}\n\n      vec3 samplePoint = cameraPos + rayDir * end;\n      float multiplier = hitsPlanet ? -1.0 : 1.0;\n\n      vec3 scattering = vec3(0);\n      float scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n      float lastOpticalDepth = getOpticalDepth(samplePoint, rayDir, scaleFract);\n      float stepSize = (end - start) / float(STEPS);\n      for (int i = 0; i < STEPS; i++) {\n        samplePoint -= stepSize * rayDir;\n        scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n        float opticalDepth = multiplier * getOpticalDepth(samplePoint, rayDir * multiplier, scaleFract);\n\n        if (i > 0) {\n          scattering *= ${t.haze ? m`` : \" mix(2.5, 1.0, clamp((length(cameraPos) - radii[0]) / 50e3, 0.0, 1.0)) * \"} exp(-(mix(betaCombined, betaRayleigh, 0.5) + betaMie) * max(0.0, (opticalDepth - lastOpticalDepth)));\n        }\n\n        if (dot(normalize(samplePoint), lightDir) > -0.3) {\n\n          float scale = exp(-scaleFract);\n          float lightDepth = getOpticalDepth(samplePoint, lightDir, scaleFract);\n\n          scattering += scale * exp(-(betaCombined + betaMie) * lightDepth);\n          ${t.haze ? \"\" : m`scattering += scale * exp(-(0.25 * betaCombined ) * lightDepth);`}\n        }\n\n        lastOpticalDepth = opticalDepth;\n\n      }\n\n      float mu = dot(rayDir, lightDir);\n      float mumu = 1.0 + mu * mu;\n\n      float phaseRayleigh = 0.05968310365 * mumu;\n\n      ${t.haze ? m`return 3.0 * scattering * stepSize * phaseRayleigh * betaRayleigh;` : m`\n            const float g = 0.8;\n            const float gg = g * g;\n            float phaseMie = end == maxEnd ? 0.11936620731 * ((1.0 - gg) * mumu) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n            phaseMie += getGlow(1.0 - mu, 5e-5, 3.0) * smoothstep(0.01, 0.1, length(scattering));\n            phaseMie = clamp(phaseMie, 0.0, 128.0);\n            return 3.0 * scattering * stepSize * (phaseRayleigh * betaRayleigh + 0.025 * phaseMie * betaMie);`}\n    }\n\n    vec3 tonemapACES(vec3 x) {\n      return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n    }\n\n    vec4 applyUndergroundAtmosphere(vec3 rayDir, vec3 lightDirection, vec4 fragColor) {\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPosition, rayDir, radii[0], true);\n      if (!((rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.y > 0.0)) {\n        return fragColor;\n      }\n\n      float lightAngle = dot(lightDirection, normalize(cameraPosition + rayDir * max(0.0, rayPlanetIntersect.x)));\n      vec4 surfaceColor = vec4(vec3(max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)))), 1.0 - altitudeFade);\n      float relDist = (rayPlanetIntersect.y - max(0.0, rayPlanetIntersect.x)) / innerFadeDistance;\n      if (relDist > 1.0) {\n        return surfaceColor;\n      }\n\n      return mix(gl_FragColor, surfaceColor, smoothstep(0.0, 1.0, relDist * relDist));\n    }\n\n    void main() {\n      vec3 rayDir = normalize(worldRay);\n      float terrainDepth = -1.0;\n      ${t.haze ? m`\n          vec4 depthSample = texture2D(depthTex, vuv0).rgba;\n          if (depthSample != vec4(0)) {\n            vec3 cameraSpaceRay = normalize(eyeDir);\n            cameraSpaceRay /= cameraSpaceRay.z;\n            cameraSpaceRay *= -linearDepthFromTexture(depthTex, vuv0, nearFar);\n            terrainDepth = max(0.0, length(cameraSpaceRay));\n          }` : m`\n          float depthSample = texture2D(depthTex, vuv0).r;\n          if (depthSample != 1.0) {\n            gl_FragColor = vec4(0);\n            return;\n          }`}\n\n      ${t.haze ? m`\n            vec3 col = vec3(0);\n            float fadeOut = smoothstep(-10000.0, -15000.0, heightParameters[0] - radii[0]);\n            if(depthSample != vec4(0)){\n              col = (1.0 - fadeOut) * hazeStrength * getAtmosphereColour(cameraPosition, rayDir, lightingMainDirection, terrainDepth);\n            }\n            float alpha = 1.0 - fadeOut;` : m`\n            vec3 col = getAtmosphereColour(cameraPosition, rayDir, lightingMainDirection, terrainDepth);;\n            float alpha = smoothstep(0.0, mix(0.15, 0.01, heightParameters[3]), length(col));`}\n      col = tonemapACES(col);\n      gl_FragColor = delinearizeGamma(vec4(col, alpha));\n      ${t.haze ? \"\" : m`\n          if (depthSample == 1.0) {\n            gl_FragColor = applyUndergroundAtmosphere(rayDir, lightingMainDirection, gl_FragColor);\n          }`}\n    }\n  `), v;\n}\n\nconst y = t(),\n      x = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: v\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { x as C, v as b };","map":{"version":3,"names":["a","e","c","t","TextureCoordinateAttribute","TextureCoordinateAttributeType","r","ReadLinearDepth","i","Gamma","o","Float2PassUniform","n","Float2Uniform","s","Float3PassUniform","l","Float3Uniform","Float4Uniform","h","FloatUniform","d","glsl","m","Matrix4PassUniform","p","ShaderBuilder","g","Texture2DUniform","f","VertexAttribute","u","v","attributes","add","POSITION","include","textureCoordinateType","Default","varyings","vertex","x","fragment","D","uniforms","camera","inverseProjectionMatrix","y","viewMatrix","code","lighting","lightingMainDirection","haze","nearFar","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","C","b"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/chunks/ChapmanAtmosphere.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{a as e}from\"./mat4.js\";import{c as t}from\"./mat4f64.js\";import{TextureCoordinateAttribute as a,TextureCoordinateAttributeType as r}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";import{ReadLinearDepth as i}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{Gamma as o}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js\";import{Float2PassUniform as n}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float2Uniform as s}from\"../views/3d/webgl-engine/core/shaderModules/Float2Uniform.js\";import{Float3PassUniform as l}from\"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";import{Float3Uniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float3Uniform.js\";import{Float4Uniform as h}from\"../views/3d/webgl-engine/core/shaderModules/Float4Uniform.js\";import{FloatUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/FloatUniform.js\";import{glsl as m}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as g}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DUniform.js\";import{VertexAttribute as u}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function v(t){const v=new g;v.attributes.add(u.POSITION,\"vec2\"),v.include(a,{textureCoordinateType:r.Default}),v.varyings.add(\"worldRay\",\"vec3\"),v.varyings.add(\"eyeDir\",\"vec3\");const{vertex:x,fragment:D}=v;return x.uniforms.add([new p(\"inverseProjectionMatrix\",((e,t)=>t.camera.inverseProjectionMatrix)),new p(\"inverseViewMatrix\",((t,a)=>e(y,a.camera.viewMatrix)))]),x.code.add(m`void main(void) {\nvec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1, 1)).xyz;\neyeDir = posViewNear;\nworldRay = (inverseViewMatrix * vec4(posViewNear, 0)).xyz;\nforwardTextureCoordinates();\ngl_Position = vec4(position, 1, 1);\n}`),D.uniforms.add([new l(\"lightingMainDirection\",((e,t)=>t.lighting.lightingMainDirection)),new s(\"radii\"),new d(\"scaleHeight\"),new c(\"cameraPosition\"),new h(\"heightParameters\"),new d(\"innerFadeDistance\"),new d(\"altitudeFade\"),new f(\"depthTex\"),new c(\"betaRayleigh\"),new c(\"betaCombined\"),new d(\"betaMie\"),new d(\"hazeStrength\")]),v.include(o),t.haze&&(D.include(i),D.uniforms.add(new n(\"nearFar\",((e,t)=>t.camera.nearFar)))),D.code.add(m`vec2 sphereIntersect(vec3 start, vec3 dir, float radius, bool planet) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = planet ? heightParameters[1] - radius * radius : heightParameters[2];\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}`),D.code.add(m`float chapmanApproximation(float X, float h, float cosZenith) {\nfloat c = sqrt(X + h);\nfloat cExpH = c * exp(-h);\nif (cosZenith >= 0.0) {\nreturn cExpH / (c * cosZenith + 1.0);\n} else {\nfloat x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);\nfloat c0 = sqrt(x0);\nreturn 2.0 * c0 * exp(X - x0) - cExpH / (1.0 - c * cosZenith);\n}\n}`),D.code.add(m`float getOpticalDepth(vec3 position, vec3 dir, float h) {\nreturn scaleHeight * chapmanApproximation(radii[0] / scaleHeight, h, dot(normalize(position), dir));\n}`),D.code.add(m`\n    const int STEPS = 6;\n\n    float getGlow(float dist, float radius, float intensity) {\n      return pow(radius / max(dist, 1e-6), intensity);\n    }\n\n    vec3 getAtmosphereColour(vec3 cameraPos, vec3 rayDir, vec3 lightDir, float terrainDepth) {\n      float reducedPlanetRadius = radii[0] - 20000.0;\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, reducedPlanetRadius, true);\n      vec2 rayAtmosphereIntersect = sphereIntersect(cameraPos, rayDir, radii[1], false);\n      bool hitsAtmosphere = (rayAtmosphereIntersect.x <= rayAtmosphereIntersect.y) && rayAtmosphereIntersect.x > 0.0;\n      bool insideAtmosphere = heightParameters[0] < radii[1];\n\n      if (!(hitsAtmosphere || insideAtmosphere)) {\n        return vec3(0);\n      }\n\n      bool hitsPlanet = (rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0;\n\n      float start = insideAtmosphere ? 0.0 : rayAtmosphereIntersect.x;\n\n      if (heightParameters[0] < reducedPlanetRadius) {\n        // Long light rays from the night side of the planet lead to numerical instability\n        // Do not render the atmosphere in such cases\n        if (dot(rayDir, normalize(cameraPos)) < -0.025) {\n          return vec3(0);\n        }\n        start = rayPlanetIntersect.y;\n      }\n\n      float end = hitsPlanet ? rayPlanetIntersect.x : rayAtmosphereIntersect.y;\n      float maxEnd = end;\n\n      ${t.haze?m`if (terrainDepth != -1.0) { end = terrainDepth; }`:\"\"}\n\n      vec3 samplePoint = cameraPos + rayDir * end;\n      float multiplier = hitsPlanet ? -1.0 : 1.0;\n\n      vec3 scattering = vec3(0);\n      float scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n      float lastOpticalDepth = getOpticalDepth(samplePoint, rayDir, scaleFract);\n      float stepSize = (end - start) / float(STEPS);\n      for (int i = 0; i < STEPS; i++) {\n        samplePoint -= stepSize * rayDir;\n        scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n        float opticalDepth = multiplier * getOpticalDepth(samplePoint, rayDir * multiplier, scaleFract);\n\n        if (i > 0) {\n          scattering *= ${t.haze?m``:\" mix(2.5, 1.0, clamp((length(cameraPos) - radii[0]) / 50e3, 0.0, 1.0)) * \"} exp(-(mix(betaCombined, betaRayleigh, 0.5) + betaMie) * max(0.0, (opticalDepth - lastOpticalDepth)));\n        }\n\n        if (dot(normalize(samplePoint), lightDir) > -0.3) {\n\n          float scale = exp(-scaleFract);\n          float lightDepth = getOpticalDepth(samplePoint, lightDir, scaleFract);\n\n          scattering += scale * exp(-(betaCombined + betaMie) * lightDepth);\n          ${t.haze?\"\":m`scattering += scale * exp(-(0.25 * betaCombined ) * lightDepth);`}\n        }\n\n        lastOpticalDepth = opticalDepth;\n\n      }\n\n      float mu = dot(rayDir, lightDir);\n      float mumu = 1.0 + mu * mu;\n\n      float phaseRayleigh = 0.05968310365 * mumu;\n\n      ${t.haze?m`return 3.0 * scattering * stepSize * phaseRayleigh * betaRayleigh;`:m`\n            const float g = 0.8;\n            const float gg = g * g;\n            float phaseMie = end == maxEnd ? 0.11936620731 * ((1.0 - gg) * mumu) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n            phaseMie += getGlow(1.0 - mu, 5e-5, 3.0) * smoothstep(0.01, 0.1, length(scattering));\n            phaseMie = clamp(phaseMie, 0.0, 128.0);\n            return 3.0 * scattering * stepSize * (phaseRayleigh * betaRayleigh + 0.025 * phaseMie * betaMie);`}\n    }\n\n    vec3 tonemapACES(vec3 x) {\n      return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n    }\n\n    vec4 applyUndergroundAtmosphere(vec3 rayDir, vec3 lightDirection, vec4 fragColor) {\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPosition, rayDir, radii[0], true);\n      if (!((rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.y > 0.0)) {\n        return fragColor;\n      }\n\n      float lightAngle = dot(lightDirection, normalize(cameraPosition + rayDir * max(0.0, rayPlanetIntersect.x)));\n      vec4 surfaceColor = vec4(vec3(max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)))), 1.0 - altitudeFade);\n      float relDist = (rayPlanetIntersect.y - max(0.0, rayPlanetIntersect.x)) / innerFadeDistance;\n      if (relDist > 1.0) {\n        return surfaceColor;\n      }\n\n      return mix(gl_FragColor, surfaceColor, smoothstep(0.0, 1.0, relDist * relDist));\n    }\n\n    void main() {\n      vec3 rayDir = normalize(worldRay);\n      float terrainDepth = -1.0;\n      ${t.haze?m`\n          vec4 depthSample = texture2D(depthTex, vuv0).rgba;\n          if (depthSample != vec4(0)) {\n            vec3 cameraSpaceRay = normalize(eyeDir);\n            cameraSpaceRay /= cameraSpaceRay.z;\n            cameraSpaceRay *= -linearDepthFromTexture(depthTex, vuv0, nearFar);\n            terrainDepth = max(0.0, length(cameraSpaceRay));\n          }`:m`\n          float depthSample = texture2D(depthTex, vuv0).r;\n          if (depthSample != 1.0) {\n            gl_FragColor = vec4(0);\n            return;\n          }`}\n\n      ${t.haze?m`\n            vec3 col = vec3(0);\n            float fadeOut = smoothstep(-10000.0, -15000.0, heightParameters[0] - radii[0]);\n            if(depthSample != vec4(0)){\n              col = (1.0 - fadeOut) * hazeStrength * getAtmosphereColour(cameraPosition, rayDir, lightingMainDirection, terrainDepth);\n            }\n            float alpha = 1.0 - fadeOut;`:m`\n            vec3 col = getAtmosphereColour(cameraPosition, rayDir, lightingMainDirection, terrainDepth);;\n            float alpha = smoothstep(0.0, mix(0.15, 0.01, heightParameters[3]), length(col));`}\n      col = tonemapACES(col);\n      gl_FragColor = delinearizeGamma(vec4(col, alpha));\n      ${t.haze?\"\":m`\n          if (depthSample == 1.0) {\n            gl_FragColor = applyUndergroundAtmosphere(rayDir, lightingMainDirection, gl_FragColor);\n          }`}\n    }\n  `),v}const y=t(),x=Object.freeze(Object.defineProperty({__proto__:null,build:v},Symbol.toStringTag,{value:\"Module\"}));export{x as C,v as b};\n"],"mappings":"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M,IAAF,CAAOf,GAAP,CAAWX,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAVI,CAfwoD,EAyBxoDoB,CAAC,CAACM,IAAF,CAAOf,GAAP,CAAWX,CAAE;AACjB;AACA,EAFI,CAzBwoD,EA2BxoDoB,CAAC,CAACM,IAAF,CAAOf,GAAP,CAAWX,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQpB,CAAC,CAACiD,IAAF,GAAO7B,CAAE,mDAAT,GAA4D,EAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0BpB,CAAC,CAACiD,IAAF,GAAO7B,CAAE,EAAT,GAAW,2EAA4E;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAYpB,CAAC,CAACiD,IAAF,GAAO,EAAP,GAAU7B,CAAE,kEAAkE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQpB,CAAC,CAACiD,IAAF,GAAO7B,CAAE,oEAAT,GAA6EA,CAAE;AACvF;AACA;AACA;AACA;AACA;AACA,8GAA+G;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQpB,CAAC,CAACiD,IAAF,GAAO7B,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,YAPQ,GAOKA,CAAE;AACf;AACA;AACA;AACA;AACA,YAAa;AACb;AACA,QAAQpB,CAAC,CAACiD,IAAF,GAAO7B,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA,yCANQ,GAMkCA,CAAE;AAC5C;AACA,8FAA+F;AAC/F;AACA;AACA,QAAQpB,CAAC,CAACiD,IAAF,GAAO,EAAP,GAAU7B,CAAE;AACpB;AACA;AACA,YAAa;AACb;AACA,GApII,CA3BwoD,EA+JvoDS,CA/JgoD;AA+J9nD;;AAAA,MAAMe,CAAC,GAAC5C,CAAC,EAAT;AAAA,MAAYsC,CAAC,GAACa,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,cAAP,CAAsB;EAACC,SAAS,EAAC,IAAX;EAAgBC,KAAK,EAAC1B;AAAtB,CAAtB,EAA+C2B,MAAM,CAACC,WAAtD,EAAkE;EAACC,KAAK,EAAC;AAAP,CAAlE,CAAd,CAAd;AAAiH,SAAOpB,CAAC,IAAIqB,CAAZ,EAAc9B,CAAC,IAAI+B,CAAnB"},"metadata":{},"sourceType":"module"}