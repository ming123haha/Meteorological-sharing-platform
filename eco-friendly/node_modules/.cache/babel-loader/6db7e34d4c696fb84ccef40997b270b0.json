{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { RgbaFloatEncoding as e } from \"../util/RgbaFloatEncoding.glsl.js\";\nimport { addCameraPosition as t } from \"../util/View.glsl.js\";\nimport { Float4PassUniform as i } from \"../../shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as o } from \"../../shaderModules/FloatPassUniform.js\";\nimport { FloatUniform as r } from \"../../shaderModules/FloatUniform.js\";\nimport { glsl as l } from \"../../shaderModules/interfaces.js\";\nimport { Texture2DUniform as a } from \"../../shaderModules/Texture2DUniform.js\";\nimport { ensureColor4 as s } from \"../../../shaders/ensureColor4.js\";\n\nfunction p(e, t) {\n  e.constants.add(\"stippleAlphaColorDiscard\", \"float\", .001), e.constants.add(\"stippleAlphaHighlightDiscard\", \"float\", .5), t.stippleEnabled ? n(e, t) : d(e);\n}\n\nfunction n(p, n) {\n  const d = !(n.draped && n.stipplePreferContinuous),\n        {\n    vertex: f,\n    fragment: m\n  } = p;\n  m.include(e), f.uniforms.add(new r(\"stipplePatternPixelSize\")), n.draped || (t(f, n), f.uniforms.add(new o(\"worldToScreenPerDistanceRatio\", (e, t) => 1 / t.camera.perScreenPixelRatio)), f.code.add(l`float computeWorldToScreenRatio(vec3 segmentCenter) {\nfloat segmentDistanceToCamera = length(segmentCenter - cameraPosition);\nreturn worldToScreenPerDistanceRatio / segmentDistanceToCamera;\n}`)), p.varyings.add(\"vStippleDistance\", \"float\"), n.stippleRequiresClamp && p.varyings.add(\"vStippleDistanceLimits\", \"vec2\"), n.stippleRequiresStretchMeasure && p.varyings.add(\"vStipplePatternStretch\", \"float\"), f.code.add(l`\n    float discretizeWorldToScreenRatio(float worldToScreenRatio) {\n      float step = ${c};\n\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n      return discreteWorldToScreenRatio;\n    }\n  `), f.code.add(l`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`), f.code.add(l`\n    if (segmentLengthPseudoScreen >= ${d ? \"patternLength\" : \"1e4\"}) {\n  `), f.uniforms.add(new o(\"pixelRatio\", (e, t) => t.camera.pixelRatio)), f.code.add(l`\n        // Round the screen length to get an integer number of pattern repetitions (minimum 1).\n        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);\n        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));\n        float segmentLengthScreenRounded = flooredRepetitions * patternLength;\n\n        ${n.stippleRequiresStretchMeasure ? l`\n              float stretch = repetitions / flooredRepetitions;\n\n              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.\n              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.\n              vStipplePatternStretch = max(0.75, stretch);` : \"\"}\n\n        return vec2(0.0, segmentLengthScreenRounded);\n      }\n      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);\n    }\n  `), m.uniforms.add(new a(\"stipplePatternTexture\")), m.uniforms.add(new r(\"stipplePatternSDFNormalizer\")), m.uniforms.add(new r(\"stipplePatternTextureSize\")), m.uniforms.add(new r(\"stipplePatternPixelSizeInv\")), m.code.add(l`float padTexture(float u) {\nreturn (u * stipplePatternTextureSize + 1.0)/(stipplePatternTextureSize + 2.0);\n}`), m.code.add(l`\n    float getStippleSDF(out bool isClamped) {\n      ${n.stippleRequiresClamp ? l`\n          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);\n          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;\n          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;` : l`\n          float stippleDistanceClamped = vStippleDistance;\n          isClamped = false;`}\n\n      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;\n      ${n.stippleScaleWithLineWidth ? l`u *= vLineSizeInv;` : \"\"}\n      u = padTexture(fract(u));\n\n      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));\n      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;\n\n      ${n.stippleRequiresStretchMeasure ? l`return (sdf - 0.5) * vStipplePatternStretch + 0.5;` : l`return sdf;`}\n    }\n\n    float getStippleSDF() {\n      bool ignored;\n      return getStippleSDF(ignored);\n    }\n\n    float getStippleAlpha() {\n      bool isClamped;\n      float stippleSDF = getStippleSDF(isClamped);\n\n      float antiAliasedResult = ${n.stippleScaleWithLineWidth ? l`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);` : l`clamp(stippleSDF + 0.5, 0.0, 1.0);`}\n\n      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;\n    }\n  `), n.stippleOffColorEnabled ? (m.uniforms.add(new i(\"stippleOffColor\", e => s(e.stippleOffColor))), m.code.add(l`#define discardByStippleAlpha(stippleAlpha, threshold) {}\n#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)) : m.code.add(l`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }\n#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`);\n}\n\nfunction d(e) {\n  e.fragment.code.add(l`float getStippleAlpha() { return 1.0; }\n#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}\n#define blendStipple(color, _stippleAlpha_) color`);\n}\n\nconst c = l.float(.4);\nexport { p as LineStipple };","map":{"version":3,"names":["RgbaFloatEncoding","e","addCameraPosition","t","Float4PassUniform","i","FloatPassUniform","o","FloatUniform","r","glsl","l","Texture2DUniform","a","ensureColor4","s","p","constants","add","stippleEnabled","n","d","draped","stipplePreferContinuous","vertex","f","fragment","m","include","uniforms","camera","perScreenPixelRatio","code","varyings","stippleRequiresClamp","stippleRequiresStretchMeasure","c","pixelRatio","stippleScaleWithLineWidth","stippleOffColorEnabled","stippleOffColor","float","LineStipple"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{RgbaFloatEncoding as e}from\"../util/RgbaFloatEncoding.glsl.js\";import{addCameraPosition as t}from\"../util/View.glsl.js\";import{Float4PassUniform as i}from\"../../shaderModules/Float4PassUniform.js\";import{FloatPassUniform as o}from\"../../shaderModules/FloatPassUniform.js\";import{FloatUniform as r}from\"../../shaderModules/FloatUniform.js\";import{glsl as l}from\"../../shaderModules/interfaces.js\";import{Texture2DUniform as a}from\"../../shaderModules/Texture2DUniform.js\";import{ensureColor4 as s}from\"../../../shaders/ensureColor4.js\";function p(e,t){e.constants.add(\"stippleAlphaColorDiscard\",\"float\",.001),e.constants.add(\"stippleAlphaHighlightDiscard\",\"float\",.5),t.stippleEnabled?n(e,t):d(e)}function n(p,n){const d=!(n.draped&&n.stipplePreferContinuous),{vertex:f,fragment:m}=p;m.include(e),f.uniforms.add(new r(\"stipplePatternPixelSize\")),n.draped||(t(f,n),f.uniforms.add(new o(\"worldToScreenPerDistanceRatio\",((e,t)=>1/t.camera.perScreenPixelRatio))),f.code.add(l`float computeWorldToScreenRatio(vec3 segmentCenter) {\nfloat segmentDistanceToCamera = length(segmentCenter - cameraPosition);\nreturn worldToScreenPerDistanceRatio / segmentDistanceToCamera;\n}`)),p.varyings.add(\"vStippleDistance\",\"float\"),n.stippleRequiresClamp&&p.varyings.add(\"vStippleDistanceLimits\",\"vec2\"),n.stippleRequiresStretchMeasure&&p.varyings.add(\"vStipplePatternStretch\",\"float\"),f.code.add(l`\n    float discretizeWorldToScreenRatio(float worldToScreenRatio) {\n      float step = ${c};\n\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n      return discreteWorldToScreenRatio;\n    }\n  `),f.code.add(l`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),f.code.add(l`\n    if (segmentLengthPseudoScreen >= ${d?\"patternLength\":\"1e4\"}) {\n  `),f.uniforms.add(new o(\"pixelRatio\",((e,t)=>t.camera.pixelRatio))),f.code.add(l`\n        // Round the screen length to get an integer number of pattern repetitions (minimum 1).\n        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);\n        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));\n        float segmentLengthScreenRounded = flooredRepetitions * patternLength;\n\n        ${n.stippleRequiresStretchMeasure?l`\n              float stretch = repetitions / flooredRepetitions;\n\n              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.\n              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.\n              vStipplePatternStretch = max(0.75, stretch);`:\"\"}\n\n        return vec2(0.0, segmentLengthScreenRounded);\n      }\n      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);\n    }\n  `),m.uniforms.add(new a(\"stipplePatternTexture\")),m.uniforms.add(new r(\"stipplePatternSDFNormalizer\")),m.uniforms.add(new r(\"stipplePatternTextureSize\")),m.uniforms.add(new r(\"stipplePatternPixelSizeInv\")),m.code.add(l`float padTexture(float u) {\nreturn (u * stipplePatternTextureSize + 1.0)/(stipplePatternTextureSize + 2.0);\n}`),m.code.add(l`\n    float getStippleSDF(out bool isClamped) {\n      ${n.stippleRequiresClamp?l`\n          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);\n          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;\n          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;`:l`\n          float stippleDistanceClamped = vStippleDistance;\n          isClamped = false;`}\n\n      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;\n      ${n.stippleScaleWithLineWidth?l`u *= vLineSizeInv;`:\"\"}\n      u = padTexture(fract(u));\n\n      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));\n      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;\n\n      ${n.stippleRequiresStretchMeasure?l`return (sdf - 0.5) * vStipplePatternStretch + 0.5;`:l`return sdf;`}\n    }\n\n    float getStippleSDF() {\n      bool ignored;\n      return getStippleSDF(ignored);\n    }\n\n    float getStippleAlpha() {\n      bool isClamped;\n      float stippleSDF = getStippleSDF(isClamped);\n\n      float antiAliasedResult = ${n.stippleScaleWithLineWidth?l`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);`:l`clamp(stippleSDF + 0.5, 0.0, 1.0);`}\n\n      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;\n    }\n  `),n.stippleOffColorEnabled?(m.uniforms.add(new i(\"stippleOffColor\",(e=>s(e.stippleOffColor)))),m.code.add(l`#define discardByStippleAlpha(stippleAlpha, threshold) {}\n#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):m.code.add(l`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }\n#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}function d(e){e.fragment.code.add(l`float getStippleAlpha() { return 1.0; }\n#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}\n#define blendStipple(color, _stippleAlpha_) color`)}const c=l.float(.4);export{p as LineStipple};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}