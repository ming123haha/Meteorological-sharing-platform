{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { isSome as e } from \"../core/maybe.js\";\nimport { Z as a } from \"./vec3f64.js\";\nimport { RasterColorizerType as o, RasterColorizerStretchType as r } from \"../views/2d/engine/imagery/enums.js\";\nimport { LayerBlendMode as l } from \"../views/3d/webgl-engine/core/shaderLibrary/output/BlendOptions.js\";\nimport { Colormap as i } from \"../views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl.js\";\nimport { CommonPassParameters as t, Common as n } from \"../views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl.js\";\nimport { BackgroundGrid as u } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/BackgroundGrid.glsl.js\";\nimport { TileBlendInput as s } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/TileBlendInput.js\";\nimport { TileComposite as c } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/TileComposite.glsl.js\";\nimport { a as m } from \"./BlendLayers.glsl.js\";\nimport { BlendModes as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/BlendModes.glsl.js\";\nimport { ColorConversion as f } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { BooleanPassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/BooleanPassUniform.js\";\nimport { Float2PassUniform as p } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float3PassUniform as x } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { FloatPassUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { FloatsPassUniform as y } from \"../views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js\";\nimport { IntegerPassUniform as _ } from \"../views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js\";\nimport { glsl as b } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as h } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as C } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\n\nclass w extends t {\n  constructor(e, o, r, l, i, t) {\n    super(e, l, i), this.colormap = o, this.symbolizer = r, this.u_colormap = t, this.backgroundColor = a, this.fboTexture = null, this.baseOpacity = 1;\n  }\n\n}\n\nclass O extends w {}\n\nclass z extends w {}\n\nfunction L(a) {\n  const r = new h();\n  r.include(c), r.include(n), r.include(i), a.tileBlendInput === s.GridComposite && (r.extensions.add(\"GL_OES_standard_derivatives\"), r.fragment.include(u));\n  const t = a.tileBlendInput === s.ColorComposite;\n  t && r.fragment.uniforms.add(new x(\"backgroundColor\", e => e.backgroundColor)), a.baseOpacityMode !== m.One && r.fragment.uniforms.add(new v(\"baseOpacity\", e => e.baseOpacity));\n  const f = a.baseOpacityMode === m.OnBaseLayer,\n        g = a.baseOpacityMode === m.OnBackground || a.baseOpacityMode === m.OnBaseLayer,\n        p = a.blendMode !== l.Normal;\n  r.fragment.include(d, a);\n  const y = a.tileBlendInput !== s.LayerOnly;\n  return (p && !y || f) && (r.fragment.uniforms.add(new C(\"fboColor\", e => e.fboTexture)), r.fragment.uniforms.add(new v(\"tileSize\", a => e(a.fboTexture) ? a.fboTexture.descriptor.width : 1))), r.fragment.code.add(b`\n    vec4 applyBackgroundBlend(vec4 layerColor) {\n      ${y || f ? b`\n          vec4 bgColor = ${f ? b`texture2D(fboColor, gl_FragCoord.xy / tileSize)` : t ? b`vec4(backgroundColor, 1.0)` : b`gridColor(vuv)`};\n          ${g ? b`bgColor *= baseOpacity;` : \"\"}` : \"\"}\n      ${p ? b`\n            vec3 pmColorLayer = layerColor.rgb * layerColor.a;\n            vec4 fboTex = ${y ? b`bgColor;` : b`texture2D(fboColor, gl_FragCoord.xy / tileSize) ${f ? \" * baseOpacity\" : \"\"};`}\n            vec3 Cb = fboTex.a == 0.0 ? fboTex.rgb : vec3(fboTex.rgb * fboTex.a);\n            return applyBlendMode(pmColorLayer.rgb, layerColor.a * u_opacity, Cb, fboTex.a);` : y || f ? b`\n            float composeAlpha = layerColor.a * u_opacity;\n            vec4 pmColorLayer = vec4(layerColor.rgb, 1.0);\n            return mix(bgColor, pmColorLayer, composeAlpha);` : b`\n            return layerColor * layerColor.a * u_opacity;`}\n    }\n  `), a.colorizerType === o.Stretch ? B(r, a) : a.colorizerType === o.Lut ? P(r) : a.colorizerType === o.Hillshade && V(r, a), r;\n}\n\nfunction P(e) {\n  e.fragment.code.add(b`void main() {\nvec2 pixelLocation = getPixelLocation(uv);\nif (isOutside(pixelLocation)) {\ngl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\ngl_FragColor = applyBackgroundBlend(colormap(currentPixel, true));\n}`);\n}\n\nfunction B(e, a) {\n  e.fragment.uniforms.add([new _(\"u_bandCount\", e => e.symbolizer.u_bandCount), new y(\"u_minCutOff\", e => e.symbolizer.u_minCutOff, 3), new y(\"u_maxCutOff\", e => e.symbolizer.u_maxCutOff, 3), new y(\"u_factor\", e => e.symbolizer.u_factor, 3), new v(\"u_minOutput\", e => e.symbolizer.u_minOutput), new v(\"u_maxOutput\", e => e.symbolizer.u_maxOutput), new g(\"u_useGamma\", e => e.symbolizer.u_useGamma), new y(\"u_gamma\", e => e.symbolizer.u_gamma, 3), new y(\"u_gammaCorrection\", e => e.symbolizer.u_gammaCorrection, 3), new v(\"u_opacity\", e => e.common.u_opacity)]), e.fragment.code.add(b`float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\nif (val >= maxCutOff) {\nreturn maxOutput;\n} else if (val <= minCutOff) {\nreturn minOutput;\n}\nfloat stretchedVal;\nif (useGamma) {\nfloat tempf = 1.0;\nfloat outRange = maxOutput - minOutput;\nfloat relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);\nif (gamma > 1.0) {\ntempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);\n}\nstretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\n} else {\nstretchedVal = minOutput + (val - minCutOff) * factor;\n}\nreturn stretchedVal;\n}`);\n  const o = a.applyColormap ? b`gl_FragColor = applyBackgroundBlend(colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma));` : b`gl_FragColor = applyBackgroundBlend(vec4(grayVal, grayVal, grayVal, currentPixel.a));`;\n  e.fragment.code.add(b`\n      void main() {\n        vec2 pixelLocation = getPixelLocation(uv);\n        if (isOutside(pixelLocation)) {\n          gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n          return;\n        }\n\n        vec4 currentPixel = getPixel(pixelLocation);\n        ${a.stretchType === r.Noop ? b`\n        gl_FragColor = applyBackgroundBlend(currentPixel);` : b`\n        if (currentPixel.a == 0.0) {\n          gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n          return;\n        }\n        if (u_bandCount == 1) {\n          float grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          ${o}\n        } else {\n          float redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          float greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\n          float blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\n          gl_FragColor = applyBackgroundBlend(vec4(redVal, greenVal, blueVal, currentPixel.a));\n        }`}\n      }`);\n}\n\nfunction V(e, a) {\n  const o = e.fragment;\n  o.uniforms.add([new C(\"u_image\", e => e.u_image), new _(\"u_hillshadeType\", e => e.symbolizer.u_hillshadeType), new y(\"u_sinZcosAs\", e => e.symbolizer.u_sinZcosAs, 6), new y(\"u_sinZsinAs\", e => e.symbolizer.u_sinZsinAs, 6), new y(\"u_cosZs\", e => e.symbolizer.u_cosZs, 6), new y(\"u_weights\", e => e.symbolizer.u_weights, 6), new p(\"u_factor\", e => e.symbolizer.u_factor), new v(\"u_minValue\", e => e.symbolizer.u_minValue), new v(\"u_maxValue\", e => e.symbolizer.u_maxValue), new p(\"u_srcImageSize\", e => e.common.u_srcImageSize)]), o.include(f), o.code.add(b`vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {\nval = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\nvec3 hsv = rgb2hsv(colormap(vec4(val, val, val, 1.0), false).rgb);\nhsv.z = hillshade;\nreturn vec4(hsv2rgb(hsv) * alpha, alpha);\n}`), o.code.add(b`float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){\nif (a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0) {\nreturn 0.0;\n}  else {\nreturn e;\n}\n}`);\n  const r = a.applyColormap ? b`gl_FragColor = applyBackgroundBlend(overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha));` : b`hillshade *= alpha;\ngl_FragColor = applyBackgroundBlend(vec4(hillshade, hillshade, hillshade, alpha));`;\n  o.code.add(b`\n    void main() {\n      vec2 pixelLocation = getPixelLocation(uv);\n      if (isOutside(pixelLocation)) {\n        gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n        return;\n      }\n\n      vec4 currentPixel = getPixel(pixelLocation);\n      if (currentPixel.a == 0.0) {\n        gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n        return;\n      }\n\n      //mirror edge pixels\n      vec2 axy = vec2(-1.0, -1.0);\n      vec2 bxy = vec2(0.0, -1.0);\n      vec2 cxy = vec2(1.0, -1.0);\n      vec2 dxy = vec2(-1.0, 0.0);\n      vec2 fxy = vec2(1.0, 0.0);\n      vec2 gxy = vec2(-1.0, 1.0);\n      vec2 hxy = vec2(0.0, 1.0);\n      vec2 ixy = vec2(1.0, 1.0);\n      vec2 onePixel = 1.0 / u_srcImageSize;\n      if (pixelLocation.s < onePixel.s) {\n        axy[0] = 1.0;\n        dxy[0] = 1.0;\n        gxy[0] = 1.0;\n      }\n      if (pixelLocation.t < onePixel.t) {\n        axy[1] = 1.0;\n        bxy[1] = 1.0;\n        cxy[1] = 1.0;\n      }\n      if (pixelLocation.s > 1.0 - onePixel.s) {\n        cxy[0] = -1.0;\n        fxy[0] = -1.0;\n        ixy[0] = -1.0;\n      }\n      if (pixelLocation.t > 1.0 - onePixel.t) {\n        gxy[1] = -1.0;\n        hxy[1] = -1.0;\n        ixy[1] = -1.0;\n      }\n\n      // calculate hillshade\n      vec4 va = texture2D(u_image, pixelLocation + onePixel * axy);\n      vec4 vb = texture2D(u_image, pixelLocation + onePixel * bxy);\n      vec4 vc = texture2D(u_image, pixelLocation + onePixel * cxy);\n      vec4 vd = texture2D(u_image, pixelLocation + onePixel * dxy);\n      vec4 ve = texture2D(u_image, pixelLocation);\n      vec4 vf = texture2D(u_image, pixelLocation + onePixel * fxy);\n      vec4 vg = texture2D(u_image, pixelLocation + onePixel * gxy);\n      vec4 vh = texture2D(u_image, pixelLocation + onePixel * hxy);\n      vec4 vi = texture2D(u_image, pixelLocation + onePixel * ixy);\n\n      // calculate the rate of z change along the x, y, and diagonal direction\n      float dzx = (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;\n      float dzy = (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;\n      float dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);\n      float hillshade = 0.0;\n\n      // traditional single light source\n      if (u_hillshadeType == 0){\n        float cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\n        float z = (u_cosZs[0] + cosDelta) / dzd;\n        if (z < 0.0)  z = 0.0;\n        hillshade = z;\n      } else {\n        // multi-directional with 6 light sources\n        for (int k = 0; k < 6; k++) {\n        float cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\n        float z = (u_cosZs[k] + cosDelta) / dzd;\n        if (z < 0.0) z = 0.0;\n        hillshade = hillshade + z * u_weights[k];\n        if (k == 5) break;\n        }\n      }\n\n      // set color\n      float alpha = getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);\n      alpha *= u_opacity;\n      ${r}\n    }\n  `);\n}\n\nconst k = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  ColorizerUniforms: w,\n  ColorizerStretchUniforms: O,\n  ColorizerHillshadeUniforms: z,\n  build: L\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { w as C, k as R, O as a, z as b, L as c };","map":{"version":3,"names":["isSome","e","Z","a","RasterColorizerType","o","RasterColorizerStretchType","r","LayerBlendMode","l","Colormap","i","CommonPassParameters","t","Common","n","BackgroundGrid","u","TileBlendInput","s","TileComposite","c","m","BlendModes","d","ColorConversion","f","BooleanPassUniform","g","Float2PassUniform","p","Float3PassUniform","x","FloatPassUniform","v","FloatsPassUniform","y","IntegerPassUniform","_","glsl","b","ShaderBuilder","h","Texture2DPassUniform","C","w","constructor","colormap","symbolizer","u_colormap","backgroundColor","fboTexture","baseOpacity","O","z","L","include","tileBlendInput","GridComposite","extensions","add","fragment","ColorComposite","uniforms","baseOpacityMode","One","OnBaseLayer","OnBackground","blendMode","Normal","LayerOnly","descriptor","width","code","colorizerType","Stretch","B","Lut","P","Hillshade","V","u_bandCount","u_minCutOff","u_maxCutOff","u_factor","u_minOutput","u_maxOutput","u_useGamma","u_gamma","u_gammaCorrection","common","u_opacity","applyColormap","stretchType","Noop","u_image","u_hillshadeType","u_sinZcosAs","u_sinZsinAs","u_cosZs","u_weights","u_minValue","u_maxValue","u_srcImageSize","k","Object","freeze","defineProperty","__proto__","ColorizerUniforms","ColorizerStretchUniforms","ColorizerHillshadeUniforms","build","Symbol","toStringTag","value","R"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/chunks/RasterColorizer.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{isSome as e}from\"../core/maybe.js\";import{Z as a}from\"./vec3f64.js\";import{RasterColorizerType as o,RasterColorizerStretchType as r}from\"../views/2d/engine/imagery/enums.js\";import{LayerBlendMode as l}from\"../views/3d/webgl-engine/core/shaderLibrary/output/BlendOptions.js\";import{Colormap as i}from\"../views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl.js\";import{CommonPassParameters as t,Common as n}from\"../views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl.js\";import{BackgroundGrid as u}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/BackgroundGrid.glsl.js\";import{TileBlendInput as s}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/TileBlendInput.js\";import{TileComposite as c}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/TileComposite.glsl.js\";import{a as m}from\"./BlendLayers.glsl.js\";import{BlendModes as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/BlendModes.glsl.js\";import{ColorConversion as f}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{BooleanPassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/BooleanPassUniform.js\";import{Float2PassUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float3PassUniform as x}from\"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";import{FloatPassUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{FloatsPassUniform as y}from\"../views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js\";import{IntegerPassUniform as _}from\"../views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js\";import{glsl as b}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as h}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as C}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";class w extends t{constructor(e,o,r,l,i,t){super(e,l,i),this.colormap=o,this.symbolizer=r,this.u_colormap=t,this.backgroundColor=a,this.fboTexture=null,this.baseOpacity=1}}class O extends w{}class z extends w{}function L(a){const r=new h;r.include(c),r.include(n),r.include(i),a.tileBlendInput===s.GridComposite&&(r.extensions.add(\"GL_OES_standard_derivatives\"),r.fragment.include(u));const t=a.tileBlendInput===s.ColorComposite;t&&r.fragment.uniforms.add(new x(\"backgroundColor\",(e=>e.backgroundColor))),a.baseOpacityMode!==m.One&&r.fragment.uniforms.add(new v(\"baseOpacity\",(e=>e.baseOpacity)));const f=a.baseOpacityMode===m.OnBaseLayer,g=a.baseOpacityMode===m.OnBackground||a.baseOpacityMode===m.OnBaseLayer,p=a.blendMode!==l.Normal;r.fragment.include(d,a);const y=a.tileBlendInput!==s.LayerOnly;return(p&&!y||f)&&(r.fragment.uniforms.add(new C(\"fboColor\",(e=>e.fboTexture))),r.fragment.uniforms.add(new v(\"tileSize\",(a=>e(a.fboTexture)?a.fboTexture.descriptor.width:1)))),r.fragment.code.add(b`\n    vec4 applyBackgroundBlend(vec4 layerColor) {\n      ${y||f?b`\n          vec4 bgColor = ${f?b`texture2D(fboColor, gl_FragCoord.xy / tileSize)`:t?b`vec4(backgroundColor, 1.0)`:b`gridColor(vuv)`};\n          ${g?b`bgColor *= baseOpacity;`:\"\"}`:\"\"}\n      ${p?b`\n            vec3 pmColorLayer = layerColor.rgb * layerColor.a;\n            vec4 fboTex = ${y?b`bgColor;`:b`texture2D(fboColor, gl_FragCoord.xy / tileSize) ${f?\" * baseOpacity\":\"\"};`}\n            vec3 Cb = fboTex.a == 0.0 ? fboTex.rgb : vec3(fboTex.rgb * fboTex.a);\n            return applyBlendMode(pmColorLayer.rgb, layerColor.a * u_opacity, Cb, fboTex.a);`:y||f?b`\n            float composeAlpha = layerColor.a * u_opacity;\n            vec4 pmColorLayer = vec4(layerColor.rgb, 1.0);\n            return mix(bgColor, pmColorLayer, composeAlpha);`:b`\n            return layerColor * layerColor.a * u_opacity;`}\n    }\n  `),a.colorizerType===o.Stretch?B(r,a):a.colorizerType===o.Lut?P(r):a.colorizerType===o.Hillshade&&V(r,a),r}function P(e){e.fragment.code.add(b`void main() {\nvec2 pixelLocation = getPixelLocation(uv);\nif (isOutside(pixelLocation)) {\ngl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\ngl_FragColor = applyBackgroundBlend(colormap(currentPixel, true));\n}`)}function B(e,a){e.fragment.uniforms.add([new _(\"u_bandCount\",(e=>e.symbolizer.u_bandCount)),new y(\"u_minCutOff\",(e=>e.symbolizer.u_minCutOff),3),new y(\"u_maxCutOff\",(e=>e.symbolizer.u_maxCutOff),3),new y(\"u_factor\",(e=>e.symbolizer.u_factor),3),new v(\"u_minOutput\",(e=>e.symbolizer.u_minOutput)),new v(\"u_maxOutput\",(e=>e.symbolizer.u_maxOutput)),new g(\"u_useGamma\",(e=>e.symbolizer.u_useGamma)),new y(\"u_gamma\",(e=>e.symbolizer.u_gamma),3),new y(\"u_gammaCorrection\",(e=>e.symbolizer.u_gammaCorrection),3),new v(\"u_opacity\",(e=>e.common.u_opacity))]),e.fragment.code.add(b`float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\nif (val >= maxCutOff) {\nreturn maxOutput;\n} else if (val <= minCutOff) {\nreturn minOutput;\n}\nfloat stretchedVal;\nif (useGamma) {\nfloat tempf = 1.0;\nfloat outRange = maxOutput - minOutput;\nfloat relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);\nif (gamma > 1.0) {\ntempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);\n}\nstretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\n} else {\nstretchedVal = minOutput + (val - minCutOff) * factor;\n}\nreturn stretchedVal;\n}`);const o=a.applyColormap?b`gl_FragColor = applyBackgroundBlend(colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma));`:b`gl_FragColor = applyBackgroundBlend(vec4(grayVal, grayVal, grayVal, currentPixel.a));`;e.fragment.code.add(b`\n      void main() {\n        vec2 pixelLocation = getPixelLocation(uv);\n        if (isOutside(pixelLocation)) {\n          gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n          return;\n        }\n\n        vec4 currentPixel = getPixel(pixelLocation);\n        ${a.stretchType===r.Noop?b`\n        gl_FragColor = applyBackgroundBlend(currentPixel);`:b`\n        if (currentPixel.a == 0.0) {\n          gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n          return;\n        }\n        if (u_bandCount == 1) {\n          float grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          ${o}\n        } else {\n          float redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          float greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\n          float blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\n          gl_FragColor = applyBackgroundBlend(vec4(redVal, greenVal, blueVal, currentPixel.a));\n        }`}\n      }`)}function V(e,a){const o=e.fragment;o.uniforms.add([new C(\"u_image\",(e=>e.u_image)),new _(\"u_hillshadeType\",(e=>e.symbolizer.u_hillshadeType)),new y(\"u_sinZcosAs\",(e=>e.symbolizer.u_sinZcosAs),6),new y(\"u_sinZsinAs\",(e=>e.symbolizer.u_sinZsinAs),6),new y(\"u_cosZs\",(e=>e.symbolizer.u_cosZs),6),new y(\"u_weights\",(e=>e.symbolizer.u_weights),6),new p(\"u_factor\",(e=>e.symbolizer.u_factor)),new v(\"u_minValue\",(e=>e.symbolizer.u_minValue)),new v(\"u_maxValue\",(e=>e.symbolizer.u_maxValue)),new p(\"u_srcImageSize\",(e=>e.common.u_srcImageSize))]),o.include(f),o.code.add(b`vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {\nval = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\nvec3 hsv = rgb2hsv(colormap(vec4(val, val, val, 1.0), false).rgb);\nhsv.z = hillshade;\nreturn vec4(hsv2rgb(hsv) * alpha, alpha);\n}`),o.code.add(b`float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){\nif (a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0) {\nreturn 0.0;\n}  else {\nreturn e;\n}\n}`);const r=a.applyColormap?b`gl_FragColor = applyBackgroundBlend(overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha));`:b`hillshade *= alpha;\ngl_FragColor = applyBackgroundBlend(vec4(hillshade, hillshade, hillshade, alpha));`;o.code.add(b`\n    void main() {\n      vec2 pixelLocation = getPixelLocation(uv);\n      if (isOutside(pixelLocation)) {\n        gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n        return;\n      }\n\n      vec4 currentPixel = getPixel(pixelLocation);\n      if (currentPixel.a == 0.0) {\n        gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n        return;\n      }\n\n      //mirror edge pixels\n      vec2 axy = vec2(-1.0, -1.0);\n      vec2 bxy = vec2(0.0, -1.0);\n      vec2 cxy = vec2(1.0, -1.0);\n      vec2 dxy = vec2(-1.0, 0.0);\n      vec2 fxy = vec2(1.0, 0.0);\n      vec2 gxy = vec2(-1.0, 1.0);\n      vec2 hxy = vec2(0.0, 1.0);\n      vec2 ixy = vec2(1.0, 1.0);\n      vec2 onePixel = 1.0 / u_srcImageSize;\n      if (pixelLocation.s < onePixel.s) {\n        axy[0] = 1.0;\n        dxy[0] = 1.0;\n        gxy[0] = 1.0;\n      }\n      if (pixelLocation.t < onePixel.t) {\n        axy[1] = 1.0;\n        bxy[1] = 1.0;\n        cxy[1] = 1.0;\n      }\n      if (pixelLocation.s > 1.0 - onePixel.s) {\n        cxy[0] = -1.0;\n        fxy[0] = -1.0;\n        ixy[0] = -1.0;\n      }\n      if (pixelLocation.t > 1.0 - onePixel.t) {\n        gxy[1] = -1.0;\n        hxy[1] = -1.0;\n        ixy[1] = -1.0;\n      }\n\n      // calculate hillshade\n      vec4 va = texture2D(u_image, pixelLocation + onePixel * axy);\n      vec4 vb = texture2D(u_image, pixelLocation + onePixel * bxy);\n      vec4 vc = texture2D(u_image, pixelLocation + onePixel * cxy);\n      vec4 vd = texture2D(u_image, pixelLocation + onePixel * dxy);\n      vec4 ve = texture2D(u_image, pixelLocation);\n      vec4 vf = texture2D(u_image, pixelLocation + onePixel * fxy);\n      vec4 vg = texture2D(u_image, pixelLocation + onePixel * gxy);\n      vec4 vh = texture2D(u_image, pixelLocation + onePixel * hxy);\n      vec4 vi = texture2D(u_image, pixelLocation + onePixel * ixy);\n\n      // calculate the rate of z change along the x, y, and diagonal direction\n      float dzx = (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;\n      float dzy = (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;\n      float dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);\n      float hillshade = 0.0;\n\n      // traditional single light source\n      if (u_hillshadeType == 0){\n        float cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\n        float z = (u_cosZs[0] + cosDelta) / dzd;\n        if (z < 0.0)  z = 0.0;\n        hillshade = z;\n      } else {\n        // multi-directional with 6 light sources\n        for (int k = 0; k < 6; k++) {\n        float cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\n        float z = (u_cosZs[k] + cosDelta) / dzd;\n        if (z < 0.0) z = 0.0;\n        hillshade = hillshade + z * u_weights[k];\n        if (k == 5) break;\n        }\n      }\n\n      // set color\n      float alpha = getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);\n      alpha *= u_opacity;\n      ${r}\n    }\n  `)}const k=Object.freeze(Object.defineProperty({__proto__:null,ColorizerUniforms:w,ColorizerStretchUniforms:O,ColorizerHillshadeUniforms:z,build:L},Symbol.toStringTag,{value:\"Module\"}));export{w as C,k as R,O as a,z as b,L as c};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}