{"ast":null,"code":"/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { normalizeToArray // , MappingExistingItem, setComponentTypeToKeyInfo, mappingToExists\n} from '../util/model.js';\nimport { each, clone, map, isTypedArray, setAsPrimitive, isArray, isObject // , HashMap , createHashMap, extend, merge,\n} from 'zrender/lib/core/util.js';\nimport { error } from '../util/log.js';\nvar QUERY_REG = /^(min|max)?(.+)$/; // Key: mainType\n// type FakeComponentsMap = HashMap<(MappingExistingItem & { subType: string })[]>;\n\n/**\r\n * TERM EXPLANATIONS:\r\n * See `ECOption` and `ECUnitOption` in `src/util/types.ts`.\r\n */\n\nvar OptionManager =\n/** @class */\nfunction () {\n  // timeline.notMerge is not supported in ec3. Firstly there is rearly\n  // case that notMerge is needed. Secondly supporting 'notMerge' requires\n  // rawOption cloned and backuped when timeline changed, which does no\n  // good to performance. What's more, that both timeline and setOption\n  // method supply 'notMerge' brings complex and some problems.\n  // Consider this case:\n  // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n  // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n  function OptionManager(api) {\n    this._timelineOptions = [];\n    this._mediaList = [];\n    /**\r\n     * -1, means default.\r\n     * empty means no media.\r\n     */\n\n    this._currentMediaIndices = [];\n    this._api = api;\n  }\n\n  OptionManager.prototype.setOption = function (rawOption, optionPreprocessorFuncs, opt) {\n    if (rawOption) {\n      // That set dat primitive is dangerous if user reuse the data when setOption again.\n      each(normalizeToArray(rawOption.series), function (series) {\n        series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);\n      });\n      each(normalizeToArray(rawOption.dataset), function (dataset) {\n        dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);\n      });\n    } // Caution: some series modify option data, if do not clone,\n    // it should ensure that the repeat modify correctly\n    // (create a new object when modify itself).\n\n\n    rawOption = clone(rawOption); // FIXME\n    // If some property is set in timeline options or media option but\n    // not set in baseOption, a warning should be given.\n\n    var optionBackup = this._optionBackup;\n    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs, !optionBackup);\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\n\n    if (optionBackup) {\n      // FIXME\n      // the restore merge solution is essentially incorrect.\n      // the mapping can not be 100% consistent with ecModel, which probably brings\n      // potential bug!\n      // The first merge is delayed, becuase in most cases, users do not call `setOption` twice.\n      // let fakeCmptsMap = this._fakeCmptsMap;\n      // if (!fakeCmptsMap) {\n      //     fakeCmptsMap = this._fakeCmptsMap = createHashMap();\n      //     mergeToBackupOption(fakeCmptsMap, null, optionBackup.baseOption, null);\n      // }\n      // mergeToBackupOption(\n      //     fakeCmptsMap, optionBackup.baseOption, newParsedOption.baseOption, opt\n      // );\n      // For simplicity, timeline options and media options do not support merge,\n      // that is, if you `setOption` twice and both has timeline options, the latter\n      // timeline opitons will not be merged to the formers, but just substitude them.\n      if (newParsedOption.timelineOptions.length) {\n        optionBackup.timelineOptions = newParsedOption.timelineOptions;\n      }\n\n      if (newParsedOption.mediaList.length) {\n        optionBackup.mediaList = newParsedOption.mediaList;\n      }\n\n      if (newParsedOption.mediaDefault) {\n        optionBackup.mediaDefault = newParsedOption.mediaDefault;\n      }\n    } else {\n      this._optionBackup = newParsedOption;\n    }\n  };\n\n  OptionManager.prototype.mountOption = function (isRecreate) {\n    var optionBackup = this._optionBackup;\n    this._timelineOptions = optionBackup.timelineOptions;\n    this._mediaList = optionBackup.mediaList;\n    this._mediaDefault = optionBackup.mediaDefault;\n    this._currentMediaIndices = [];\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\n    // called, and is merged into every new option by inner method `mergeToBackupOption`\n    // each time `setOption` called, can be only used in `isRecreate`, because\n    // its reliability is under suspicion. In other cases option merge is\n    // performed by `model.mergeOption`.\n    ? optionBackup.baseOption : this._newBaseOption);\n  };\n\n  OptionManager.prototype.getTimelineOption = function (ecModel) {\n    var option;\n    var timelineOptions = this._timelineOptions;\n\n    if (timelineOptions.length) {\n      // getTimelineOption can only be called after ecModel inited,\n      // so we can get currentIndex from timelineModel.\n      var timelineModel = ecModel.getComponent('timeline');\n\n      if (timelineModel) {\n        option = clone( // FIXME:TS as TimelineModel or quivlant interface\n        timelineOptions[timelineModel.getCurrentIndex()]);\n      }\n    }\n\n    return option;\n  };\n\n  OptionManager.prototype.getMediaOption = function (ecModel) {\n    var ecWidth = this._api.getWidth();\n\n    var ecHeight = this._api.getHeight();\n\n    var mediaList = this._mediaList;\n    var mediaDefault = this._mediaDefault;\n    var indices = [];\n    var result = []; // No media defined.\n\n    if (!mediaList.length && !mediaDefault) {\n      return result;\n    } // Multi media may be applied, the latter defined media has higher priority.\n\n\n    for (var i = 0, len = mediaList.length; i < len; i++) {\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n        indices.push(i);\n      }\n    } // FIXME\n    // Whether mediaDefault should force users to provide? Otherwise\n    // the change by media query can not be recorvered.\n\n\n    if (!indices.length && mediaDefault) {\n      indices = [-1];\n    }\n\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n      result = map(indices, function (index) {\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n      });\n    } // Otherwise return nothing.\n\n\n    this._currentMediaIndices = indices;\n    return result;\n  };\n\n  return OptionManager;\n}();\n/**\r\n * [RAW_OPTION_PATTERNS]\r\n * (Note: \"series: []\" represents all other props in `ECUnitOption`)\r\n *\r\n * (1) No prop \"baseOption\" declared:\r\n * Root option is used as \"baseOption\" (except prop \"options\" and \"media\").\r\n * ```js\r\n * option = {\r\n *     series: [],\r\n *     timeline: {},\r\n *     options: [],\r\n * };\r\n * option = {\r\n *     series: [],\r\n *     media: {},\r\n * };\r\n * option = {\r\n *     series: [],\r\n *     timeline: {},\r\n *     options: [],\r\n *     media: {},\r\n * }\r\n * ```\r\n *\r\n * (2) Prop \"baseOption\" declared:\r\n * If \"baseOption\" declared, `ECUnitOption` props can only be declared\r\n * inside \"baseOption\" except prop \"timeline\" (compat ec2).\r\n * ```js\r\n * option = {\r\n *     baseOption: {\r\n *         timeline: {},\r\n *         series: [],\r\n *     },\r\n *     options: []\r\n * };\r\n * option = {\r\n *     baseOption: {\r\n *         series: [],\r\n *     },\r\n *     media: []\r\n * };\r\n * option = {\r\n *     baseOption: {\r\n *         timeline: {},\r\n *         series: [],\r\n *     },\r\n *     options: []\r\n *     media: []\r\n * };\r\n * option = {\r\n *     // ec3 compat ec2: allow (only) `timeline` declared\r\n *     // outside baseOption. Keep this setting for compat.\r\n *     timeline: {},\r\n *     baseOption: {\r\n *         series: [],\r\n *     },\r\n *     options: [],\r\n *     media: []\r\n * };\r\n * ```\r\n */\n\n\nfunction parseRawOption( // `rawOption` May be modified\nrawOption, optionPreprocessorFuncs, isNew) {\n  var mediaList = [];\n  var mediaDefault;\n  var baseOption;\n  var declaredBaseOption = rawOption.baseOption; // Compatible with ec2, [RAW_OPTION_PATTERNS] above.\n\n  var timelineOnRoot = rawOption.timeline;\n  var timelineOptionsOnRoot = rawOption.options;\n  var mediaOnRoot = rawOption.media;\n  var hasMedia = !!rawOption.media;\n  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);\n\n  if (declaredBaseOption) {\n    baseOption = declaredBaseOption; // For merge option.\n\n    if (!baseOption.timeline) {\n      baseOption.timeline = timelineOnRoot;\n    }\n  } // For convenience, enable to use the root option as the `baseOption`:\n  // `{ ...normalOptionProps, media: [{ ... }, { ... }] }`\n  else {\n    if (hasTimeline || hasMedia) {\n      rawOption.options = rawOption.media = null;\n    }\n\n    baseOption = rawOption;\n  }\n\n  if (hasMedia) {\n    if (isArray(mediaOnRoot)) {\n      each(mediaOnRoot, function (singleMedia) {\n        if (process.env.NODE_ENV !== 'production') {\n          // Real case of wrong config.\n          if (singleMedia && !singleMedia.option && isObject(singleMedia.query) && isObject(singleMedia.query.option)) {\n            error('Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }');\n          }\n        }\n\n        if (singleMedia && singleMedia.option) {\n          if (singleMedia.query) {\n            mediaList.push(singleMedia);\n          } else if (!mediaDefault) {\n            // Use the first media default.\n            mediaDefault = singleMedia;\n          }\n        }\n      });\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        // Real case of wrong config.\n        error('Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }');\n      }\n    }\n  }\n\n  doPreprocess(baseOption);\n  each(timelineOptionsOnRoot, function (option) {\n    return doPreprocess(option);\n  });\n  each(mediaList, function (media) {\n    return doPreprocess(media.option);\n  });\n\n  function doPreprocess(option) {\n    each(optionPreprocessorFuncs, function (preProcess) {\n      preProcess(option, isNew);\n    });\n  }\n\n  return {\n    baseOption: baseOption,\n    timelineOptions: timelineOptionsOnRoot || [],\n    mediaDefault: mediaDefault,\n    mediaList: mediaList\n  };\n}\n/**\r\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\r\n * Support: width, height, aspectRatio\r\n * Can use max or min as prefix.\r\n */\n\n\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n  var realMap = {\n    width: ecWidth,\n    height: ecHeight,\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\n  };\n  var applicatable = true;\n  each(query, function (value, attr) {\n    var matched = attr.match(QUERY_REG);\n\n    if (!matched || !matched[1] || !matched[2]) {\n      return;\n    }\n\n    var operator = matched[1];\n    var realAttr = matched[2].toLowerCase();\n\n    if (!compare(realMap[realAttr], value, operator)) {\n      applicatable = false;\n    }\n  });\n  return applicatable;\n}\n\nfunction compare(real, expect, operator) {\n  if (operator === 'min') {\n    return real >= expect;\n  } else if (operator === 'max') {\n    return real <= expect;\n  } else {\n    // Equals\n    return real === expect;\n  }\n}\n\nfunction indicesEquals(indices1, indices2) {\n  // indices is always order by asc and has only finite number.\n  return indices1.join(',') === indices2.join(',');\n}\n/**\r\n * Consider case:\r\n * `chart.setOption(opt1);`\r\n * Then user do some interaction like dataZoom, dataView changing.\r\n * `chart.setOption(opt2);`\r\n * Then user press 'reset button' in toolbox.\r\n *\r\n * After doing that all of the interaction effects should be reset, the\r\n * chart should be the same as the result of invoke\r\n * `chart.setOption(opt1); chart.setOption(opt2);`.\r\n *\r\n * Although it is not able ensure that\r\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\r\n * `chart.setOption(merge(opt1, opt2));` exactly,\r\n * this might be the only simple way to implement that feature.\r\n *\r\n * MEMO: We've considered some other approaches:\r\n * 1. Each model handle its self restoration but not uniform treatment.\r\n *     (Too complex in logic and error-prone)\r\n * 2. Use a shadow ecModel. (Performace expensive)\r\n *\r\n * FIXME: A possible solution:\r\n * Add a extra level of model for each component model. The inheritance chain would be:\r\n * ecModel <- componentModel <- componentActionModel <- dataItemModel\r\n * And all of the actions can only modify the `componentActionModel` rather than\r\n * `componentModel`. `setOption` will only modify the `ecModel` and `componentModel`.\r\n * When \"resotre\" action triggered, model from `componentActionModel` will be discarded\r\n * instead of recreating the \"ecModel\" from the \"_optionBackup\".\r\n */\n// function mergeToBackupOption(\n//     fakeCmptsMap: FakeComponentsMap,\n//     // `tarOption` Can be null/undefined, means init\n//     tarOption: ECUnitOption,\n//     newOption: ECUnitOption,\n//     // Can be null/undefined\n//     opt: InnerSetOptionOpts\n// ): void {\n//     newOption = newOption || {} as ECUnitOption;\n//     const notInit = !!tarOption;\n//     each(newOption, function (newOptsInMainType, mainType) {\n//         if (newOptsInMainType == null) {\n//             return;\n//         }\n//         if (!ComponentModel.hasClass(mainType)) {\n//             if (tarOption) {\n//                 tarOption[mainType] = merge(tarOption[mainType], newOptsInMainType, true);\n//             }\n//         }\n//         else {\n//             const oldTarOptsInMainType = notInit ? normalizeToArray(tarOption[mainType]) : null;\n//             const oldFakeCmptsInMainType = fakeCmptsMap.get(mainType) || [];\n//             const resultTarOptsInMainType = notInit ? (tarOption[mainType] = [] as ComponentOption[]) : null;\n//             const resultFakeCmptsInMainType = fakeCmptsMap.set(mainType, []);\n//             const mappingResult = mappingToExists(\n//                 oldFakeCmptsInMainType,\n//                 normalizeToArray(newOptsInMainType),\n//                 (opt && opt.replaceMergeMainTypeMap.get(mainType)) ? 'replaceMerge' : 'normalMerge'\n//             );\n//             setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel as ComponentModelConstructor);\n//             each(mappingResult, function (resultItem, index) {\n//                 // The same logic as `Global.ts#_mergeOption`.\n//                 let fakeCmpt = resultItem.existing;\n//                 const newOption = resultItem.newOption;\n//                 const keyInfo = resultItem.keyInfo;\n//                 let fakeCmptOpt;\n//                 if (!newOption) {\n//                     fakeCmptOpt = oldTarOptsInMainType[index];\n//                 }\n//                 else {\n//                     if (fakeCmpt && fakeCmpt.subType === keyInfo.subType) {\n//                         fakeCmpt.name = keyInfo.name;\n//                         if (notInit) {\n//                             fakeCmptOpt = merge(oldTarOptsInMainType[index], newOption, true);\n//                         }\n//                     }\n//                     else {\n//                         fakeCmpt = extend({}, keyInfo);\n//                         if (notInit) {\n//                             fakeCmptOpt = clone(newOption);\n//                         }\n//                     }\n//                 }\n//                 if (fakeCmpt) {\n//                     notInit && resultTarOptsInMainType.push(fakeCmptOpt);\n//                     resultFakeCmptsInMainType.push(fakeCmpt);\n//                 }\n//                 else {\n//                     notInit && resultTarOptsInMainType.push(void 0);\n//                     resultFakeCmptsInMainType.push(void 0);\n//                 }\n//             });\n//         }\n//     });\n// }\n\n\nexport default OptionManager;","map":{"version":3,"names":["normalizeToArray","each","clone","map","isTypedArray","setAsPrimitive","isArray","isObject","error","QUERY_REG","OptionManager","api","_timelineOptions","_mediaList","_currentMediaIndices","_api","prototype","setOption","rawOption","optionPreprocessorFuncs","opt","series","data","dataset","source","optionBackup","_optionBackup","newParsedOption","parseRawOption","_newBaseOption","baseOption","timelineOptions","length","mediaList","mediaDefault","mountOption","isRecreate","_mediaDefault","getTimelineOption","ecModel","option","timelineModel","getComponent","getCurrentIndex","getMediaOption","ecWidth","getWidth","ecHeight","getHeight","indices","result","i","len","applyMediaQuery","query","push","indicesEquals","index","isNew","declaredBaseOption","timelineOnRoot","timeline","timelineOptionsOnRoot","options","mediaOnRoot","media","hasMedia","hasTimeline","singleMedia","process","env","NODE_ENV","doPreprocess","preProcess","realMap","width","height","aspectratio","applicatable","value","attr","matched","match","operator","realAttr","toLowerCase","compare","real","expect","indices1","indices2","join"],"sources":["E:/各个学科/论文/毕业论文/Atmosphere/eco-friendly/node_modules/echarts/lib/model/OptionManager.js"],"sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { normalizeToArray // , MappingExistingItem, setComponentTypeToKeyInfo, mappingToExists\r\n} from '../util/model.js';\r\nimport { each, clone, map, isTypedArray, setAsPrimitive, isArray, isObject // , HashMap , createHashMap, extend, merge,\r\n} from 'zrender/lib/core/util.js';\r\nimport { error } from '../util/log.js';\r\nvar QUERY_REG = /^(min|max)?(.+)$/; // Key: mainType\r\n// type FakeComponentsMap = HashMap<(MappingExistingItem & { subType: string })[]>;\r\n\r\n/**\r\n * TERM EXPLANATIONS:\r\n * See `ECOption` and `ECUnitOption` in `src/util/types.ts`.\r\n */\r\n\r\nvar OptionManager =\r\n/** @class */\r\nfunction () {\r\n  // timeline.notMerge is not supported in ec3. Firstly there is rearly\r\n  // case that notMerge is needed. Secondly supporting 'notMerge' requires\r\n  // rawOption cloned and backuped when timeline changed, which does no\r\n  // good to performance. What's more, that both timeline and setOption\r\n  // method supply 'notMerge' brings complex and some problems.\r\n  // Consider this case:\r\n  // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\r\n  // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\r\n  function OptionManager(api) {\r\n    this._timelineOptions = [];\r\n    this._mediaList = [];\r\n    /**\r\n     * -1, means default.\r\n     * empty means no media.\r\n     */\r\n\r\n    this._currentMediaIndices = [];\r\n    this._api = api;\r\n  }\r\n\r\n  OptionManager.prototype.setOption = function (rawOption, optionPreprocessorFuncs, opt) {\r\n    if (rawOption) {\r\n      // That set dat primitive is dangerous if user reuse the data when setOption again.\r\n      each(normalizeToArray(rawOption.series), function (series) {\r\n        series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);\r\n      });\r\n      each(normalizeToArray(rawOption.dataset), function (dataset) {\r\n        dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);\r\n      });\r\n    } // Caution: some series modify option data, if do not clone,\r\n    // it should ensure that the repeat modify correctly\r\n    // (create a new object when modify itself).\r\n\r\n\r\n    rawOption = clone(rawOption); // FIXME\r\n    // If some property is set in timeline options or media option but\r\n    // not set in baseOption, a warning should be given.\r\n\r\n    var optionBackup = this._optionBackup;\r\n    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs, !optionBackup);\r\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\r\n\r\n    if (optionBackup) {\r\n      // FIXME\r\n      // the restore merge solution is essentially incorrect.\r\n      // the mapping can not be 100% consistent with ecModel, which probably brings\r\n      // potential bug!\r\n      // The first merge is delayed, becuase in most cases, users do not call `setOption` twice.\r\n      // let fakeCmptsMap = this._fakeCmptsMap;\r\n      // if (!fakeCmptsMap) {\r\n      //     fakeCmptsMap = this._fakeCmptsMap = createHashMap();\r\n      //     mergeToBackupOption(fakeCmptsMap, null, optionBackup.baseOption, null);\r\n      // }\r\n      // mergeToBackupOption(\r\n      //     fakeCmptsMap, optionBackup.baseOption, newParsedOption.baseOption, opt\r\n      // );\r\n      // For simplicity, timeline options and media options do not support merge,\r\n      // that is, if you `setOption` twice and both has timeline options, the latter\r\n      // timeline opitons will not be merged to the formers, but just substitude them.\r\n      if (newParsedOption.timelineOptions.length) {\r\n        optionBackup.timelineOptions = newParsedOption.timelineOptions;\r\n      }\r\n\r\n      if (newParsedOption.mediaList.length) {\r\n        optionBackup.mediaList = newParsedOption.mediaList;\r\n      }\r\n\r\n      if (newParsedOption.mediaDefault) {\r\n        optionBackup.mediaDefault = newParsedOption.mediaDefault;\r\n      }\r\n    } else {\r\n      this._optionBackup = newParsedOption;\r\n    }\r\n  };\r\n\r\n  OptionManager.prototype.mountOption = function (isRecreate) {\r\n    var optionBackup = this._optionBackup;\r\n    this._timelineOptions = optionBackup.timelineOptions;\r\n    this._mediaList = optionBackup.mediaList;\r\n    this._mediaDefault = optionBackup.mediaDefault;\r\n    this._currentMediaIndices = [];\r\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\r\n    // called, and is merged into every new option by inner method `mergeToBackupOption`\r\n    // each time `setOption` called, can be only used in `isRecreate`, because\r\n    // its reliability is under suspicion. In other cases option merge is\r\n    // performed by `model.mergeOption`.\r\n    ? optionBackup.baseOption : this._newBaseOption);\r\n  };\r\n\r\n  OptionManager.prototype.getTimelineOption = function (ecModel) {\r\n    var option;\r\n    var timelineOptions = this._timelineOptions;\r\n\r\n    if (timelineOptions.length) {\r\n      // getTimelineOption can only be called after ecModel inited,\r\n      // so we can get currentIndex from timelineModel.\r\n      var timelineModel = ecModel.getComponent('timeline');\r\n\r\n      if (timelineModel) {\r\n        option = clone( // FIXME:TS as TimelineModel or quivlant interface\r\n        timelineOptions[timelineModel.getCurrentIndex()]);\r\n      }\r\n    }\r\n\r\n    return option;\r\n  };\r\n\r\n  OptionManager.prototype.getMediaOption = function (ecModel) {\r\n    var ecWidth = this._api.getWidth();\r\n\r\n    var ecHeight = this._api.getHeight();\r\n\r\n    var mediaList = this._mediaList;\r\n    var mediaDefault = this._mediaDefault;\r\n    var indices = [];\r\n    var result = []; // No media defined.\r\n\r\n    if (!mediaList.length && !mediaDefault) {\r\n      return result;\r\n    } // Multi media may be applied, the latter defined media has higher priority.\r\n\r\n\r\n    for (var i = 0, len = mediaList.length; i < len; i++) {\r\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\r\n        indices.push(i);\r\n      }\r\n    } // FIXME\r\n    // Whether mediaDefault should force users to provide? Otherwise\r\n    // the change by media query can not be recorvered.\r\n\r\n\r\n    if (!indices.length && mediaDefault) {\r\n      indices = [-1];\r\n    }\r\n\r\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\r\n      result = map(indices, function (index) {\r\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\r\n      });\r\n    } // Otherwise return nothing.\r\n\r\n\r\n    this._currentMediaIndices = indices;\r\n    return result;\r\n  };\r\n\r\n  return OptionManager;\r\n}();\r\n/**\r\n * [RAW_OPTION_PATTERNS]\r\n * (Note: \"series: []\" represents all other props in `ECUnitOption`)\r\n *\r\n * (1) No prop \"baseOption\" declared:\r\n * Root option is used as \"baseOption\" (except prop \"options\" and \"media\").\r\n * ```js\r\n * option = {\r\n *     series: [],\r\n *     timeline: {},\r\n *     options: [],\r\n * };\r\n * option = {\r\n *     series: [],\r\n *     media: {},\r\n * };\r\n * option = {\r\n *     series: [],\r\n *     timeline: {},\r\n *     options: [],\r\n *     media: {},\r\n * }\r\n * ```\r\n *\r\n * (2) Prop \"baseOption\" declared:\r\n * If \"baseOption\" declared, `ECUnitOption` props can only be declared\r\n * inside \"baseOption\" except prop \"timeline\" (compat ec2).\r\n * ```js\r\n * option = {\r\n *     baseOption: {\r\n *         timeline: {},\r\n *         series: [],\r\n *     },\r\n *     options: []\r\n * };\r\n * option = {\r\n *     baseOption: {\r\n *         series: [],\r\n *     },\r\n *     media: []\r\n * };\r\n * option = {\r\n *     baseOption: {\r\n *         timeline: {},\r\n *         series: [],\r\n *     },\r\n *     options: []\r\n *     media: []\r\n * };\r\n * option = {\r\n *     // ec3 compat ec2: allow (only) `timeline` declared\r\n *     // outside baseOption. Keep this setting for compat.\r\n *     timeline: {},\r\n *     baseOption: {\r\n *         series: [],\r\n *     },\r\n *     options: [],\r\n *     media: []\r\n * };\r\n * ```\r\n */\r\n\r\n\r\nfunction parseRawOption( // `rawOption` May be modified\r\nrawOption, optionPreprocessorFuncs, isNew) {\r\n  var mediaList = [];\r\n  var mediaDefault;\r\n  var baseOption;\r\n  var declaredBaseOption = rawOption.baseOption; // Compatible with ec2, [RAW_OPTION_PATTERNS] above.\r\n\r\n  var timelineOnRoot = rawOption.timeline;\r\n  var timelineOptionsOnRoot = rawOption.options;\r\n  var mediaOnRoot = rawOption.media;\r\n  var hasMedia = !!rawOption.media;\r\n  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);\r\n\r\n  if (declaredBaseOption) {\r\n    baseOption = declaredBaseOption; // For merge option.\r\n\r\n    if (!baseOption.timeline) {\r\n      baseOption.timeline = timelineOnRoot;\r\n    }\r\n  } // For convenience, enable to use the root option as the `baseOption`:\r\n  // `{ ...normalOptionProps, media: [{ ... }, { ... }] }`\r\n  else {\r\n      if (hasTimeline || hasMedia) {\r\n        rawOption.options = rawOption.media = null;\r\n      }\r\n\r\n      baseOption = rawOption;\r\n    }\r\n\r\n  if (hasMedia) {\r\n    if (isArray(mediaOnRoot)) {\r\n      each(mediaOnRoot, function (singleMedia) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          // Real case of wrong config.\r\n          if (singleMedia && !singleMedia.option && isObject(singleMedia.query) && isObject(singleMedia.query.option)) {\r\n            error('Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }');\r\n          }\r\n        }\r\n\r\n        if (singleMedia && singleMedia.option) {\r\n          if (singleMedia.query) {\r\n            mediaList.push(singleMedia);\r\n          } else if (!mediaDefault) {\r\n            // Use the first media default.\r\n            mediaDefault = singleMedia;\r\n          }\r\n        }\r\n      });\r\n    } else {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        // Real case of wrong config.\r\n        error('Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }');\r\n      }\r\n    }\r\n  }\r\n\r\n  doPreprocess(baseOption);\r\n  each(timelineOptionsOnRoot, function (option) {\r\n    return doPreprocess(option);\r\n  });\r\n  each(mediaList, function (media) {\r\n    return doPreprocess(media.option);\r\n  });\r\n\r\n  function doPreprocess(option) {\r\n    each(optionPreprocessorFuncs, function (preProcess) {\r\n      preProcess(option, isNew);\r\n    });\r\n  }\r\n\r\n  return {\r\n    baseOption: baseOption,\r\n    timelineOptions: timelineOptionsOnRoot || [],\r\n    mediaDefault: mediaDefault,\r\n    mediaList: mediaList\r\n  };\r\n}\r\n/**\r\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\r\n * Support: width, height, aspectRatio\r\n * Can use max or min as prefix.\r\n */\r\n\r\n\r\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\r\n  var realMap = {\r\n    width: ecWidth,\r\n    height: ecHeight,\r\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\r\n\r\n  };\r\n  var applicatable = true;\r\n  each(query, function (value, attr) {\r\n    var matched = attr.match(QUERY_REG);\r\n\r\n    if (!matched || !matched[1] || !matched[2]) {\r\n      return;\r\n    }\r\n\r\n    var operator = matched[1];\r\n    var realAttr = matched[2].toLowerCase();\r\n\r\n    if (!compare(realMap[realAttr], value, operator)) {\r\n      applicatable = false;\r\n    }\r\n  });\r\n  return applicatable;\r\n}\r\n\r\nfunction compare(real, expect, operator) {\r\n  if (operator === 'min') {\r\n    return real >= expect;\r\n  } else if (operator === 'max') {\r\n    return real <= expect;\r\n  } else {\r\n    // Equals\r\n    return real === expect;\r\n  }\r\n}\r\n\r\nfunction indicesEquals(indices1, indices2) {\r\n  // indices is always order by asc and has only finite number.\r\n  return indices1.join(',') === indices2.join(',');\r\n}\r\n/**\r\n * Consider case:\r\n * `chart.setOption(opt1);`\r\n * Then user do some interaction like dataZoom, dataView changing.\r\n * `chart.setOption(opt2);`\r\n * Then user press 'reset button' in toolbox.\r\n *\r\n * After doing that all of the interaction effects should be reset, the\r\n * chart should be the same as the result of invoke\r\n * `chart.setOption(opt1); chart.setOption(opt2);`.\r\n *\r\n * Although it is not able ensure that\r\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\r\n * `chart.setOption(merge(opt1, opt2));` exactly,\r\n * this might be the only simple way to implement that feature.\r\n *\r\n * MEMO: We've considered some other approaches:\r\n * 1. Each model handle its self restoration but not uniform treatment.\r\n *     (Too complex in logic and error-prone)\r\n * 2. Use a shadow ecModel. (Performace expensive)\r\n *\r\n * FIXME: A possible solution:\r\n * Add a extra level of model for each component model. The inheritance chain would be:\r\n * ecModel <- componentModel <- componentActionModel <- dataItemModel\r\n * And all of the actions can only modify the `componentActionModel` rather than\r\n * `componentModel`. `setOption` will only modify the `ecModel` and `componentModel`.\r\n * When \"resotre\" action triggered, model from `componentActionModel` will be discarded\r\n * instead of recreating the \"ecModel\" from the \"_optionBackup\".\r\n */\r\n// function mergeToBackupOption(\r\n//     fakeCmptsMap: FakeComponentsMap,\r\n//     // `tarOption` Can be null/undefined, means init\r\n//     tarOption: ECUnitOption,\r\n//     newOption: ECUnitOption,\r\n//     // Can be null/undefined\r\n//     opt: InnerSetOptionOpts\r\n// ): void {\r\n//     newOption = newOption || {} as ECUnitOption;\r\n//     const notInit = !!tarOption;\r\n//     each(newOption, function (newOptsInMainType, mainType) {\r\n//         if (newOptsInMainType == null) {\r\n//             return;\r\n//         }\r\n//         if (!ComponentModel.hasClass(mainType)) {\r\n//             if (tarOption) {\r\n//                 tarOption[mainType] = merge(tarOption[mainType], newOptsInMainType, true);\r\n//             }\r\n//         }\r\n//         else {\r\n//             const oldTarOptsInMainType = notInit ? normalizeToArray(tarOption[mainType]) : null;\r\n//             const oldFakeCmptsInMainType = fakeCmptsMap.get(mainType) || [];\r\n//             const resultTarOptsInMainType = notInit ? (tarOption[mainType] = [] as ComponentOption[]) : null;\r\n//             const resultFakeCmptsInMainType = fakeCmptsMap.set(mainType, []);\r\n//             const mappingResult = mappingToExists(\r\n//                 oldFakeCmptsInMainType,\r\n//                 normalizeToArray(newOptsInMainType),\r\n//                 (opt && opt.replaceMergeMainTypeMap.get(mainType)) ? 'replaceMerge' : 'normalMerge'\r\n//             );\r\n//             setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel as ComponentModelConstructor);\r\n//             each(mappingResult, function (resultItem, index) {\r\n//                 // The same logic as `Global.ts#_mergeOption`.\r\n//                 let fakeCmpt = resultItem.existing;\r\n//                 const newOption = resultItem.newOption;\r\n//                 const keyInfo = resultItem.keyInfo;\r\n//                 let fakeCmptOpt;\r\n//                 if (!newOption) {\r\n//                     fakeCmptOpt = oldTarOptsInMainType[index];\r\n//                 }\r\n//                 else {\r\n//                     if (fakeCmpt && fakeCmpt.subType === keyInfo.subType) {\r\n//                         fakeCmpt.name = keyInfo.name;\r\n//                         if (notInit) {\r\n//                             fakeCmptOpt = merge(oldTarOptsInMainType[index], newOption, true);\r\n//                         }\r\n//                     }\r\n//                     else {\r\n//                         fakeCmpt = extend({}, keyInfo);\r\n//                         if (notInit) {\r\n//                             fakeCmptOpt = clone(newOption);\r\n//                         }\r\n//                     }\r\n//                 }\r\n//                 if (fakeCmpt) {\r\n//                     notInit && resultTarOptsInMainType.push(fakeCmptOpt);\r\n//                     resultFakeCmptsInMainType.push(fakeCmpt);\r\n//                 }\r\n//                 else {\r\n//                     notInit && resultTarOptsInMainType.push(void 0);\r\n//                     resultFakeCmptsInMainType.push(void 0);\r\n//                 }\r\n//             });\r\n//         }\r\n//     });\r\n// }\r\n\r\n\r\nexport default OptionManager;"],"mappings":"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"},"metadata":{},"sourceType":"module"}