{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { __extends } from \"tslib\";\n/**\r\n * Caution: If the mechanism should be changed some day, these cases\r\n * should be considered:\r\n *\r\n * (1) In `merge option` mode, if using the same option to call `setOption`\r\n * many times, the result should be the same (try our best to ensure that).\r\n * (2) In `merge option` mode, if a component has no id/name specified, it\r\n * will be merged by index, and the result sequence of the components is\r\n * consistent to the original sequence.\r\n * (3) In `replaceMerge` mode, keep the result sequence of the components is\r\n * consistent to the original sequence, even though there might result in \"hole\".\r\n * (4) `reset` feature (in toolbox). Find detailed info in comments about\r\n * `mergeOption` in module:echarts/model/OptionManager.\r\n */\n\nimport { each, filter, isArray, isObject, isString, createHashMap, assert, clone, merge, extend, mixin, isFunction } from 'zrender/lib/core/util.js';\nimport * as modelUtil from '../util/model.js';\nimport Model from './Model.js';\nimport ComponentModel from './Component.js';\nimport globalDefault from './globalDefault.js';\nimport { resetSourceDefaulter } from '../data/helper/sourceHelper.js';\nimport { concatInternalOptions } from './internalComponentCreator.js';\nimport { PaletteMixin } from './mixin/palette.js';\nimport { error, warn } from '../util/log.js'; // -----------------------\n// Internal method names:\n// -----------------------\n\nvar reCreateSeriesIndices;\nvar assertSeriesInitialized;\nvar initBase;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\nvar OPTION_INNER_VALUE = 1;\nvar BUITIN_COMPONENTS_MAP = {\n  grid: 'GridComponent',\n  polar: 'PolarComponent',\n  geo: 'GeoComponent',\n  singleAxis: 'SingleAxisComponent',\n  parallel: 'ParallelComponent',\n  calendar: 'CalendarComponent',\n  graphic: 'GraphicComponent',\n  toolbox: 'ToolboxComponent',\n  tooltip: 'TooltipComponent',\n  axisPointer: 'AxisPointerComponent',\n  brush: 'BrushComponent',\n  title: 'TitleComponent',\n  timeline: 'TimelineComponent',\n  markPoint: 'MarkPointComponent',\n  markLine: 'MarkLineComponent',\n  markArea: 'MarkAreaComponent',\n  legend: 'LegendComponent',\n  dataZoom: 'DataZoomComponent',\n  visualMap: 'VisualMapComponent',\n  // aria: 'AriaComponent',\n  // dataset: 'DatasetComponent',\n  // Dependencies\n  xAxis: 'GridComponent',\n  yAxis: 'GridComponent',\n  angleAxis: 'PolarComponent',\n  radiusAxis: 'PolarComponent'\n};\nvar BUILTIN_CHARTS_MAP = {\n  line: 'LineChart',\n  bar: 'BarChart',\n  pie: 'PieChart',\n  scatter: 'ScatterChart',\n  radar: 'RadarChart',\n  map: 'MapChart',\n  tree: 'TreeChart',\n  treemap: 'TreemapChart',\n  graph: 'GraphChart',\n  gauge: 'GaugeChart',\n  funnel: 'FunnelChart',\n  parallel: 'ParallelChart',\n  sankey: 'SankeyChart',\n  boxplot: 'BoxplotChart',\n  candlestick: 'CandlestickChart',\n  effectScatter: 'EffectScatterChart',\n  lines: 'LinesChart',\n  heatmap: 'HeatmapChart',\n  pictorialBar: 'PictorialBarChart',\n  themeRiver: 'ThemeRiverChart',\n  sunburst: 'SunburstChart',\n  custom: 'CustomChart'\n};\nvar componetsMissingLogPrinted = {};\n\nfunction checkMissingComponents(option) {\n  each(option, function (componentOption, mainType) {\n    if (!ComponentModel.hasClass(mainType)) {\n      var componentImportName = BUITIN_COMPONENTS_MAP[mainType];\n\n      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {\n        error(\"Component \" + mainType + \" is used but not imported.\\nimport { \" + componentImportName + \" } from 'echarts/components';\\necharts.use([\" + componentImportName + \"]);\");\n        componetsMissingLogPrinted[componentImportName] = true;\n      }\n    }\n  });\n}\n\nvar GlobalModel =\n/** @class */\nfunction (_super) {\n  __extends(GlobalModel, _super);\n\n  function GlobalModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    this._theme = new Model(theme);\n    this._locale = new Model(locale);\n    this._optionManager = optionManager;\n  };\n\n  GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(option != null, 'option is null/undefined');\n      assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, 'please use chart.getOption()');\n    }\n\n    var innerOpt = normalizeSetOptionInput(opts);\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);\n\n    this._resetOption(null, innerOpt);\n  };\n  /**\r\n   * @param type null/undefined: reset all.\r\n   *        'recreate': force recreate all.\r\n   *        'timeline': only reset timeline option\r\n   *        'media': only reset media query option\r\n   * @return Whether option changed.\r\n   */\n\n\n  GlobalModel.prototype.resetOption = function (type, opt) {\n    return this._resetOption(type, normalizeSetOptionInput(opt));\n  };\n\n  GlobalModel.prototype._resetOption = function (type, opt) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkMissingComponents(baseOption);\n      }\n\n      if (!this.option || type === 'recreate') {\n        initBase(this, baseOption);\n      } else {\n        this.restoreData();\n\n        this._mergeOption(baseOption, opt);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    } // By design, if `setOption(option2)` at the second time, and `option2` is a `ECUnitOption`,\n    // it should better not have the same props with `MediaUnit['option']`.\n    // Becuase either `option2` or `MediaUnit['option']` will be always merged to \"current option\"\n    // rather than original \"baseOption\". If they both override a prop, the result might be\n    // unexpected when media state changed after `setOption` called.\n    // If we really need to modify a props in each `MediaUnit['option']`, use the full version\n    // (`{baseOption, media}`) in `setOption`.\n    // For `timeline`, the case is the same.\n\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n\n      if (timelineOption) {\n        optionChanged = true;\n\n        this._mergeOption(timelineOption, opt);\n      }\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          optionChanged = true;\n\n          this._mergeOption(mediaOption, opt);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  };\n\n  GlobalModel.prototype.mergeOption = function (option) {\n    this._mergeOption(option, null);\n  };\n\n  GlobalModel.prototype._mergeOption = function (newOption, opt) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var componentsCount = this._componentsCount;\n    var newCmptTypes = [];\n    var newCmptTypeMap = createHashMap();\n    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;\n    resetSourceDefaulter(this); // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCmptTypes.push(mainType);\n        newCmptTypeMap.set(mainType, true);\n      }\n    });\n\n    if (replaceMergeMainTypeMap) {\n      // If there is a mainType `xxx` in `replaceMerge` but not declared in option,\n      // we trade it as it is declared in option as `{xxx: []}`. Because:\n      // (1) for normal merge, `{xxx: null/undefined}` are the same meaning as `{xxx: []}`.\n      // (2) some preprocessor may convert some of `{xxx: null/undefined}` to `{xxx: []}`.\n      replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {\n        if (ComponentModel.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {\n          newCmptTypes.push(mainTypeInReplaceMerge);\n          newCmptTypeMap.set(mainTypeInReplaceMerge, true);\n        }\n      });\n    }\n\n    ComponentModel.topologicalTravel(newCmptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\n    function visitComponent(mainType) {\n      var newCmptOptionList = concatInternalOptions(this, mainType, modelUtil.normalizeToArray(newOption[mainType]));\n      var oldCmptList = componentsMap.get(mainType);\n      var mergeMode = // `!oldCmptList` means init. See the comment in `mappingToExists`\n      !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge';\n      var mappingResult = modelUtil.mappingToExists(oldCmptList, newCmptOptionList, mergeMode); // Set mainType and complete subType.\n\n      modelUtil.setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel); // Empty it before the travel, in order to prevent `this._componentsMap`\n      // from being used in the `init`/`mergeOption`/`optionUpdated` of some\n      // components, which is probably incorrect logic.\n\n      option[mainType] = null;\n      componentsMap.set(mainType, null);\n      componentsCount.set(mainType, 0);\n      var optionsByMainType = [];\n      var cmptsByMainType = [];\n      var cmptsCountByMainType = 0;\n      var tooltipExists;\n      var tooltipWarningLogged;\n      each(mappingResult, function (resultItem, index) {\n        var componentModel = resultItem.existing;\n        var newCmptOption = resultItem.newOption;\n\n        if (!newCmptOption) {\n          if (componentModel) {\n            // Consider where is no new option and should be merged using {},\n            // see removeEdgeAndAdd in topologicalTravel and\n            // ComponentModel.getAllClassMainTypes.\n            componentModel.mergeOption({}, this);\n            componentModel.optionUpdated({}, false);\n          } // If no both `resultItem.exist` and `resultItem.option`,\n          // either it is in `replaceMerge` and not matched by any id,\n          // or it has been removed in previous `replaceMerge` and left a \"hole\" in this component index.\n\n        } else {\n          var isSeriesType = mainType === 'series';\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType // Give a more detailed warn later if series don't exists\n          );\n\n          if (!ComponentModelClass) {\n            if (process.env.NODE_ENV !== 'production') {\n              var subType = resultItem.keyInfo.subType;\n              var seriesImportName = BUILTIN_CHARTS_MAP[subType];\n\n              if (!componetsMissingLogPrinted[subType]) {\n                componetsMissingLogPrinted[subType] = true;\n\n                if (seriesImportName) {\n                  error(\"Series \" + subType + \" is used but not imported.\\nimport { \" + seriesImportName + \" } from 'echarts/charts';\\necharts.use([\" + seriesImportName + \"]);\");\n                } else {\n                  error(\"Unkown series \" + subType);\n                }\n              }\n            }\n\n            return;\n          } // TODO Before multiple tooltips get supported, we do this check to avoid unexpected exception.\n\n\n          if (mainType === 'tooltip') {\n            if (tooltipExists) {\n              if (process.env.NODE_ENV !== 'production') {\n                if (!tooltipWarningLogged) {\n                  warn('Currently only one tooltip component is allowed.');\n                  tooltipWarningLogged = true;\n                }\n              }\n\n              return;\n            }\n\n            tooltipExists = true;\n          }\n\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\n\n            componentModel.mergeOption(newCmptOption, this);\n            componentModel.optionUpdated(newCmptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = extend({\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt); // Assign `keyInfo`\n\n            extend(componentModel, extraOpt);\n\n            if (resultItem.brandNew) {\n              componentModel.__requireNewView = true;\n            }\n\n            componentModel.init(newCmptOption, this, this); // Call optionUpdated after init.\n            // newCmptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        if (componentModel) {\n          optionsByMainType.push(componentModel.option);\n          cmptsByMainType.push(componentModel);\n          cmptsCountByMainType++;\n        } else {\n          // Always do assign to avoid elided item in array.\n          optionsByMainType.push(void 0);\n          cmptsByMainType.push(void 0);\n        }\n      }, this);\n      option[mainType] = optionsByMainType;\n      componentsMap.set(mainType, cmptsByMainType);\n      componentsCount.set(mainType, cmptsCountByMainType); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        reCreateSeriesIndices(this);\n      }\n    } // If no series declared, ensure `_seriesIndices` initialized.\n\n\n    if (!this._seriesIndices) {\n      reCreateSeriesIndices(this);\n    }\n  };\n  /**\r\n   * Get option for output (cloned option and inner info removed)\r\n   */\n\n\n  GlobalModel.prototype.getOption = function () {\n    var option = clone(this.option);\n    each(option, function (optInMainType, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(optInMainType); // Inner cmpts need to be removed.\n        // Inner cmpts might not be at last since ec5.0, but still\n        // compatible for users: if inner cmpt at last, splice the returned array.\n\n        var realLen = opts.length;\n        var metNonInner = false;\n\n        for (var i = realLen - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (opts[i] && !modelUtil.isComponentIdInternal(opts[i])) {\n            metNonInner = true;\n          } else {\n            opts[i] = null;\n            !metNonInner && realLen--;\n          }\n        }\n\n        opts.length = realLen;\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  };\n\n  GlobalModel.prototype.getTheme = function () {\n    return this._theme;\n  };\n\n  GlobalModel.prototype.getLocaleModel = function () {\n    return this._locale;\n  };\n\n  GlobalModel.prototype.setUpdatePayload = function (payload) {\n    this._payload = payload;\n  };\n\n  GlobalModel.prototype.getUpdatePayload = function () {\n    return this._payload;\n  };\n  /**\r\n   * @param idx If not specified, return the first one.\r\n   */\n\n\n  GlobalModel.prototype.getComponent = function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      var cmpt = list[idx || 0];\n\n      if (cmpt) {\n        return cmpt;\n      } else if (idx == null) {\n        for (var i = 0; i < list.length; i++) {\n          if (list[i]) {\n            return list[i];\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * @return Never be null/undefined.\r\n   */\n\n\n  GlobalModel.prototype.queryComponents = function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cmpts = this._componentsMap.get(mainType);\n\n    if (!cmpts || !cmpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      result = [];\n      each(modelUtil.normalizeToArray(index), function (idx) {\n        cmpts[idx] && result.push(cmpts[idx]);\n      });\n    } else if (id != null) {\n      result = queryByIdOrName('id', id, cmpts);\n    } else if (name != null) {\n      result = queryByIdOrName('name', name, cmpts);\n    } else {\n      // Return all non-empty components in that mainType\n      result = filter(cmpts, function (cmpt) {\n        return !!cmpt;\n      });\n    }\n\n    return filterBySubType(result, condition);\n  };\n  /**\r\n   * The interface is different from queryComponents,\r\n   * which is convenient for inner usage.\r\n   *\r\n   * @usage\r\n   * let result = findComponents(\r\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\r\n   * );\r\n   * let result = findComponents(\r\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\r\n   * );\r\n   * let result = findComponents(\r\n   *     {mainType: 'series',\r\n   *     filter: function (model, index) {...}}\r\n   * );\r\n   * // result like [component0, componnet1, ...]\r\n   */\n\n\n  GlobalModel.prototype.findComponents = function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) // Retrieve all non-empty components.\n    : filter(this._componentsMap.get(mainType), function (cmpt) {\n      return !!cmpt;\n    });\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  };\n\n  GlobalModel.prototype.eachComponent = function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (isFunction(mainType)) {\n      var ctxForAll_1 = cb;\n      var cbForAll_1 = mainType;\n      componentsMap.each(function (cmpts, componentType) {\n        for (var i = 0; cmpts && i < cmpts.length; i++) {\n          var cmpt = cmpts[i];\n          cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex);\n        }\n      });\n    } else {\n      var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null;\n\n      for (var i = 0; cmpts && i < cmpts.length; i++) {\n        var cmpt = cmpts[i];\n        cmpt && cb.call(context, cmpt, cmpt.componentIndex);\n      }\n    }\n  };\n  /**\r\n   * Get series list before filtered by name.\r\n   */\n\n\n  GlobalModel.prototype.getSeriesByName = function (name) {\n    var nameStr = modelUtil.convertOptionIdName(name, null);\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;\n    });\n  };\n  /**\r\n   * Get series list before filtered by index.\r\n   */\n\n\n  GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  };\n  /**\r\n   * Get series list before filtered by type.\r\n   * FIXME: rename to getRawSeriesByType?\r\n   */\n\n\n  GlobalModel.prototype.getSeriesByType = function (subType) {\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && oneSeries.subType === subType;\n    });\n  };\n  /**\r\n   * Get all series before filtered.\r\n   */\n\n\n  GlobalModel.prototype.getSeries = function () {\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries;\n    });\n  };\n  /**\r\n   * Count series before filtered.\r\n   */\n\n\n  GlobalModel.prototype.getSeriesCount = function () {\n    return this._componentsCount.get('series');\n  };\n  /**\r\n   * After filtering, series may be different\r\n   * frome raw series.\r\n   */\n\n\n  GlobalModel.prototype.eachSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  };\n  /**\r\n   * Iterate raw series before filtered.\r\n   *\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\n\n\n  GlobalModel.prototype.eachRawSeries = function (cb, context) {\n    each(this._componentsMap.get('series'), function (series) {\n      series && cb.call(context, series, series.componentIndex);\n    });\n  };\n  /**\r\n   * After filtering, series may be different.\r\n   * frome raw series.\r\n   */\n\n\n  GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  };\n  /**\r\n   * Iterate raw series before filtered of given type.\r\n   */\n\n\n  GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  };\n\n  GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  };\n\n  GlobalModel.prototype.getCurrentSeriesIndices = function () {\n    return (this._seriesIndices || []).slice();\n  };\n\n  GlobalModel.prototype.filterSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    var newSeriesIndices = [];\n    each(this._seriesIndices, function (seriesRawIdx) {\n      var series = this._componentsMap.get('series')[seriesRawIdx];\n\n      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);\n    }, this);\n    this._seriesIndices = newSeriesIndices;\n    this._seriesIndicesMap = createHashMap(newSeriesIndices);\n  };\n\n  GlobalModel.prototype.restoreData = function (payload) {\n    reCreateSeriesIndices(this);\n    var componentsMap = this._componentsMap;\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      if (ComponentModel.hasClass(componentType)) {\n        componentTypes.push(componentType);\n      }\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType) {\n      each(componentsMap.get(componentType), function (component) {\n        if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {\n          component.restoreData();\n        }\n      });\n    });\n  };\n\n  GlobalModel.internalField = function () {\n    reCreateSeriesIndices = function (ecModel) {\n      var seriesIndices = ecModel._seriesIndices = [];\n      each(ecModel._componentsMap.get('series'), function (series) {\n        // series may have been removed by `replaceMerge`.\n        series && seriesIndices.push(series.componentIndex);\n      });\n      ecModel._seriesIndicesMap = createHashMap(seriesIndices);\n    };\n\n    assertSeriesInitialized = function (ecModel) {\n      // Components that use _seriesIndices should depends on series component,\n      // which make sure that their initialization is after series.\n      if (process.env.NODE_ENV !== 'production') {\n        if (!ecModel._seriesIndices) {\n          throw new Error('Option should contains series.');\n        }\n      }\n    };\n\n    initBase = function (ecModel, baseOption) {\n      // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n      // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n      ecModel.option = {};\n      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE; // Init with series: [], in case of calling findSeries method\n      // before series initialized.\n\n      ecModel._componentsMap = createHashMap({\n        series: []\n      });\n      ecModel._componentsCount = createHashMap(); // If user spefied `option.aria`, aria will be enable. This detection should be\n      // performed before theme and globalDefault merge.\n\n      var airaOption = baseOption.aria;\n\n      if (isObject(airaOption) && airaOption.enabled == null) {\n        airaOption.enabled = true;\n      }\n\n      mergeTheme(baseOption, ecModel._theme.option); // TODO Needs clone when merging to the unexisted property\n\n      merge(baseOption, globalDefault, false);\n\n      ecModel._mergeOption(baseOption, null);\n    };\n  }();\n\n  return GlobalModel;\n}(Model);\n\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seriesIndex;\n    var id = payload.seriesId;\n    var name_1 = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;\n  }\n}\n\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  each(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    } // If it is component model mainType, the model handles that merge later.\n    // otherwise, merge them here.\n\n\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction queryByIdOrName(attr, idOrName, cmpts) {\n  // Here is a break from echarts4: string and number are\n  // treated as equal.\n  if (isArray(idOrName)) {\n    var keyMap_1 = createHashMap();\n    each(idOrName, function (idOrNameItem) {\n      if (idOrNameItem != null) {\n        var idName = modelUtil.convertOptionIdName(idOrNameItem, null);\n        idName != null && keyMap_1.set(idOrNameItem, true);\n      }\n    });\n    return filter(cmpts, function (cmpt) {\n      return cmpt && keyMap_1.get(cmpt[attr]);\n    });\n  } else {\n    var idName_1 = modelUtil.convertOptionIdName(idOrName, null);\n    return filter(cmpts, function (cmpt) {\n      return cmpt && idName_1 != null && cmpt[attr] === idName_1;\n    });\n  }\n}\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cmpt) {\n    return cmpt && cmpt.subType === condition.subType;\n  }) : components;\n}\n\nfunction normalizeSetOptionInput(opts) {\n  var replaceMergeMainTypeMap = createHashMap();\n  opts && each(modelUtil.normalizeToArray(opts.replaceMerge), function (mainType) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(ComponentModel.hasClass(mainType), '\"' + mainType + '\" is not valid component main type in \"replaceMerge\"');\n    }\n\n    replaceMergeMainTypeMap.set(mainType, true);\n  });\n  return {\n    replaceMergeMainTypeMap: replaceMergeMainTypeMap\n  };\n}\n\nmixin(GlobalModel, PaletteMixin);\nexport default GlobalModel;","map":{"version":3,"names":["__extends","each","filter","isArray","isObject","isString","createHashMap","assert","clone","merge","extend","mixin","isFunction","modelUtil","Model","ComponentModel","globalDefault","resetSourceDefaulter","concatInternalOptions","PaletteMixin","error","warn","reCreateSeriesIndices","assertSeriesInitialized","initBase","OPTION_INNER_KEY","OPTION_INNER_VALUE","BUITIN_COMPONENTS_MAP","grid","polar","geo","singleAxis","parallel","calendar","graphic","toolbox","tooltip","axisPointer","brush","title","timeline","markPoint","markLine","markArea","legend","dataZoom","visualMap","xAxis","yAxis","angleAxis","radiusAxis","BUILTIN_CHARTS_MAP","line","bar","pie","scatter","radar","map","tree","treemap","graph","gauge","funnel","sankey","boxplot","candlestick","effectScatter","lines","heatmap","pictorialBar","themeRiver","sunburst","custom","componetsMissingLogPrinted","checkMissingComponents","option","componentOption","mainType","hasClass","componentImportName","GlobalModel","_super","apply","arguments","prototype","init","parentModel","ecModel","theme","locale","optionManager","_theme","_locale","_optionManager","setOption","opts","optionPreprocessorFuncs","process","env","NODE_ENV","innerOpt","normalizeSetOptionInput","_resetOption","resetOption","type","opt","optionChanged","baseOption","mountOption","restoreData","_mergeOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","length","mediaOption","mergeOption","newOption","componentsMap","_componentsMap","componentsCount","_componentsCount","newCmptTypes","newCmptTypeMap","replaceMergeMainTypeMap","push","set","val","mainTypeInReplaceMerge","get","topologicalTravel","getAllClassMainTypes","visitComponent","newCmptOptionList","normalizeToArray","oldCmptList","mergeMode","mappingResult","mappingToExists","setComponentTypeToKeyInfo","optionsByMainType","cmptsByMainType","cmptsCountByMainType","tooltipExists","tooltipWarningLogged","resultItem","index","componentModel","existing","newCmptOption","optionUpdated","isSeriesType","ComponentModelClass","getClass","keyInfo","subType","seriesImportName","constructor","name","extraOpt","componentIndex","brandNew","__requireNewView","_seriesIndices","getOption","optInMainType","realLen","metNonInner","i","isComponentIdInternal","getTheme","getLocaleModel","setUpdatePayload","payload","_payload","getUpdatePayload","getComponent","idx","list","cmpt","queryComponents","condition","id","cmpts","result","queryByIdOrName","filterBySubType","findComponents","query","queryCond","getQueryCond","doFilter","q","indexAttr","idAttr","nameAttr","res","eachComponent","cb","context","ctxForAll_1","cbForAll_1","componentType","call","getSeriesByName","nameStr","convertOptionIdName","oneSeries","getSeriesByIndex","seriesIndex","getSeriesByType","getSeries","getSeriesCount","eachSeries","rawSeriesIndex","series","eachRawSeries","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","seriesModel","_seriesIndicesMap","getCurrentSeriesIndices","slice","filterSeries","newSeriesIndices","seriesRawIdx","componentTypes","components","component","isNotTargetSeries","internalField","seriesIndices","Error","airaOption","aria","enabled","mergeTheme","seriesId","name_1","seriesName","notMergeColorLayer","color","colorLayer","themeItem","attr","idOrName","keyMap_1","idOrNameItem","idName","idName_1","hasOwnProperty","replaceMerge"],"sources":["E:/各个学科/论文/毕业论文/Atmosphere/eco-friendly/node_modules/echarts/lib/model/Global.js"],"sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * Caution: If the mechanism should be changed some day, these cases\r\n * should be considered:\r\n *\r\n * (1) In `merge option` mode, if using the same option to call `setOption`\r\n * many times, the result should be the same (try our best to ensure that).\r\n * (2) In `merge option` mode, if a component has no id/name specified, it\r\n * will be merged by index, and the result sequence of the components is\r\n * consistent to the original sequence.\r\n * (3) In `replaceMerge` mode, keep the result sequence of the components is\r\n * consistent to the original sequence, even though there might result in \"hole\".\r\n * (4) `reset` feature (in toolbox). Find detailed info in comments about\r\n * `mergeOption` in module:echarts/model/OptionManager.\r\n */\r\n\r\nimport { each, filter, isArray, isObject, isString, createHashMap, assert, clone, merge, extend, mixin, isFunction } from 'zrender/lib/core/util.js';\r\nimport * as modelUtil from '../util/model.js';\r\nimport Model from './Model.js';\r\nimport ComponentModel from './Component.js';\r\nimport globalDefault from './globalDefault.js';\r\nimport { resetSourceDefaulter } from '../data/helper/sourceHelper.js';\r\nimport { concatInternalOptions } from './internalComponentCreator.js';\r\nimport { PaletteMixin } from './mixin/palette.js';\r\nimport { error, warn } from '../util/log.js'; // -----------------------\r\n// Internal method names:\r\n// -----------------------\r\n\r\nvar reCreateSeriesIndices;\r\nvar assertSeriesInitialized;\r\nvar initBase;\r\nvar OPTION_INNER_KEY = '\\0_ec_inner';\r\nvar OPTION_INNER_VALUE = 1;\r\nvar BUITIN_COMPONENTS_MAP = {\r\n  grid: 'GridComponent',\r\n  polar: 'PolarComponent',\r\n  geo: 'GeoComponent',\r\n  singleAxis: 'SingleAxisComponent',\r\n  parallel: 'ParallelComponent',\r\n  calendar: 'CalendarComponent',\r\n  graphic: 'GraphicComponent',\r\n  toolbox: 'ToolboxComponent',\r\n  tooltip: 'TooltipComponent',\r\n  axisPointer: 'AxisPointerComponent',\r\n  brush: 'BrushComponent',\r\n  title: 'TitleComponent',\r\n  timeline: 'TimelineComponent',\r\n  markPoint: 'MarkPointComponent',\r\n  markLine: 'MarkLineComponent',\r\n  markArea: 'MarkAreaComponent',\r\n  legend: 'LegendComponent',\r\n  dataZoom: 'DataZoomComponent',\r\n  visualMap: 'VisualMapComponent',\r\n  // aria: 'AriaComponent',\r\n  // dataset: 'DatasetComponent',\r\n  // Dependencies\r\n  xAxis: 'GridComponent',\r\n  yAxis: 'GridComponent',\r\n  angleAxis: 'PolarComponent',\r\n  radiusAxis: 'PolarComponent'\r\n};\r\nvar BUILTIN_CHARTS_MAP = {\r\n  line: 'LineChart',\r\n  bar: 'BarChart',\r\n  pie: 'PieChart',\r\n  scatter: 'ScatterChart',\r\n  radar: 'RadarChart',\r\n  map: 'MapChart',\r\n  tree: 'TreeChart',\r\n  treemap: 'TreemapChart',\r\n  graph: 'GraphChart',\r\n  gauge: 'GaugeChart',\r\n  funnel: 'FunnelChart',\r\n  parallel: 'ParallelChart',\r\n  sankey: 'SankeyChart',\r\n  boxplot: 'BoxplotChart',\r\n  candlestick: 'CandlestickChart',\r\n  effectScatter: 'EffectScatterChart',\r\n  lines: 'LinesChart',\r\n  heatmap: 'HeatmapChart',\r\n  pictorialBar: 'PictorialBarChart',\r\n  themeRiver: 'ThemeRiverChart',\r\n  sunburst: 'SunburstChart',\r\n  custom: 'CustomChart'\r\n};\r\nvar componetsMissingLogPrinted = {};\r\n\r\nfunction checkMissingComponents(option) {\r\n  each(option, function (componentOption, mainType) {\r\n    if (!ComponentModel.hasClass(mainType)) {\r\n      var componentImportName = BUITIN_COMPONENTS_MAP[mainType];\r\n\r\n      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {\r\n        error(\"Component \" + mainType + \" is used but not imported.\\nimport { \" + componentImportName + \" } from 'echarts/components';\\necharts.use([\" + componentImportName + \"]);\");\r\n        componetsMissingLogPrinted[componentImportName] = true;\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nvar GlobalModel =\r\n/** @class */\r\nfunction (_super) {\r\n  __extends(GlobalModel, _super);\r\n\r\n  function GlobalModel() {\r\n    return _super !== null && _super.apply(this, arguments) || this;\r\n  }\r\n\r\n  GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {\r\n    theme = theme || {};\r\n    this.option = null; // Mark as not initialized.\r\n\r\n    this._theme = new Model(theme);\r\n    this._locale = new Model(locale);\r\n    this._optionManager = optionManager;\r\n  };\r\n\r\n  GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assert(option != null, 'option is null/undefined');\r\n      assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, 'please use chart.getOption()');\r\n    }\r\n\r\n    var innerOpt = normalizeSetOptionInput(opts);\r\n\r\n    this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);\r\n\r\n    this._resetOption(null, innerOpt);\r\n  };\r\n  /**\r\n   * @param type null/undefined: reset all.\r\n   *        'recreate': force recreate all.\r\n   *        'timeline': only reset timeline option\r\n   *        'media': only reset media query option\r\n   * @return Whether option changed.\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.resetOption = function (type, opt) {\r\n    return this._resetOption(type, normalizeSetOptionInput(opt));\r\n  };\r\n\r\n  GlobalModel.prototype._resetOption = function (type, opt) {\r\n    var optionChanged = false;\r\n    var optionManager = this._optionManager;\r\n\r\n    if (!type || type === 'recreate') {\r\n      var baseOption = optionManager.mountOption(type === 'recreate');\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        checkMissingComponents(baseOption);\r\n      }\r\n\r\n      if (!this.option || type === 'recreate') {\r\n        initBase(this, baseOption);\r\n      } else {\r\n        this.restoreData();\r\n\r\n        this._mergeOption(baseOption, opt);\r\n      }\r\n\r\n      optionChanged = true;\r\n    }\r\n\r\n    if (type === 'timeline' || type === 'media') {\r\n      this.restoreData();\r\n    } // By design, if `setOption(option2)` at the second time, and `option2` is a `ECUnitOption`,\r\n    // it should better not have the same props with `MediaUnit['option']`.\r\n    // Becuase either `option2` or `MediaUnit['option']` will be always merged to \"current option\"\r\n    // rather than original \"baseOption\". If they both override a prop, the result might be\r\n    // unexpected when media state changed after `setOption` called.\r\n    // If we really need to modify a props in each `MediaUnit['option']`, use the full version\r\n    // (`{baseOption, media}`) in `setOption`.\r\n    // For `timeline`, the case is the same.\r\n\r\n\r\n    if (!type || type === 'recreate' || type === 'timeline') {\r\n      var timelineOption = optionManager.getTimelineOption(this);\r\n\r\n      if (timelineOption) {\r\n        optionChanged = true;\r\n\r\n        this._mergeOption(timelineOption, opt);\r\n      }\r\n    }\r\n\r\n    if (!type || type === 'recreate' || type === 'media') {\r\n      var mediaOptions = optionManager.getMediaOption(this);\r\n\r\n      if (mediaOptions.length) {\r\n        each(mediaOptions, function (mediaOption) {\r\n          optionChanged = true;\r\n\r\n          this._mergeOption(mediaOption, opt);\r\n        }, this);\r\n      }\r\n    }\r\n\r\n    return optionChanged;\r\n  };\r\n\r\n  GlobalModel.prototype.mergeOption = function (option) {\r\n    this._mergeOption(option, null);\r\n  };\r\n\r\n  GlobalModel.prototype._mergeOption = function (newOption, opt) {\r\n    var option = this.option;\r\n    var componentsMap = this._componentsMap;\r\n    var componentsCount = this._componentsCount;\r\n    var newCmptTypes = [];\r\n    var newCmptTypeMap = createHashMap();\r\n    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;\r\n    resetSourceDefaulter(this); // If no component class, merge directly.\r\n    // For example: color, animaiton options, etc.\r\n\r\n    each(newOption, function (componentOption, mainType) {\r\n      if (componentOption == null) {\r\n        return;\r\n      }\r\n\r\n      if (!ComponentModel.hasClass(mainType)) {\r\n        // globalSettingTask.dirty();\r\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\r\n      } else if (mainType) {\r\n        newCmptTypes.push(mainType);\r\n        newCmptTypeMap.set(mainType, true);\r\n      }\r\n    });\r\n\r\n    if (replaceMergeMainTypeMap) {\r\n      // If there is a mainType `xxx` in `replaceMerge` but not declared in option,\r\n      // we trade it as it is declared in option as `{xxx: []}`. Because:\r\n      // (1) for normal merge, `{xxx: null/undefined}` are the same meaning as `{xxx: []}`.\r\n      // (2) some preprocessor may convert some of `{xxx: null/undefined}` to `{xxx: []}`.\r\n      replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {\r\n        if (ComponentModel.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {\r\n          newCmptTypes.push(mainTypeInReplaceMerge);\r\n          newCmptTypeMap.set(mainTypeInReplaceMerge, true);\r\n        }\r\n      });\r\n    }\r\n\r\n    ComponentModel.topologicalTravel(newCmptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\r\n\r\n    function visitComponent(mainType) {\r\n      var newCmptOptionList = concatInternalOptions(this, mainType, modelUtil.normalizeToArray(newOption[mainType]));\r\n      var oldCmptList = componentsMap.get(mainType);\r\n      var mergeMode = // `!oldCmptList` means init. See the comment in `mappingToExists`\r\n      !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge';\r\n      var mappingResult = modelUtil.mappingToExists(oldCmptList, newCmptOptionList, mergeMode); // Set mainType and complete subType.\r\n\r\n      modelUtil.setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel); // Empty it before the travel, in order to prevent `this._componentsMap`\r\n      // from being used in the `init`/`mergeOption`/`optionUpdated` of some\r\n      // components, which is probably incorrect logic.\r\n\r\n      option[mainType] = null;\r\n      componentsMap.set(mainType, null);\r\n      componentsCount.set(mainType, 0);\r\n      var optionsByMainType = [];\r\n      var cmptsByMainType = [];\r\n      var cmptsCountByMainType = 0;\r\n      var tooltipExists;\r\n      var tooltipWarningLogged;\r\n      each(mappingResult, function (resultItem, index) {\r\n        var componentModel = resultItem.existing;\r\n        var newCmptOption = resultItem.newOption;\r\n\r\n        if (!newCmptOption) {\r\n          if (componentModel) {\r\n            // Consider where is no new option and should be merged using {},\r\n            // see removeEdgeAndAdd in topologicalTravel and\r\n            // ComponentModel.getAllClassMainTypes.\r\n            componentModel.mergeOption({}, this);\r\n            componentModel.optionUpdated({}, false);\r\n          } // If no both `resultItem.exist` and `resultItem.option`,\r\n          // either it is in `replaceMerge` and not matched by any id,\r\n          // or it has been removed in previous `replaceMerge` and left a \"hole\" in this component index.\r\n\r\n        } else {\r\n          var isSeriesType = mainType === 'series';\r\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType // Give a more detailed warn later if series don't exists\r\n          );\r\n\r\n          if (!ComponentModelClass) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n              var subType = resultItem.keyInfo.subType;\r\n              var seriesImportName = BUILTIN_CHARTS_MAP[subType];\r\n\r\n              if (!componetsMissingLogPrinted[subType]) {\r\n                componetsMissingLogPrinted[subType] = true;\r\n\r\n                if (seriesImportName) {\r\n                  error(\"Series \" + subType + \" is used but not imported.\\nimport { \" + seriesImportName + \" } from 'echarts/charts';\\necharts.use([\" + seriesImportName + \"]);\");\r\n                } else {\r\n                  error(\"Unkown series \" + subType);\r\n                }\r\n              }\r\n            }\r\n\r\n            return;\r\n          } // TODO Before multiple tooltips get supported, we do this check to avoid unexpected exception.\r\n\r\n\r\n          if (mainType === 'tooltip') {\r\n            if (tooltipExists) {\r\n              if (process.env.NODE_ENV !== 'production') {\r\n                if (!tooltipWarningLogged) {\r\n                  warn('Currently only one tooltip component is allowed.');\r\n                  tooltipWarningLogged = true;\r\n                }\r\n              }\r\n\r\n              return;\r\n            }\r\n\r\n            tooltipExists = true;\r\n          }\r\n\r\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\r\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\r\n\r\n            componentModel.mergeOption(newCmptOption, this);\r\n            componentModel.optionUpdated(newCmptOption, false);\r\n          } else {\r\n            // PENDING Global as parent ?\r\n            var extraOpt = extend({\r\n              componentIndex: index\r\n            }, resultItem.keyInfo);\r\n            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt); // Assign `keyInfo`\r\n\r\n            extend(componentModel, extraOpt);\r\n\r\n            if (resultItem.brandNew) {\r\n              componentModel.__requireNewView = true;\r\n            }\r\n\r\n            componentModel.init(newCmptOption, this, this); // Call optionUpdated after init.\r\n            // newCmptOption has been used as componentModel.option\r\n            // and may be merged with theme and default, so pass null\r\n            // to avoid confusion.\r\n\r\n            componentModel.optionUpdated(null, true);\r\n          }\r\n        }\r\n\r\n        if (componentModel) {\r\n          optionsByMainType.push(componentModel.option);\r\n          cmptsByMainType.push(componentModel);\r\n          cmptsCountByMainType++;\r\n        } else {\r\n          // Always do assign to avoid elided item in array.\r\n          optionsByMainType.push(void 0);\r\n          cmptsByMainType.push(void 0);\r\n        }\r\n      }, this);\r\n      option[mainType] = optionsByMainType;\r\n      componentsMap.set(mainType, cmptsByMainType);\r\n      componentsCount.set(mainType, cmptsCountByMainType); // Backup series for filtering.\r\n\r\n      if (mainType === 'series') {\r\n        reCreateSeriesIndices(this);\r\n      }\r\n    } // If no series declared, ensure `_seriesIndices` initialized.\r\n\r\n\r\n    if (!this._seriesIndices) {\r\n      reCreateSeriesIndices(this);\r\n    }\r\n  };\r\n  /**\r\n   * Get option for output (cloned option and inner info removed)\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.getOption = function () {\r\n    var option = clone(this.option);\r\n    each(option, function (optInMainType, mainType) {\r\n      if (ComponentModel.hasClass(mainType)) {\r\n        var opts = modelUtil.normalizeToArray(optInMainType); // Inner cmpts need to be removed.\r\n        // Inner cmpts might not be at last since ec5.0, but still\r\n        // compatible for users: if inner cmpt at last, splice the returned array.\r\n\r\n        var realLen = opts.length;\r\n        var metNonInner = false;\r\n\r\n        for (var i = realLen - 1; i >= 0; i--) {\r\n          // Remove options with inner id.\r\n          if (opts[i] && !modelUtil.isComponentIdInternal(opts[i])) {\r\n            metNonInner = true;\r\n          } else {\r\n            opts[i] = null;\r\n            !metNonInner && realLen--;\r\n          }\r\n        }\r\n\r\n        opts.length = realLen;\r\n        option[mainType] = opts;\r\n      }\r\n    });\r\n    delete option[OPTION_INNER_KEY];\r\n    return option;\r\n  };\r\n\r\n  GlobalModel.prototype.getTheme = function () {\r\n    return this._theme;\r\n  };\r\n\r\n  GlobalModel.prototype.getLocaleModel = function () {\r\n    return this._locale;\r\n  };\r\n\r\n  GlobalModel.prototype.setUpdatePayload = function (payload) {\r\n    this._payload = payload;\r\n  };\r\n\r\n  GlobalModel.prototype.getUpdatePayload = function () {\r\n    return this._payload;\r\n  };\r\n  /**\r\n   * @param idx If not specified, return the first one.\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.getComponent = function (mainType, idx) {\r\n    var list = this._componentsMap.get(mainType);\r\n\r\n    if (list) {\r\n      var cmpt = list[idx || 0];\r\n\r\n      if (cmpt) {\r\n        return cmpt;\r\n      } else if (idx == null) {\r\n        for (var i = 0; i < list.length; i++) {\r\n          if (list[i]) {\r\n            return list[i];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * @return Never be null/undefined.\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.queryComponents = function (condition) {\r\n    var mainType = condition.mainType;\r\n\r\n    if (!mainType) {\r\n      return [];\r\n    }\r\n\r\n    var index = condition.index;\r\n    var id = condition.id;\r\n    var name = condition.name;\r\n\r\n    var cmpts = this._componentsMap.get(mainType);\r\n\r\n    if (!cmpts || !cmpts.length) {\r\n      return [];\r\n    }\r\n\r\n    var result;\r\n\r\n    if (index != null) {\r\n      result = [];\r\n      each(modelUtil.normalizeToArray(index), function (idx) {\r\n        cmpts[idx] && result.push(cmpts[idx]);\r\n      });\r\n    } else if (id != null) {\r\n      result = queryByIdOrName('id', id, cmpts);\r\n    } else if (name != null) {\r\n      result = queryByIdOrName('name', name, cmpts);\r\n    } else {\r\n      // Return all non-empty components in that mainType\r\n      result = filter(cmpts, function (cmpt) {\r\n        return !!cmpt;\r\n      });\r\n    }\r\n\r\n    return filterBySubType(result, condition);\r\n  };\r\n  /**\r\n   * The interface is different from queryComponents,\r\n   * which is convenient for inner usage.\r\n   *\r\n   * @usage\r\n   * let result = findComponents(\r\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\r\n   * );\r\n   * let result = findComponents(\r\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\r\n   * );\r\n   * let result = findComponents(\r\n   *     {mainType: 'series',\r\n   *     filter: function (model, index) {...}}\r\n   * );\r\n   * // result like [component0, componnet1, ...]\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.findComponents = function (condition) {\r\n    var query = condition.query;\r\n    var mainType = condition.mainType;\r\n    var queryCond = getQueryCond(query);\r\n    var result = queryCond ? this.queryComponents(queryCond) // Retrieve all non-empty components.\r\n    : filter(this._componentsMap.get(mainType), function (cmpt) {\r\n      return !!cmpt;\r\n    });\r\n    return doFilter(filterBySubType(result, condition));\r\n\r\n    function getQueryCond(q) {\r\n      var indexAttr = mainType + 'Index';\r\n      var idAttr = mainType + 'Id';\r\n      var nameAttr = mainType + 'Name';\r\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\r\n        mainType: mainType,\r\n        // subType will be filtered finally.\r\n        index: q[indexAttr],\r\n        id: q[idAttr],\r\n        name: q[nameAttr]\r\n      } : null;\r\n    }\r\n\r\n    function doFilter(res) {\r\n      return condition.filter ? filter(res, condition.filter) : res;\r\n    }\r\n  };\r\n\r\n  GlobalModel.prototype.eachComponent = function (mainType, cb, context) {\r\n    var componentsMap = this._componentsMap;\r\n\r\n    if (isFunction(mainType)) {\r\n      var ctxForAll_1 = cb;\r\n      var cbForAll_1 = mainType;\r\n      componentsMap.each(function (cmpts, componentType) {\r\n        for (var i = 0; cmpts && i < cmpts.length; i++) {\r\n          var cmpt = cmpts[i];\r\n          cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex);\r\n        }\r\n      });\r\n    } else {\r\n      var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null;\r\n\r\n      for (var i = 0; cmpts && i < cmpts.length; i++) {\r\n        var cmpt = cmpts[i];\r\n        cmpt && cb.call(context, cmpt, cmpt.componentIndex);\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Get series list before filtered by name.\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.getSeriesByName = function (name) {\r\n    var nameStr = modelUtil.convertOptionIdName(name, null);\r\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\r\n      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;\r\n    });\r\n  };\r\n  /**\r\n   * Get series list before filtered by index.\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {\r\n    return this._componentsMap.get('series')[seriesIndex];\r\n  };\r\n  /**\r\n   * Get series list before filtered by type.\r\n   * FIXME: rename to getRawSeriesByType?\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.getSeriesByType = function (subType) {\r\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\r\n      return !!oneSeries && oneSeries.subType === subType;\r\n    });\r\n  };\r\n  /**\r\n   * Get all series before filtered.\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.getSeries = function () {\r\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\r\n      return !!oneSeries;\r\n    });\r\n  };\r\n  /**\r\n   * Count series before filtered.\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.getSeriesCount = function () {\r\n    return this._componentsCount.get('series');\r\n  };\r\n  /**\r\n   * After filtering, series may be different\r\n   * frome raw series.\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.eachSeries = function (cb, context) {\r\n    assertSeriesInitialized(this);\r\n    each(this._seriesIndices, function (rawSeriesIndex) {\r\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\r\n\r\n      cb.call(context, series, rawSeriesIndex);\r\n    }, this);\r\n  };\r\n  /**\r\n   * Iterate raw series before filtered.\r\n   *\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.eachRawSeries = function (cb, context) {\r\n    each(this._componentsMap.get('series'), function (series) {\r\n      series && cb.call(context, series, series.componentIndex);\r\n    });\r\n  };\r\n  /**\r\n   * After filtering, series may be different.\r\n   * frome raw series.\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {\r\n    assertSeriesInitialized(this);\r\n    each(this._seriesIndices, function (rawSeriesIndex) {\r\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\r\n\r\n      if (series.subType === subType) {\r\n        cb.call(context, series, rawSeriesIndex);\r\n      }\r\n    }, this);\r\n  };\r\n  /**\r\n   * Iterate raw series before filtered of given type.\r\n   */\r\n\r\n\r\n  GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {\r\n    return each(this.getSeriesByType(subType), cb, context);\r\n  };\r\n\r\n  GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {\r\n    assertSeriesInitialized(this);\r\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\r\n  };\r\n\r\n  GlobalModel.prototype.getCurrentSeriesIndices = function () {\r\n    return (this._seriesIndices || []).slice();\r\n  };\r\n\r\n  GlobalModel.prototype.filterSeries = function (cb, context) {\r\n    assertSeriesInitialized(this);\r\n    var newSeriesIndices = [];\r\n    each(this._seriesIndices, function (seriesRawIdx) {\r\n      var series = this._componentsMap.get('series')[seriesRawIdx];\r\n\r\n      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);\r\n    }, this);\r\n    this._seriesIndices = newSeriesIndices;\r\n    this._seriesIndicesMap = createHashMap(newSeriesIndices);\r\n  };\r\n\r\n  GlobalModel.prototype.restoreData = function (payload) {\r\n    reCreateSeriesIndices(this);\r\n    var componentsMap = this._componentsMap;\r\n    var componentTypes = [];\r\n    componentsMap.each(function (components, componentType) {\r\n      if (ComponentModel.hasClass(componentType)) {\r\n        componentTypes.push(componentType);\r\n      }\r\n    });\r\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType) {\r\n      each(componentsMap.get(componentType), function (component) {\r\n        if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {\r\n          component.restoreData();\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  GlobalModel.internalField = function () {\r\n    reCreateSeriesIndices = function (ecModel) {\r\n      var seriesIndices = ecModel._seriesIndices = [];\r\n      each(ecModel._componentsMap.get('series'), function (series) {\r\n        // series may have been removed by `replaceMerge`.\r\n        series && seriesIndices.push(series.componentIndex);\r\n      });\r\n      ecModel._seriesIndicesMap = createHashMap(seriesIndices);\r\n    };\r\n\r\n    assertSeriesInitialized = function (ecModel) {\r\n      // Components that use _seriesIndices should depends on series component,\r\n      // which make sure that their initialization is after series.\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (!ecModel._seriesIndices) {\r\n          throw new Error('Option should contains series.');\r\n        }\r\n      }\r\n    };\r\n\r\n    initBase = function (ecModel, baseOption) {\r\n      // Using OPTION_INNER_KEY to mark that this option can not be used outside,\r\n      // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\r\n      ecModel.option = {};\r\n      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE; // Init with series: [], in case of calling findSeries method\r\n      // before series initialized.\r\n\r\n      ecModel._componentsMap = createHashMap({\r\n        series: []\r\n      });\r\n      ecModel._componentsCount = createHashMap(); // If user spefied `option.aria`, aria will be enable. This detection should be\r\n      // performed before theme and globalDefault merge.\r\n\r\n      var airaOption = baseOption.aria;\r\n\r\n      if (isObject(airaOption) && airaOption.enabled == null) {\r\n        airaOption.enabled = true;\r\n      }\r\n\r\n      mergeTheme(baseOption, ecModel._theme.option); // TODO Needs clone when merging to the unexisted property\r\n\r\n      merge(baseOption, globalDefault, false);\r\n\r\n      ecModel._mergeOption(baseOption, null);\r\n    };\r\n  }();\r\n\r\n  return GlobalModel;\r\n}(Model);\r\n\r\nfunction isNotTargetSeries(seriesModel, payload) {\r\n  if (payload) {\r\n    var index = payload.seriesIndex;\r\n    var id = payload.seriesId;\r\n    var name_1 = payload.seriesName;\r\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;\r\n  }\r\n}\r\n\r\nfunction mergeTheme(option, theme) {\r\n  // PENDING\r\n  // NOT use `colorLayer` in theme if option has `color`\r\n  var notMergeColorLayer = option.color && !option.colorLayer;\r\n  each(theme, function (themeItem, name) {\r\n    if (name === 'colorLayer' && notMergeColorLayer) {\r\n      return;\r\n    } // If it is component model mainType, the model handles that merge later.\r\n    // otherwise, merge them here.\r\n\r\n\r\n    if (!ComponentModel.hasClass(name)) {\r\n      if (typeof themeItem === 'object') {\r\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\r\n      } else {\r\n        if (option[name] == null) {\r\n          option[name] = themeItem;\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction queryByIdOrName(attr, idOrName, cmpts) {\r\n  // Here is a break from echarts4: string and number are\r\n  // treated as equal.\r\n  if (isArray(idOrName)) {\r\n    var keyMap_1 = createHashMap();\r\n    each(idOrName, function (idOrNameItem) {\r\n      if (idOrNameItem != null) {\r\n        var idName = modelUtil.convertOptionIdName(idOrNameItem, null);\r\n        idName != null && keyMap_1.set(idOrNameItem, true);\r\n      }\r\n    });\r\n    return filter(cmpts, function (cmpt) {\r\n      return cmpt && keyMap_1.get(cmpt[attr]);\r\n    });\r\n  } else {\r\n    var idName_1 = modelUtil.convertOptionIdName(idOrName, null);\r\n    return filter(cmpts, function (cmpt) {\r\n      return cmpt && idName_1 != null && cmpt[attr] === idName_1;\r\n    });\r\n  }\r\n}\r\n\r\nfunction filterBySubType(components, condition) {\r\n  // Using hasOwnProperty for restrict. Consider\r\n  // subType is undefined in user payload.\r\n  return condition.hasOwnProperty('subType') ? filter(components, function (cmpt) {\r\n    return cmpt && cmpt.subType === condition.subType;\r\n  }) : components;\r\n}\r\n\r\nfunction normalizeSetOptionInput(opts) {\r\n  var replaceMergeMainTypeMap = createHashMap();\r\n  opts && each(modelUtil.normalizeToArray(opts.replaceMerge), function (mainType) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assert(ComponentModel.hasClass(mainType), '\"' + mainType + '\" is not valid component main type in \"replaceMerge\"');\r\n    }\r\n\r\n    replaceMergeMainTypeMap.set(mainType, true);\r\n  });\r\n  return {\r\n    replaceMergeMainTypeMap: replaceMergeMainTypeMap\r\n  };\r\n}\r\n\r\nmixin(GlobalModel, PaletteMixin);\r\nexport default GlobalModel;"],"mappings":"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"},"metadata":{},"sourceType":"module"}