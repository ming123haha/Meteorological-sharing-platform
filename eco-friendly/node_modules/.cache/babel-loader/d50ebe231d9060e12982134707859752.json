{"ast":null,"code":"import Point from './Point.js';\nvar extent = [0, 0];\nvar extent2 = [0, 0];\nvar minTv = new Point();\nvar maxTv = new Point();\n\nvar OrientedBoundingRect = function () {\n  function OrientedBoundingRect(rect, transform) {\n    this._corners = [];\n    this._axes = [];\n    this._origin = [0, 0];\n\n    for (var i = 0; i < 4; i++) {\n      this._corners[i] = new Point();\n    }\n\n    for (var i = 0; i < 2; i++) {\n      this._axes[i] = new Point();\n    }\n\n    if (rect) {\n      this.fromBoundingRect(rect, transform);\n    }\n  }\n\n  OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {\n    var corners = this._corners;\n    var axes = this._axes;\n    var x = rect.x;\n    var y = rect.y;\n    var x2 = x + rect.width;\n    var y2 = y + rect.height;\n    corners[0].set(x, y);\n    corners[1].set(x2, y);\n    corners[2].set(x2, y2);\n    corners[3].set(x, y2);\n\n    if (transform) {\n      for (var i = 0; i < 4; i++) {\n        corners[i].transform(transform);\n      }\n    }\n\n    Point.sub(axes[0], corners[1], corners[0]);\n    Point.sub(axes[1], corners[3], corners[0]);\n    axes[0].normalize();\n    axes[1].normalize();\n\n    for (var i = 0; i < 2; i++) {\n      this._origin[i] = axes[i].dot(corners[0]);\n    }\n  };\n\n  OrientedBoundingRect.prototype.intersect = function (other, mtv) {\n    var overlapped = true;\n    var noMtv = !mtv;\n    minTv.set(Infinity, Infinity);\n    maxTv.set(0, 0);\n\n    if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {\n      overlapped = false;\n\n      if (noMtv) {\n        return overlapped;\n      }\n    }\n\n    if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {\n      overlapped = false;\n\n      if (noMtv) {\n        return overlapped;\n      }\n    }\n\n    if (!noMtv) {\n      Point.copy(mtv, overlapped ? minTv : maxTv);\n    }\n\n    return overlapped;\n  };\n\n  OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, minTv, maxTv, noMtv, inverse) {\n    var overlapped = true;\n\n    for (var i = 0; i < 2; i++) {\n      var axis = this._axes[i];\n\n      this._getProjMinMaxOnAxis(i, self._corners, extent);\n\n      this._getProjMinMaxOnAxis(i, other._corners, extent2);\n\n      if (extent[1] < extent2[0] || extent[0] > extent2[1]) {\n        overlapped = false;\n\n        if (noMtv) {\n          return overlapped;\n        }\n\n        var dist0 = Math.abs(extent2[0] - extent[1]);\n        var dist1 = Math.abs(extent[0] - extent2[1]);\n\n        if (Math.min(dist0, dist1) > maxTv.len()) {\n          if (dist0 < dist1) {\n            Point.scale(maxTv, axis, -dist0 * inverse);\n          } else {\n            Point.scale(maxTv, axis, dist1 * inverse);\n          }\n        }\n      } else if (minTv) {\n        var dist0 = Math.abs(extent2[0] - extent[1]);\n        var dist1 = Math.abs(extent[0] - extent2[1]);\n\n        if (Math.min(dist0, dist1) < minTv.len()) {\n          if (dist0 < dist1) {\n            Point.scale(minTv, axis, dist0 * inverse);\n          } else {\n            Point.scale(minTv, axis, -dist1 * inverse);\n          }\n        }\n      }\n    }\n\n    return overlapped;\n  };\n\n  OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {\n    var axis = this._axes[dim];\n    var origin = this._origin;\n    var proj = corners[0].dot(axis) + origin[dim];\n    var min = proj;\n    var max = proj;\n\n    for (var i = 1; i < corners.length; i++) {\n      var proj_1 = corners[i].dot(axis) + origin[dim];\n      min = Math.min(proj_1, min);\n      max = Math.max(proj_1, max);\n    }\n\n    out[0] = min;\n    out[1] = max;\n  };\n\n  return OrientedBoundingRect;\n}();\n\nexport default OrientedBoundingRect;","map":{"version":3,"names":["Point","extent","extent2","minTv","maxTv","OrientedBoundingRect","rect","transform","_corners","_axes","_origin","i","fromBoundingRect","prototype","corners","axes","x","y","x2","width","y2","height","set","sub","normalize","dot","intersect","other","mtv","overlapped","noMtv","Infinity","_intersectCheckOneSide","copy","self","inverse","axis","_getProjMinMaxOnAxis","dist0","Math","abs","dist1","min","len","scale","dim","out","origin","proj","max","length","proj_1"],"sources":["E:/各个学科/论文/毕业论文/Atmosphere/eco-friendly/node_modules/zrender/lib/core/OrientedBoundingRect.js"],"sourcesContent":["import Point from './Point.js';\r\nvar extent = [0, 0];\r\nvar extent2 = [0, 0];\r\nvar minTv = new Point();\r\nvar maxTv = new Point();\r\nvar OrientedBoundingRect = (function () {\r\n    function OrientedBoundingRect(rect, transform) {\r\n        this._corners = [];\r\n        this._axes = [];\r\n        this._origin = [0, 0];\r\n        for (var i = 0; i < 4; i++) {\r\n            this._corners[i] = new Point();\r\n        }\r\n        for (var i = 0; i < 2; i++) {\r\n            this._axes[i] = new Point();\r\n        }\r\n        if (rect) {\r\n            this.fromBoundingRect(rect, transform);\r\n        }\r\n    }\r\n    OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {\r\n        var corners = this._corners;\r\n        var axes = this._axes;\r\n        var x = rect.x;\r\n        var y = rect.y;\r\n        var x2 = x + rect.width;\r\n        var y2 = y + rect.height;\r\n        corners[0].set(x, y);\r\n        corners[1].set(x2, y);\r\n        corners[2].set(x2, y2);\r\n        corners[3].set(x, y2);\r\n        if (transform) {\r\n            for (var i = 0; i < 4; i++) {\r\n                corners[i].transform(transform);\r\n            }\r\n        }\r\n        Point.sub(axes[0], corners[1], corners[0]);\r\n        Point.sub(axes[1], corners[3], corners[0]);\r\n        axes[0].normalize();\r\n        axes[1].normalize();\r\n        for (var i = 0; i < 2; i++) {\r\n            this._origin[i] = axes[i].dot(corners[0]);\r\n        }\r\n    };\r\n    OrientedBoundingRect.prototype.intersect = function (other, mtv) {\r\n        var overlapped = true;\r\n        var noMtv = !mtv;\r\n        minTv.set(Infinity, Infinity);\r\n        maxTv.set(0, 0);\r\n        if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {\r\n            overlapped = false;\r\n            if (noMtv) {\r\n                return overlapped;\r\n            }\r\n        }\r\n        if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {\r\n            overlapped = false;\r\n            if (noMtv) {\r\n                return overlapped;\r\n            }\r\n        }\r\n        if (!noMtv) {\r\n            Point.copy(mtv, overlapped ? minTv : maxTv);\r\n        }\r\n        return overlapped;\r\n    };\r\n    OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, minTv, maxTv, noMtv, inverse) {\r\n        var overlapped = true;\r\n        for (var i = 0; i < 2; i++) {\r\n            var axis = this._axes[i];\r\n            this._getProjMinMaxOnAxis(i, self._corners, extent);\r\n            this._getProjMinMaxOnAxis(i, other._corners, extent2);\r\n            if (extent[1] < extent2[0] || extent[0] > extent2[1]) {\r\n                overlapped = false;\r\n                if (noMtv) {\r\n                    return overlapped;\r\n                }\r\n                var dist0 = Math.abs(extent2[0] - extent[1]);\r\n                var dist1 = Math.abs(extent[0] - extent2[1]);\r\n                if (Math.min(dist0, dist1) > maxTv.len()) {\r\n                    if (dist0 < dist1) {\r\n                        Point.scale(maxTv, axis, -dist0 * inverse);\r\n                    }\r\n                    else {\r\n                        Point.scale(maxTv, axis, dist1 * inverse);\r\n                    }\r\n                }\r\n            }\r\n            else if (minTv) {\r\n                var dist0 = Math.abs(extent2[0] - extent[1]);\r\n                var dist1 = Math.abs(extent[0] - extent2[1]);\r\n                if (Math.min(dist0, dist1) < minTv.len()) {\r\n                    if (dist0 < dist1) {\r\n                        Point.scale(minTv, axis, dist0 * inverse);\r\n                    }\r\n                    else {\r\n                        Point.scale(minTv, axis, -dist1 * inverse);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return overlapped;\r\n    };\r\n    OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {\r\n        var axis = this._axes[dim];\r\n        var origin = this._origin;\r\n        var proj = corners[0].dot(axis) + origin[dim];\r\n        var min = proj;\r\n        var max = proj;\r\n        for (var i = 1; i < corners.length; i++) {\r\n            var proj_1 = corners[i].dot(axis) + origin[dim];\r\n            min = Math.min(proj_1, min);\r\n            max = Math.max(proj_1, max);\r\n        }\r\n        out[0] = min;\r\n        out[1] = max;\r\n    };\r\n    return OrientedBoundingRect;\r\n}());\r\nexport default OrientedBoundingRect;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}