{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { MARKER_TEXTURE_SIZE as e, MARKER_THICKNESS as r } from \"../views/3d/layers/support/markerUtils.js\";\nimport { ShaderOutput as o } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js\";\nimport { SliceDraw as i } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { RibbonVertexPosition as t } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";\nimport { OutputDepth as a } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { multipassTerrainTest as s } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { symbolAlphaCutoff as n } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { ColorConversion as l } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { RgbaFloatEncoding as c } from \"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";\nimport { addProjViewLocalOrigin as p } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float2PassUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as f } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as h } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as u } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nimport { TransparencyPassType as w } from \"../views/3d/webgl-engine/lib/basicInterfaces.js\";\nimport { VertexAttribute as y } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\n\nfunction b(b) {\n  const x = new h(),\n        P = b.hasMultipassTerrain && (b.output === o.Color || b.output === o.Alpha);\n  x.include(t, b), b.output === o.Depth && x.include(a, b);\n  const {\n    vertex: S,\n    fragment: j\n  } = x;\n  return j.include(c), p(x, b), x.attributes.add(y.POSITION, \"vec3\"), x.attributes.add(y.UV0, \"vec2\"), x.attributes.add(y.AUXPOS1, \"vec3\"), x.varyings.add(\"vColor\", \"vec4\"), x.varyings.add(\"vpos\", \"vec3\"), x.varyings.add(\"vUV\", \"vec2\"), x.varyings.add(\"vSize\", \"float\"), x.varyings.add(\"linearDepth\", \"float\"), P && x.varyings.add(\"depth\", \"float\"), S.code.add(f`#define PERPENDICULAR(v) vec2(v.y, -v.x)\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}`), S.uniforms.add([new d(\"nearFar\", (e, r) => r.camera.nearFar), new v(\"viewport\", (e, r) => r.camera.fullViewport)]), S.code.add(f`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`), S.code.add(f`void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nprev = mix(pos, prev, interp(vnp, pos, prev));\n}\n}`), b.draped || (S.uniforms.add(new m(\"inverseProjectionMatrix\", (e, r) => r.camera.inverseProjectionMatrix)), S.code.add(f`vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}`), S.code.add(f`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}`), S.uniforms.add(new g(\"perScreenPixelRatio\", (e, r) => r.camera.perScreenPixelRatio)), S.code.add(f`\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ${b.hasCap ? \"\\n                if(prev.z > posLeft.z) {\\n                  vec2 diff = posLeft.xy - posRight.xy;\\n                  planeOrigin.xy += PERPENDICULAR(diff) / 2.0;\\n                }\\n              \" : \"\"};\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  `)), S.uniforms.add(new g(\"pixelRatio\", (e, r) => r.camera.pixelRatio)), S.code.add(f`\n    void main(void) {\n      float coverage = 1.0;\n\n      // Check for special value of uv0.y which is used by the Renderer when graphics\n      // are removed before the VBO is recompacted. If this is the case, then we just\n      // project outside of clip space.\n      if (uv0.y == 0.0) {\n        // Project out of clip space\n        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      }\n      else {\n        float lineSize = getSize();\n        float lineWidth = max(lineSize, 1.0) * pixelRatio;\n\n        vec4 pos  = view * vec4(position.xyz, 1.0);\n        vec4 prev = view * vec4(auxpos1.xyz, 1.0);\n        clip(pos, prev);\n\n        vec4 posScreen = projectAndScale(pos);\n        vec4 prevScreen = projectAndScale(prev);\n\n        vec2 segment = posScreen.xy - prevScreen.xy;\n\n        // normalize vector along line segment\n        float segmentLen = length(segment);\n        segment = (segmentLen > 0.001) ? segment / segmentLen : vec2(0.0, 0.0);\n\n        // displace according to position in the texture\n        vec2 displacementDirU = PERPENDICULAR(segment);\n        vec2 displacementDirV = segment;\n\n        float displacementLen = ${f.float(e / r)} * lineWidth;\n\n        vec4 displacedPosScreen = posScreen;\n        displacedPosScreen.xy += uv0.x * displacementDirU * displacementLen + uv0.y * displacementDirV * displacementLen;\n  `), b.draped || S.code.add(f`vec3 posRight = inverseProject(posScreen + vec4(displacementDirU.xy, 0.0, 0.0) * lineWidth);\nvec3 posLeft = pos.xyz + (pos.xyz - posRight);\npos = toFront(displacedPosScreen, posLeft, posRight, prev.xyz, lineWidth);\ndisplacedPosScreen = projectAndScale(pos);`), S.code.add(f`\n        ${P ? \"depth = pos.z;\" : \"\"}\n        linearDepth = (-pos.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\n\n        // Convert back into NDC\n        displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n        // Convert texture coordinate into [0,1] and cancel out perspective correct interpolation\n        vUV = (uv0 + 1.0) / 2.0;\n        vUV *= displacedPosScreen.w;\n\n        vSize = displacementLen;\n\n        vColor = getColor();\n        vColor.a *= coverage;\n\n        // Use camera space for slicing\n        vpos = pos.xyz;\n\n        gl_Position = displacedPosScreen;\n      }\n    }\n  `), P && x.include(s, b), x.include(i, b), j.uniforms.add([new v(\"intrinsicColor\", e => e.color), new u(\"tex\", e => e.texture)]), j.include(l), j.code.add(f`\n  void main() {\n    discardBySlice(vpos);\n    ${P ? \"terrainDepthTest(gl_FragCoord, depth);\" : \"\"}\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    // Offset texture coordinate s.t. we sample texel centers\n    float texelSize = ${f.float(1 / e)};\n    vec2 samplePos = vUV * gl_FragCoord.w + vec2(0.5, -0.5) * texelSize;\n\n    // Evaluate sdf\n    float sdf = rgba2float(texture2D(tex, samplePos)) - 0.5;\n    float distance = sdf * vSize;\n\n    // Grow by a halfpixel to make sure the line is fully covered by the cross marker\n    // (otherwise there will be a halo if they are different colours)\n    distance -= 0.5;\n\n    finalColor.a *= clamp(0.5 - distance, 0.0, 1.0);\n\n    if (finalColor.a < ${f.float(n)}) {\n      discard;\n    }\n\n    ${b.output === o.Alpha ? f`gl_FragColor = vec4(finalColor.a);` : \"\"}\n    ${b.output === o.Color ? f`gl_FragColor = highlightSlice(finalColor, vpos);` : \"\"}\n    ${b.output === o.Color && b.transparencyPassType === w.Color ? \"gl_FragColor = premultiplyAlpha(gl_FragColor);\" : \"\"}\n    ${b.output === o.Highlight ? f`gl_FragColor = vec4(1.0);` : \"\"}\n    ${b.output === o.Depth ? f`outputDepth(linearDepth);` : \"\"}\n  }\n  `), x;\n}\n\nconst x = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: b\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { x as L, b };","map":{"version":3,"names":["MARKER_TEXTURE_SIZE","e","MARKER_THICKNESS","r","ShaderOutput","o","SliceDraw","i","RibbonVertexPosition","t","OutputDepth","a","multipassTerrainTest","s","symbolAlphaCutoff","n","ColorConversion","l","RgbaFloatEncoding","c","addProjViewLocalOrigin","p","Float2PassUniform","d","Float4PassUniform","v","FloatPassUniform","g","glsl","f","Matrix4PassUniform","m","ShaderBuilder","h","Texture2DPassUniform","u","TransparencyPassType","w","VertexAttribute","y","b","x","P","hasMultipassTerrain","output","Color","Alpha","include","Depth","vertex","S","fragment","j","attributes","add","POSITION","UV0","AUXPOS1","varyings","code","uniforms","camera","nearFar","fullViewport","draped","inverseProjectionMatrix","perScreenPixelRatio","hasCap","pixelRatio","float","color","texture","transparencyPassType","Highlight","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","L"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/chunks/LineMarker.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{MARKER_TEXTURE_SIZE as e,MARKER_THICKNESS as r}from\"../views/3d/layers/support/markerUtils.js\";import{ShaderOutput as o}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js\";import{SliceDraw as i}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{RibbonVertexPosition as t}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";import{OutputDepth as a}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{multipassTerrainTest as s}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{symbolAlphaCutoff as n}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";import{ColorConversion as l}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{RgbaFloatEncoding as c}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{addProjViewLocalOrigin as p}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float2PassUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as f}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as h}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{TransparencyPassType as w}from\"../views/3d/webgl-engine/lib/basicInterfaces.js\";import{VertexAttribute as y}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function b(b){const x=new h,P=b.hasMultipassTerrain&&(b.output===o.Color||b.output===o.Alpha);x.include(t,b),b.output===o.Depth&&x.include(a,b);const{vertex:S,fragment:j}=x;return j.include(c),p(x,b),x.attributes.add(y.POSITION,\"vec3\"),x.attributes.add(y.UV0,\"vec2\"),x.attributes.add(y.AUXPOS1,\"vec3\"),x.varyings.add(\"vColor\",\"vec4\"),x.varyings.add(\"vpos\",\"vec3\"),x.varyings.add(\"vUV\",\"vec2\"),x.varyings.add(\"vSize\",\"float\"),x.varyings.add(\"linearDepth\",\"float\"),P&&x.varyings.add(\"depth\",\"float\"),S.code.add(f`#define PERPENDICULAR(v) vec2(v.y, -v.x)\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}`),S.uniforms.add([new d(\"nearFar\",((e,r)=>r.camera.nearFar)),new v(\"viewport\",((e,r)=>r.camera.fullViewport))]),S.code.add(f`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`),S.code.add(f`void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nprev = mix(pos, prev, interp(vnp, pos, prev));\n}\n}`),b.draped||(S.uniforms.add(new m(\"inverseProjectionMatrix\",((e,r)=>r.camera.inverseProjectionMatrix))),S.code.add(f`vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}`),S.code.add(f`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}`),S.uniforms.add(new g(\"perScreenPixelRatio\",((e,r)=>r.camera.perScreenPixelRatio))),S.code.add(f`\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ${b.hasCap?\"\\n                if(prev.z > posLeft.z) {\\n                  vec2 diff = posLeft.xy - posRight.xy;\\n                  planeOrigin.xy += PERPENDICULAR(diff) / 2.0;\\n                }\\n              \":\"\"};\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  `)),S.uniforms.add(new g(\"pixelRatio\",((e,r)=>r.camera.pixelRatio))),S.code.add(f`\n    void main(void) {\n      float coverage = 1.0;\n\n      // Check for special value of uv0.y which is used by the Renderer when graphics\n      // are removed before the VBO is recompacted. If this is the case, then we just\n      // project outside of clip space.\n      if (uv0.y == 0.0) {\n        // Project out of clip space\n        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      }\n      else {\n        float lineSize = getSize();\n        float lineWidth = max(lineSize, 1.0) * pixelRatio;\n\n        vec4 pos  = view * vec4(position.xyz, 1.0);\n        vec4 prev = view * vec4(auxpos1.xyz, 1.0);\n        clip(pos, prev);\n\n        vec4 posScreen = projectAndScale(pos);\n        vec4 prevScreen = projectAndScale(prev);\n\n        vec2 segment = posScreen.xy - prevScreen.xy;\n\n        // normalize vector along line segment\n        float segmentLen = length(segment);\n        segment = (segmentLen > 0.001) ? segment / segmentLen : vec2(0.0, 0.0);\n\n        // displace according to position in the texture\n        vec2 displacementDirU = PERPENDICULAR(segment);\n        vec2 displacementDirV = segment;\n\n        float displacementLen = ${f.float(e/r)} * lineWidth;\n\n        vec4 displacedPosScreen = posScreen;\n        displacedPosScreen.xy += uv0.x * displacementDirU * displacementLen + uv0.y * displacementDirV * displacementLen;\n  `),b.draped||S.code.add(f`vec3 posRight = inverseProject(posScreen + vec4(displacementDirU.xy, 0.0, 0.0) * lineWidth);\nvec3 posLeft = pos.xyz + (pos.xyz - posRight);\npos = toFront(displacedPosScreen, posLeft, posRight, prev.xyz, lineWidth);\ndisplacedPosScreen = projectAndScale(pos);`),S.code.add(f`\n        ${P?\"depth = pos.z;\":\"\"}\n        linearDepth = (-pos.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\n\n        // Convert back into NDC\n        displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n        // Convert texture coordinate into [0,1] and cancel out perspective correct interpolation\n        vUV = (uv0 + 1.0) / 2.0;\n        vUV *= displacedPosScreen.w;\n\n        vSize = displacementLen;\n\n        vColor = getColor();\n        vColor.a *= coverage;\n\n        // Use camera space for slicing\n        vpos = pos.xyz;\n\n        gl_Position = displacedPosScreen;\n      }\n    }\n  `),P&&x.include(s,b),x.include(i,b),j.uniforms.add([new v(\"intrinsicColor\",(e=>e.color)),new u(\"tex\",(e=>e.texture))]),j.include(l),j.code.add(f`\n  void main() {\n    discardBySlice(vpos);\n    ${P?\"terrainDepthTest(gl_FragCoord, depth);\":\"\"}\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    // Offset texture coordinate s.t. we sample texel centers\n    float texelSize = ${f.float(1/e)};\n    vec2 samplePos = vUV * gl_FragCoord.w + vec2(0.5, -0.5) * texelSize;\n\n    // Evaluate sdf\n    float sdf = rgba2float(texture2D(tex, samplePos)) - 0.5;\n    float distance = sdf * vSize;\n\n    // Grow by a halfpixel to make sure the line is fully covered by the cross marker\n    // (otherwise there will be a halo if they are different colours)\n    distance -= 0.5;\n\n    finalColor.a *= clamp(0.5 - distance, 0.0, 1.0);\n\n    if (finalColor.a < ${f.float(n)}) {\n      discard;\n    }\n\n    ${b.output===o.Alpha?f`gl_FragColor = vec4(finalColor.a);`:\"\"}\n    ${b.output===o.Color?f`gl_FragColor = highlightSlice(finalColor, vpos);`:\"\"}\n    ${b.output===o.Color&&b.transparencyPassType===w.Color?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}\n    ${b.output===o.Highlight?f`gl_FragColor = vec4(1.0);`:\"\"}\n    ${b.output===o.Depth?f`outputDepth(linearDepth);`:\"\"}\n  }\n  `),x}const x=Object.freeze(Object.defineProperty({__proto__:null,build:b},Symbol.toStringTag,{value:\"Module\"}));export{x as L,b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}