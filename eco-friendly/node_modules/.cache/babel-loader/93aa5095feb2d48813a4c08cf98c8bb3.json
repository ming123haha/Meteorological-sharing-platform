{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { ReadLinearDepth as e } from \"../output/ReadLinearDepth.glsl.js\";\nimport { multipassGeometryTest as r } from \"../shading/MultipassGeometryTest.glsl.js\";\nimport { RgbaFloatEncoding as t } from \"../util/RgbaFloatEncoding.glsl.js\";\nimport { Float2PassUniform as o } from \"../../shaderModules/Float2PassUniform.js\";\nimport { glsl as a } from \"../../shaderModules/interfaces.js\";\nimport { Texture2DPassUniform as i } from \"../../shaderModules/Texture2DPassUniform.js\";\n\nfunction s(s, n) {\n  const {\n    vertex: p,\n    fragment: l\n  } = s;\n  n.hasMultipassGeometry && p.include(r), n.hasMultipassTerrain && s.varyings.add(\"depth\", \"float\"), p.code.add(a`\n  void main(void) {\n    vec4 posProjCenter;\n    if (dot(position, position) > 0.0) {\n      // Render single point to center of the pixel to avoid subpixel\n      // filtering to affect the marker color\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n      posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n\n      ${n.hasMultipassGeometry ? a`\n        // Don't draw vertices behind geometry\n        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){\n          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n        }` : \"\"}\n\n      ${n.hasMultipassTerrain ? \"depth = projectAux.posView.z;\" : \"\"}\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        // Project out of clip space\n        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n      }\n\n    } else {\n      // Project out of clip space\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n\n    gl_Position = posProjCenter;\n    gl_PointSize = 1.0;\n  }\n  `), n.hasMultipassTerrain && l.include(e), n.hasMultipassTerrain && l.uniforms.add([new i(\"terrainDepthTexture\", (e, r) => r.multipassTerrain.linearDepthTexture), new o(\"nearFar\", (e, r) => r.camera.nearFar), new o(\"inverseViewport\", (e, r) => r.inverseViewport)]), l.include(t), l.code.add(a`\n  void main() {\n    gl_FragColor = vec4(1, 1, 1, 1);\n    ${n.hasMultipassTerrain ? a`\n          vec2 uv = gl_FragCoord.xy * inverseViewport;\n\n          //Read the rgba data from the texture linear depth\n          vec4 terrainDepthData = texture2D(terrainDepthTexture, uv);\n\n          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), nearFar);\n\n          //If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)\n          //Mark the HUD vertex as occluded by transparent terrain\n          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){\n            gl_FragColor.g = 0.5;\n          }` : \"\"}\n  }\n  `);\n}\n\nexport { s as HUDOcclusionPass };","map":{"version":3,"names":["ReadLinearDepth","e","multipassGeometryTest","r","RgbaFloatEncoding","t","Float2PassUniform","o","glsl","a","Texture2DPassUniform","i","s","n","vertex","p","fragment","l","hasMultipassGeometry","include","hasMultipassTerrain","varyings","add","code","uniforms","multipassTerrain","linearDepthTexture","camera","nearFar","inverseViewport","HUDOcclusionPass"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{ReadLinearDepth as e}from\"../output/ReadLinearDepth.glsl.js\";import{multipassGeometryTest as r}from\"../shading/MultipassGeometryTest.glsl.js\";import{RgbaFloatEncoding as t}from\"../util/RgbaFloatEncoding.glsl.js\";import{Float2PassUniform as o}from\"../../shaderModules/Float2PassUniform.js\";import{glsl as a}from\"../../shaderModules/interfaces.js\";import{Texture2DPassUniform as i}from\"../../shaderModules/Texture2DPassUniform.js\";function s(s,n){const{vertex:p,fragment:l}=s;n.hasMultipassGeometry&&p.include(r),n.hasMultipassTerrain&&s.varyings.add(\"depth\",\"float\"),p.code.add(a`\n  void main(void) {\n    vec4 posProjCenter;\n    if (dot(position, position) > 0.0) {\n      // Render single point to center of the pixel to avoid subpixel\n      // filtering to affect the marker color\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n      posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n\n      ${n.hasMultipassGeometry?a`\n        // Don't draw vertices behind geometry\n        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){\n          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n        }`:\"\"}\n\n      ${n.hasMultipassTerrain?\"depth = projectAux.posView.z;\":\"\"}\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        // Project out of clip space\n        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n      }\n\n    } else {\n      // Project out of clip space\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n\n    gl_Position = posProjCenter;\n    gl_PointSize = 1.0;\n  }\n  `),n.hasMultipassTerrain&&l.include(e),n.hasMultipassTerrain&&l.uniforms.add([new i(\"terrainDepthTexture\",((e,r)=>r.multipassTerrain.linearDepthTexture)),new o(\"nearFar\",((e,r)=>r.camera.nearFar)),new o(\"inverseViewport\",((e,r)=>r.inverseViewport))]),l.include(t),l.code.add(a`\n  void main() {\n    gl_FragColor = vec4(1, 1, 1, 1);\n    ${n.hasMultipassTerrain?a`\n          vec2 uv = gl_FragCoord.xy * inverseViewport;\n\n          //Read the rgba data from the texture linear depth\n          vec4 terrainDepthData = texture2D(terrainDepthTexture, uv);\n\n          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), nearFar);\n\n          //If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)\n          //Mark the HUD vertex as occluded by transparent terrain\n          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){\n            gl_FragColor.g = 0.5;\n          }`:\"\"}\n  }\n  `)}export{s as HUDOcclusionPass};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,eAAe,IAAIC,CAA1B,QAAgC,mCAAhC;AAAoE,SAAOC,qBAAqB,IAAIC,CAAhC,QAAsC,0CAAtC;AAAiF,SAAOC,iBAAiB,IAAIC,CAA5B,QAAkC,mCAAlC;AAAsE,SAAOC,iBAAiB,IAAIC,CAA5B,QAAkC,0CAAlC;AAA6E,SAAOC,IAAI,IAAIC,CAAf,QAAqB,mCAArB;AAAyD,SAAOC,oBAAoB,IAAIC,CAA/B,QAAqC,6CAArC;;AAAmF,SAASC,CAAT,CAAWA,CAAX,EAAaC,CAAb,EAAe;EAAC,MAAK;IAACC,MAAM,EAACC,CAAR;IAAUC,QAAQ,EAACC;EAAnB,IAAsBL,CAA3B;EAA6BC,CAAC,CAACK,oBAAF,IAAwBH,CAAC,CAACI,OAAF,CAAUhB,CAAV,CAAxB,EAAqCU,CAAC,CAACO,mBAAF,IAAuBR,CAAC,CAACS,QAAF,CAAWC,GAAX,CAAe,OAAf,EAAuB,OAAvB,CAA5D,EAA4FP,CAAC,CAACQ,IAAF,CAAOD,GAAP,CAAWb,CAAE;AAC1kB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQI,CAAC,CAACK,oBAAF,GAAuBT,CAAE;AACjC;AACA;AACA;AACA,UAJQ,GAIG,EAAG;AACd;AACA,QAAQI,CAAC,CAACO,mBAAF,GAAsB,+BAAtB,GAAsD,EAAG;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GA/B6jB,CAA5F,EA+B5dP,CAAC,CAACO,mBAAF,IAAuBH,CAAC,CAACE,OAAF,CAAUlB,CAAV,CA/Bqc,EA+BxbY,CAAC,CAACO,mBAAF,IAAuBH,CAAC,CAACO,QAAF,CAAWF,GAAX,CAAe,CAAC,IAAIX,CAAJ,CAAM,qBAAN,EAA6B,CAACV,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAACsB,gBAAF,CAAmBC,kBAAvD,CAAD,EAA6E,IAAInB,CAAJ,CAAM,SAAN,EAAiB,CAACN,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAACwB,MAAF,CAASC,OAAjC,CAA7E,EAAwH,IAAIrB,CAAJ,CAAM,iBAAN,EAAyB,CAACN,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAAC0B,eAAlC,CAAxH,CAAf,CA/Bia,EA+BpOZ,CAAC,CAACE,OAAF,CAAUd,CAAV,CA/BoO,EA+BvNY,CAAC,CAACM,IAAF,CAAOD,GAAP,CAAWb,CAAE;AACvR;AACA;AACA,MAAMI,CAAC,CAACO,mBAAF,GAAsBX,CAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAZM,GAYO,EAAG;AAChB;AACA,GAjB0Q,CA/BuN;AAgD5d;;AAAA,SAAOG,CAAC,IAAIkB,gBAAZ"},"metadata":{},"sourceType":"module"}