{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { NoiseTextureRenderMode as e } from \"../views/3d/environment/NoiseTextureAtlasConfiguration.js\";\nimport { TILE_ROWS as o, WEATHER_TILE_SIZE as t, WEATHER_MAP_SIZE as r, TILE_SIZE as l, ATLAS_SIZE as a } from \"../views/3d/environment/NoiseTextureAtlasDimensions.js\";\nimport { ScreenSpacePass as i } from \"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js\";\nimport { Float2Uniform as d } from \"../views/3d/webgl-engine/core/shaderModules/Float2Uniform.js\";\nimport { glsl as f } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as n } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\n\nfunction p(p) {\n  const c = new n();\n\n  if (c.include(i, !1), c.fragment.code.add(f`float remap(float x, float low1, float high1, float low2, float high2) {\nreturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}`), c.fragment.uniforms.add(new d(\"weatherTile\")), p.mode === e.Full) {\n    const e = 2,\n          t = 8;\n    c.fragment.code.add(f`\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }\n\n    // Safer modulo for positive and negative values\n    vec3 modulo(vec3 m, float n){\n      return mod(mod(m, n) + n, n);\n    }\n\n    vec3 hash(vec3 p3, float frequency){\n      p3 = modulo(p3, frequency);\n      p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yxz + 33.33);\n      return -1.0 + 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx);\n    }\n\n    // 5th order polynomial interpolation\n    vec3 fade(vec3 t){\n      return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n    }\n\n    float gradientNoise(vec3 p, float frequency){\n      // Cell point is in\n      vec3 i = floor(p);\n\n      // Position in the cell in [0, 1]\n      vec3 f = fract(p);\n\n      // Interpolation value for gradient mixing\n      vec3 u = fade(f);\n\n      // Trilinear interpolation of gradients at cube vertices around point\n      return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0), frequency), f - vec3(0.0,0.0,0.0) ),\n                            dot( hash( i + vec3(1.0,0.0,0.0), frequency), f - vec3(1.0,0.0,0.0) ), u.x),\n                       mix( dot( hash( i + vec3(0.0,1.0,0.0), frequency), f - vec3(0.0,1.0,0.0) ),\n                            dot( hash( i + vec3(1.0,1.0,0.0), frequency), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                  mix( mix( dot( hash( i + vec3(0.0,0.0,1.0), frequency), f - vec3(0.0,0.0,1.0) ),\n                            dot( hash( i + vec3(1.0,0.0,1.0), frequency), f - vec3(1.0,0.0,1.0) ), u.x),\n                       mix( dot( hash( i + vec3(0.0,1.0,1.0), frequency), f - vec3(0.0,1.0,1.0) ),\n                            dot( hash( i + vec3(1.0,1.0,1.0), frequency), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    float getPerlinNoise(vec3 pos, float frequency) {\n      float octaveFrequencyFactor = 2.0;\n      float sum = 0.0;\n      float weightSum = 0.0;\n      float weight = 1.0;\n\n      for (int oct = 0; oct < 3; oct++) {\n        vec3 p = pos * frequency;\n        float val = 0.5 + 0.5 * gradientNoise(p, frequency);\n        sum += val * weight;\n        weightSum += weight;\n        weight *= 0.5;\n        frequency *= octaveFrequencyFactor;\n      }\n\n      float noise = (sum / weightSum);\n      noise = saturate(noise);\n      return noise;\n    }\n\n    float worley(vec3 pos, float numCells) {\n      vec3 p = pos * numCells;\n      float d = 1.0e10;\n\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          for (int z = -1; z <= 1; z++) {\n            vec3 tp = floor(p) + vec3(x, y, z);\n            tp = p - tp - (hash(tp, numCells) * 0.5 + 0.5);\n            d = min(d, dot(tp, tp));\n          }\n        }\n      }\n\n      return 1.0 - clamp(d, 0.0, 1.0);\n    }\n\n    vec3 get3Dfrom2D(vec2 uv) {\n      vec2 tile = floor(uv);\n      float z = floor(${f.float(o)} * tile.y + tile.x);\n      return vec3(fract(uv), z);\n    }\n\n    float getTextureForPointPerlinWorley(vec3 p) {\n      float perlinNoise = getPerlinNoise(p, ${f.float(t)});\n\n      float worley0 = worley(p, ${f.float(e)} * 2.0);\n      float worley1 = worley(p, ${f.float(e)} * 8.0);\n      float worley2 = worley(p, ${f.float(e)} * 14.0);\n\n      float worleyFBM = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n      return remap(perlinNoise, 0.0, 1.0, worleyFBM, 1.0);\n    }\n\n    float getTextureForPointWorley(vec3 p) {\n      float worley0 = worley(p, ${f.float(e)});\n      float worley1 = worley(p, ${f.float(e)} * 2.0);\n      float worley2 = worley(p, ${f.float(e)} * 4.0);\n      float worley3 = worley(p, ${f.float(e)} * 8.0);\n\n      float FBM0 = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n      float FBM1 = worley1 * 0.625 + worley2 * 0.25 + worley3 * 0.125;\n      float FBM2 = worley2 * 0.75 + worley3 * 0.25;\n\n      return FBM0 * 0.625 + FBM1 * 0.25 + FBM2 * 0.125;\n    }\n  `);\n  }\n\n  return c.fragment.code.add(f`\n    vec2 modulo(vec2 m, float n){\n      return mod(mod(m, n) + n, n);\n    }\n\n    vec2 hash(vec2 p){\n      // Get position of p in weather tile\n      p = modulo(p, ${f.float(t)});\n\n      // Get global coordinates of p\n      p += weatherTile * ${f.float(t)};\n\n      // Limit position to avoid numerical instability\n      p = modulo(p, ${f.float(r)});\n\n      vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yzx + 33.33);\n      return 2.0 * fract((p3.xx + p3.yz) * p3.zy) - 1.0;\n    }\n\n    vec2 fade(vec2 t){\n      return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n    }\n\n    float gradientNoise(vec2 p){\n      vec2 i = floor( p );\n      vec2 f = fract( p );\n\n      vec2 u = fade(f);\n\n      // Bilinear interpolation of gradients at cell vertices around point\n      return  mix(\n                mix(dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                    dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix(dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                    dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x),\n                u.y);\n    }\n\n    float worley(vec2 p){\n      float d = 1.0e10;\n      for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n                vec2 tp = floor(p) + vec2(x, y);\n                tp = p - tp - (0.5 + 0.5 * hash(tp));\n                d = min(d, dot(tp, tp));\n            }\n        }\n      return 1.0 - clamp(d, 0.0, 1.0);\n    }\n  `), c.fragment.code.add(f`void main() {`), p.mode === e.Full && c.fragment.code.add(f`\n        float padWidth = 1.0;\n        float paddedSize = ${f.float(l)} + 2.0 * padWidth;\n        float tileCount = ${f.float(o)} * ${f.float(o)};\n        vec2 tile = floor((gl_FragCoord.xy - 0.5) / paddedSize);\n\n        bool padCell = false;\n        if (mod(gl_FragCoord.x, paddedSize) == 0.5 || mod(gl_FragCoord.x, paddedSize) == paddedSize - 0.5) {\n          padCell = true;\n        }\n\n        if (mod(gl_FragCoord.y, paddedSize) == 0.5 || mod(gl_FragCoord.y, paddedSize) == paddedSize - 0.5) {\n          padCell = true;\n        }\n\n        bool startPadX = false;\n        bool startPadY = false;\n        bool endPadX = false;\n        bool endPadY = false;\n\n        if (gl_FragCoord.x == tile.x * paddedSize + 0.5) {\n          startPadX = true;\n        }\n\n        if (gl_FragCoord.y == tile.y * paddedSize + 0.5) {\n          startPadY = true;\n        }\n\n        if (gl_FragCoord.x == (tile.x + 1.0) * paddedSize - 0.5) {\n          endPadX = true;\n        }\n\n        if (gl_FragCoord.y == (tile.y + 1.0) * paddedSize - 0.5) {\n          endPadY = true;\n        }\n\n        vec2 padding = vec2(2.0 * padWidth) * tile;\n        vec2 uv;\n\n        if (padCell) {\n          vec2 pixel = gl_FragCoord.xy - padWidth - padding;\n\n          if (startPadX) {\n            pixel.x += ${f.float(l)};\n          }\n\n          if (startPadY) {\n            pixel.y += ${f.float(l)};\n          }\n\n          if (endPadX) {\n            pixel.x -= ${f.float(l)};\n          }\n\n          if (endPadY) {\n            pixel.y -= ${f.float(l)};\n          }\n\n          uv = vec2(pixel.xy / ${f.float(l)});\n        } else {\n          vec2 pixel = gl_FragCoord.xy - padWidth - padding;\n          uv = vec2(pixel.xy / ${f.float(l)});\n        }\n\n        vec3 p_ = get3Dfrom2D(uv);\n        vec3 p = p_;\n        p.z /= (${f.float(o)} * ${f.float(o)});\n\n        float worleyPerlinNoise = getTextureForPointPerlinWorley(p);\n        float worleyNoise = getTextureForPointWorley(p);\n\n        gl_FragColor.r = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        p_ = mod(p_ + 1.0, ${f.float(o)} * ${f.float(o)});\n        p = p_;\n        p.z /= (${f.float(o)} * ${f.float(o)});\n\n        worleyPerlinNoise = getTextureForPointPerlinWorley(p);\n        worleyNoise = getTextureForPointWorley(p);\n\n        gl_FragColor.g = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n      `), c.fragment.code.add(f`\n      vec2 mapUV = ${f.float(t)} * (gl_FragCoord.xy / ${f.float(a)});\n      float map = abs(gradientNoise(mapUV));\n      map = remap(map, 0.25 * (1.0 - worley(8.0 * mapUV)), 1.0, 0.0, 1.0);\n\n      ${p.mode === e.Full ? f`gl_FragColor.ba = vec2(0.0, map);` : f`gl_FragColor = vec4(map);`};\n    }\n  `), c;\n}\n\nconst c = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: p\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { c as N, p as b };","map":{"version":3,"names":["NoiseTextureRenderMode","e","TILE_ROWS","o","WEATHER_TILE_SIZE","t","WEATHER_MAP_SIZE","r","TILE_SIZE","l","ATLAS_SIZE","a","ScreenSpacePass","i","Float2Uniform","d","glsl","f","ShaderBuilder","n","p","c","include","fragment","code","add","uniforms","mode","Full","float","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","N","b"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/chunks/NoiseTextureAtlas.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{NoiseTextureRenderMode as e}from\"../views/3d/environment/NoiseTextureAtlasConfiguration.js\";import{TILE_ROWS as o,WEATHER_TILE_SIZE as t,WEATHER_MAP_SIZE as r,TILE_SIZE as l,ATLAS_SIZE as a}from\"../views/3d/environment/NoiseTextureAtlasDimensions.js\";import{ScreenSpacePass as i}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js\";import{Float2Uniform as d}from\"../views/3d/webgl-engine/core/shaderModules/Float2Uniform.js\";import{glsl as f}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as n}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";function p(p){const c=new n;if(c.include(i,!1),c.fragment.code.add(f`float remap(float x, float low1, float high1, float low2, float high2) {\nreturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}`),c.fragment.uniforms.add(new d(\"weatherTile\")),p.mode===e.Full){const e=2,t=8;c.fragment.code.add(f`\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }\n\n    // Safer modulo for positive and negative values\n    vec3 modulo(vec3 m, float n){\n      return mod(mod(m, n) + n, n);\n    }\n\n    vec3 hash(vec3 p3, float frequency){\n      p3 = modulo(p3, frequency);\n      p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yxz + 33.33);\n      return -1.0 + 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx);\n    }\n\n    // 5th order polynomial interpolation\n    vec3 fade(vec3 t){\n      return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n    }\n\n    float gradientNoise(vec3 p, float frequency){\n      // Cell point is in\n      vec3 i = floor(p);\n\n      // Position in the cell in [0, 1]\n      vec3 f = fract(p);\n\n      // Interpolation value for gradient mixing\n      vec3 u = fade(f);\n\n      // Trilinear interpolation of gradients at cube vertices around point\n      return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0), frequency), f - vec3(0.0,0.0,0.0) ),\n                            dot( hash( i + vec3(1.0,0.0,0.0), frequency), f - vec3(1.0,0.0,0.0) ), u.x),\n                       mix( dot( hash( i + vec3(0.0,1.0,0.0), frequency), f - vec3(0.0,1.0,0.0) ),\n                            dot( hash( i + vec3(1.0,1.0,0.0), frequency), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                  mix( mix( dot( hash( i + vec3(0.0,0.0,1.0), frequency), f - vec3(0.0,0.0,1.0) ),\n                            dot( hash( i + vec3(1.0,0.0,1.0), frequency), f - vec3(1.0,0.0,1.0) ), u.x),\n                       mix( dot( hash( i + vec3(0.0,1.0,1.0), frequency), f - vec3(0.0,1.0,1.0) ),\n                            dot( hash( i + vec3(1.0,1.0,1.0), frequency), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    float getPerlinNoise(vec3 pos, float frequency) {\n      float octaveFrequencyFactor = 2.0;\n      float sum = 0.0;\n      float weightSum = 0.0;\n      float weight = 1.0;\n\n      for (int oct = 0; oct < 3; oct++) {\n        vec3 p = pos * frequency;\n        float val = 0.5 + 0.5 * gradientNoise(p, frequency);\n        sum += val * weight;\n        weightSum += weight;\n        weight *= 0.5;\n        frequency *= octaveFrequencyFactor;\n      }\n\n      float noise = (sum / weightSum);\n      noise = saturate(noise);\n      return noise;\n    }\n\n    float worley(vec3 pos, float numCells) {\n      vec3 p = pos * numCells;\n      float d = 1.0e10;\n\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          for (int z = -1; z <= 1; z++) {\n            vec3 tp = floor(p) + vec3(x, y, z);\n            tp = p - tp - (hash(tp, numCells) * 0.5 + 0.5);\n            d = min(d, dot(tp, tp));\n          }\n        }\n      }\n\n      return 1.0 - clamp(d, 0.0, 1.0);\n    }\n\n    vec3 get3Dfrom2D(vec2 uv) {\n      vec2 tile = floor(uv);\n      float z = floor(${f.float(o)} * tile.y + tile.x);\n      return vec3(fract(uv), z);\n    }\n\n    float getTextureForPointPerlinWorley(vec3 p) {\n      float perlinNoise = getPerlinNoise(p, ${f.float(t)});\n\n      float worley0 = worley(p, ${f.float(e)} * 2.0);\n      float worley1 = worley(p, ${f.float(e)} * 8.0);\n      float worley2 = worley(p, ${f.float(e)} * 14.0);\n\n      float worleyFBM = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n      return remap(perlinNoise, 0.0, 1.0, worleyFBM, 1.0);\n    }\n\n    float getTextureForPointWorley(vec3 p) {\n      float worley0 = worley(p, ${f.float(e)});\n      float worley1 = worley(p, ${f.float(e)} * 2.0);\n      float worley2 = worley(p, ${f.float(e)} * 4.0);\n      float worley3 = worley(p, ${f.float(e)} * 8.0);\n\n      float FBM0 = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n      float FBM1 = worley1 * 0.625 + worley2 * 0.25 + worley3 * 0.125;\n      float FBM2 = worley2 * 0.75 + worley3 * 0.25;\n\n      return FBM0 * 0.625 + FBM1 * 0.25 + FBM2 * 0.125;\n    }\n  `)}return c.fragment.code.add(f`\n    vec2 modulo(vec2 m, float n){\n      return mod(mod(m, n) + n, n);\n    }\n\n    vec2 hash(vec2 p){\n      // Get position of p in weather tile\n      p = modulo(p, ${f.float(t)});\n\n      // Get global coordinates of p\n      p += weatherTile * ${f.float(t)};\n\n      // Limit position to avoid numerical instability\n      p = modulo(p, ${f.float(r)});\n\n      vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yzx + 33.33);\n      return 2.0 * fract((p3.xx + p3.yz) * p3.zy) - 1.0;\n    }\n\n    vec2 fade(vec2 t){\n      return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n    }\n\n    float gradientNoise(vec2 p){\n      vec2 i = floor( p );\n      vec2 f = fract( p );\n\n      vec2 u = fade(f);\n\n      // Bilinear interpolation of gradients at cell vertices around point\n      return  mix(\n                mix(dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                    dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix(dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                    dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x),\n                u.y);\n    }\n\n    float worley(vec2 p){\n      float d = 1.0e10;\n      for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n                vec2 tp = floor(p) + vec2(x, y);\n                tp = p - tp - (0.5 + 0.5 * hash(tp));\n                d = min(d, dot(tp, tp));\n            }\n        }\n      return 1.0 - clamp(d, 0.0, 1.0);\n    }\n  `),c.fragment.code.add(f`void main() {`),p.mode===e.Full&&c.fragment.code.add(f`\n        float padWidth = 1.0;\n        float paddedSize = ${f.float(l)} + 2.0 * padWidth;\n        float tileCount = ${f.float(o)} * ${f.float(o)};\n        vec2 tile = floor((gl_FragCoord.xy - 0.5) / paddedSize);\n\n        bool padCell = false;\n        if (mod(gl_FragCoord.x, paddedSize) == 0.5 || mod(gl_FragCoord.x, paddedSize) == paddedSize - 0.5) {\n          padCell = true;\n        }\n\n        if (mod(gl_FragCoord.y, paddedSize) == 0.5 || mod(gl_FragCoord.y, paddedSize) == paddedSize - 0.5) {\n          padCell = true;\n        }\n\n        bool startPadX = false;\n        bool startPadY = false;\n        bool endPadX = false;\n        bool endPadY = false;\n\n        if (gl_FragCoord.x == tile.x * paddedSize + 0.5) {\n          startPadX = true;\n        }\n\n        if (gl_FragCoord.y == tile.y * paddedSize + 0.5) {\n          startPadY = true;\n        }\n\n        if (gl_FragCoord.x == (tile.x + 1.0) * paddedSize - 0.5) {\n          endPadX = true;\n        }\n\n        if (gl_FragCoord.y == (tile.y + 1.0) * paddedSize - 0.5) {\n          endPadY = true;\n        }\n\n        vec2 padding = vec2(2.0 * padWidth) * tile;\n        vec2 uv;\n\n        if (padCell) {\n          vec2 pixel = gl_FragCoord.xy - padWidth - padding;\n\n          if (startPadX) {\n            pixel.x += ${f.float(l)};\n          }\n\n          if (startPadY) {\n            pixel.y += ${f.float(l)};\n          }\n\n          if (endPadX) {\n            pixel.x -= ${f.float(l)};\n          }\n\n          if (endPadY) {\n            pixel.y -= ${f.float(l)};\n          }\n\n          uv = vec2(pixel.xy / ${f.float(l)});\n        } else {\n          vec2 pixel = gl_FragCoord.xy - padWidth - padding;\n          uv = vec2(pixel.xy / ${f.float(l)});\n        }\n\n        vec3 p_ = get3Dfrom2D(uv);\n        vec3 p = p_;\n        p.z /= (${f.float(o)} * ${f.float(o)});\n\n        float worleyPerlinNoise = getTextureForPointPerlinWorley(p);\n        float worleyNoise = getTextureForPointWorley(p);\n\n        gl_FragColor.r = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        p_ = mod(p_ + 1.0, ${f.float(o)} * ${f.float(o)});\n        p = p_;\n        p.z /= (${f.float(o)} * ${f.float(o)});\n\n        worleyPerlinNoise = getTextureForPointPerlinWorley(p);\n        worleyNoise = getTextureForPointWorley(p);\n\n        gl_FragColor.g = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n      `),c.fragment.code.add(f`\n      vec2 mapUV = ${f.float(t)} * (gl_FragCoord.xy / ${f.float(a)});\n      float map = abs(gradientNoise(mapUV));\n      map = remap(map, 0.25 * (1.0 - worley(8.0 * mapUV)), 1.0, 0.0, 1.0);\n\n      ${p.mode===e.Full?f`gl_FragColor.ba = vec2(0.0, map);`:f`gl_FragColor = vec4(map);`};\n    }\n  `),c}const c=Object.freeze(Object.defineProperty({__proto__:null,build:p},Symbol.toStringTag,{value:\"Module\"}));export{c as N,p as b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}