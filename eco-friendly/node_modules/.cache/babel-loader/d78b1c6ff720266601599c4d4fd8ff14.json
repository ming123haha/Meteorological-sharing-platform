{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\n\n/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.97\n */\nimport { e as rectToClientRect } from './floating-ui.js';\n/**\n * This module provides utils to fix positioning across shadow DOM in non-Chromium browsers\n *\n * It is based on floating-ui's distributable\n */\n\n/**\n * 👇 the following are needed to fix shadow DOM positioning 👇️\n *\n * @param element\n */\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n    return null;\n  }\n\n  return composedOffsetParent(element);\n}\n/**\n * Polyfills the old offsetParent behavior from before the spec was changed:\n * https://github.com/w3c/csswg-drafts/issues/159\n *\n * @param element\n */\n\n\nfunction composedOffsetParent(element) {\n  let {\n    offsetParent\n  } = element;\n  let ancestor = element;\n  let foundInsideSlot = false;\n\n  while (ancestor && ancestor !== offsetParent) {\n    const {\n      assignedSlot\n    } = ancestor;\n\n    if (assignedSlot) {\n      let newOffsetParent = assignedSlot.offsetParent;\n\n      if (getComputedStyle(assignedSlot).display === \"contents\") {\n        const hadStyleAttribute = assignedSlot.hasAttribute(\"style\");\n        const oldDisplay = assignedSlot.style.display;\n        assignedSlot.style.display = getComputedStyle(ancestor).display;\n        newOffsetParent = assignedSlot.offsetParent;\n        assignedSlot.style.display = oldDisplay;\n\n        if (!hadStyleAttribute) {\n          assignedSlot.removeAttribute(\"style\");\n        }\n      }\n\n      ancestor = assignedSlot;\n\n      if (offsetParent !== newOffsetParent) {\n        offsetParent = newOffsetParent;\n        foundInsideSlot = true;\n      }\n    } else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {\n      break;\n    }\n\n    ancestor = isShadowRoot(ancestor) && ancestor.host || ancestor.parentNode;\n  }\n\n  return offsetParent;\n}\n\nfunction getElementRects(_ref) {\n  const {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n    floating: { ...getDimensions(floating),\n      x: 0,\n      y: 0\n    }\n  };\n}\n/**\n * ☝️ the following are needed to fix shadow DOM positioning ☝️\n */\n\n/**\n * 👇 the following are taken directly from floating-ui's ESM distributable to support the exports above 👇️\n *\n * **Notes**:\n * unused functions are removed\n * ESLint is disabled\n * TS-warnings are suppressed\n */\n\n/* eslint-disable */\n\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\n\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? \"\" : node ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\n\nfunction getUAString() {\n  // @ts-ignore\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(\" \");\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\n\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\n\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display);\n}\n\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element));\n}\n\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== \"none\" || css.perspective !== \"none\" || isFirefox && css.willChange === \"filter\" || isFirefox && (css.filter ? css.filter !== \"none\" : false) || [\"transform\", \"perspective\"].some(value => css.willChange.includes(value)) || [\"paint\", \"layout\", \"strict\", \"content\"].some( // TS 4.1 compat\n  value => {\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\n\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nfunction isLastTraversableNode(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // @ts-ignore\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === \"fixed\");\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      // @ts-ignore\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\" && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  } // @ts-ignore\n\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n} // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === \"rtl\") {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList // @ts-ignore: isBody tells us target will be an HTMLElement here\n  : updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {\n  let currentNode = element;\n\n  while (currentNode && !isLastTraversableNode(currentNode) && !clippingAncestors.includes(currentNode)) {\n    if (isElement(currentNode) && [\"absolute\", \"fixed\"].includes(getComputedStyle(currentNode).position)) {\n      break;\n    }\n\n    const parentNode = getParentNode(currentNode);\n    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;\n  }\n\n  return currentNode;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === \"viewport\") {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  // @ts-ignore\n  const clippingAncestors = getOverflowAncestors(element);\n  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);\n  let clipperElement = null;\n\n  if (nearestEscapableParent && isHTMLElement(nearestEscapableParent)) {\n    const offsetParent = getOffsetParent(nearestEscapableParent);\n\n    if (isOverflowElement(nearestEscapableParent)) {\n      clipperElement = nearestEscapableParent;\n    } else if (isHTMLElement(offsetParent)) {\n      clipperElement = offsetParent;\n    }\n  }\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => clipperElement && isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== \"body\");\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === \"clippingAncestors\" ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nexport { getClippingRect, getElementRects, getOffsetParent };","map":{"version":3,"names":["e","rectToClientRect","getTrueOffsetParent","element","isHTMLElement","getComputedStyle","position","composedOffsetParent","offsetParent","ancestor","foundInsideSlot","assignedSlot","newOffsetParent","display","hadStyleAttribute","hasAttribute","oldDisplay","style","removeAttribute","isShadowRoot","host","parentNode","getElementRects","_ref","reference","floating","strategy","getRectRelativeToOffsetParent","getOffsetParent","getDimensions","x","y","isWindow","value","document","location","alert","setInterval","getWindow","node","window","ownerDocument","defaultView","getNodeName","nodeName","toLowerCase","getUAString","uaData","navigator","userAgentData","brands","map","item","brand","version","join","userAgent","HTMLElement","isElement","Element","isNode","Node","ShadowRoot","OwnElement","isOverflowElement","overflow","overflowX","overflowY","test","includes","isTableElement","isContainingBlock","isFirefox","css","transform","perspective","willChange","filter","some","contain","isLayoutViewport","isLastTraversableNode","min","Math","max","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","offsetWidth","width","offsetHeight","height","win","addVisualOffsets","left","visualViewport","offsetLeft","top","offsetTop","right","bottom","getDocumentElement","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","isScaled","rect","isOffsetParentAnElement","scroll","offsets","offsetRect","clientLeft","clientTop","getParentNode","getContainingBlock","currentNode","parent","getViewportRect","html","clientWidth","clientHeight","layoutViewport","getDocumentRect","_element$ownerDocumen","body","scrollWidth","scrollHeight","direction","getNearestOverflowAncestor","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","concat","updatedList","contains","child","rootNode","getRootNode","next","getNearestParentCapableOfEscapingClipping","clippingAncestors","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingParent","getClippingAncestors","nearestEscapableParent","clipperElement","getClippingRect","boundary","rootBoundary","mainClippingAncestors","firstClippingAncestor","clippingRect","reduce","accRect","clippingAncestor"],"sources":["E:/各个学科/论文/毕业论文/Atmosphere/eco-friendly/node_modules/@esri/calcite-components/dist/components/nonChromiumPlatformUtils.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.97\n */\nimport { e as rectToClientRect } from './floating-ui.js';\n\n/**\n * This module provides utils to fix positioning across shadow DOM in non-Chromium browsers\n *\n * It is based on floating-ui's distributable\n */\n/**\n * 👇 the following are needed to fix shadow DOM positioning 👇️\n *\n * @param element\n */\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n    return null;\n  }\n  return composedOffsetParent(element);\n}\n/**\n * Polyfills the old offsetParent behavior from before the spec was changed:\n * https://github.com/w3c/csswg-drafts/issues/159\n *\n * @param element\n */\nfunction composedOffsetParent(element) {\n  let { offsetParent } = element;\n  let ancestor = element;\n  let foundInsideSlot = false;\n  while (ancestor && ancestor !== offsetParent) {\n    const { assignedSlot } = ancestor;\n    if (assignedSlot) {\n      let newOffsetParent = assignedSlot.offsetParent;\n      if (getComputedStyle(assignedSlot).display === \"contents\") {\n        const hadStyleAttribute = assignedSlot.hasAttribute(\"style\");\n        const oldDisplay = assignedSlot.style.display;\n        assignedSlot.style.display = getComputedStyle(ancestor).display;\n        newOffsetParent = assignedSlot.offsetParent;\n        assignedSlot.style.display = oldDisplay;\n        if (!hadStyleAttribute) {\n          assignedSlot.removeAttribute(\"style\");\n        }\n      }\n      ancestor = assignedSlot;\n      if (offsetParent !== newOffsetParent) {\n        offsetParent = newOffsetParent;\n        foundInsideSlot = true;\n      }\n    }\n    else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {\n      break;\n    }\n    ancestor = (isShadowRoot(ancestor) && ancestor.host) || ancestor.parentNode;\n  }\n  return offsetParent;\n}\nfunction getElementRects(_ref) {\n  const { reference, floating, strategy } = _ref;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n    floating: { ...getDimensions(floating), x: 0, y: 0 }\n  };\n}\n/**\n * ☝️ the following are needed to fix shadow DOM positioning ☝️\n */\n/**\n * 👇 the following are taken directly from floating-ui's ESM distributable to support the exports above 👇️\n *\n * **Notes**:\n * unused functions are removed\n * ESLint is disabled\n * TS-warnings are suppressed\n */\n/* eslint-disable */\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeName(node) {\n  return isWindow(node) ? \"\" : node ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction getUAString() {\n  // @ts-ignore\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map((item) => item.brand + \"/\" + item.version).join(\" \");\n  }\n  return navigator.userAgent;\n}\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n  return (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display));\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return (css.transform !== \"none\" ||\n    css.perspective !== \"none\" ||\n    (isFirefox && css.willChange === \"filter\") ||\n    (isFirefox && (css.filter ? css.filter !== \"none\" : false)) ||\n    [\"transform\", \"perspective\"].some((value) => css.willChange.includes(value)) ||\n    [\"paint\", \"layout\", \"strict\", \"content\"].some(\n    // TS 4.1 compat\n    (value) => {\n      const contain = css.contain;\n      return contain != null ? contain.includes(value) : false;\n    }));\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\nfunction isLastTraversableNode(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left +\n    (addVisualOffsets\n      ? (_win$visualViewport$o =\n        (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null\n        ? _win$visualViewport$o\n        : 0\n      : 0)) /\n    scaleX;\n  const y = (clientRect.top +\n    (addVisualOffsets\n      ? (_win$visualViewport$o2 =\n        (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null\n        ? _win$visualViewport$o2\n        : 0\n      : 0)) /\n    scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // @ts-ignore\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction isScaled(element) {\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === \"fixed\");\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || (!isOffsetParentAnElement && strategy !== \"fixed\")) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      // @ts-ignore\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n    else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  return (\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  // @ts-ignore\n  node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || // DOM Element detected\n    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n  );\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent &&\n    (getNodeName(offsetParent) === \"html\" ||\n      (getNodeName(offsetParent) === \"body\" &&\n        getComputedStyle(offsetParent).position === \"static\" &&\n        !isContainingBlock(offsetParent)))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || (!layoutViewport && strategy === \"fixed\")) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body || html).direction === \"rtl\") {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody\n    ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n    : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody\n    ? updatedList // @ts-ignore: isBody tells us target will be an HTMLElement here\n    : updatedList.concat(getOverflowAncestors(target));\n}\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\nfunction getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {\n  let currentNode = element;\n  while (currentNode && !isLastTraversableNode(currentNode) && !clippingAncestors.includes(currentNode)) {\n    if (isElement(currentNode) && [\"absolute\", \"fixed\"].includes(getComputedStyle(currentNode).position)) {\n      break;\n    }\n    const parentNode = getParentNode(currentNode);\n    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;\n  }\n  return currentNode;\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === \"viewport\") {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingAncestors(element) {\n  // @ts-ignore\n  const clippingAncestors = getOverflowAncestors(element);\n  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);\n  let clipperElement = null;\n  if (nearestEscapableParent && isHTMLElement(nearestEscapableParent)) {\n    const offsetParent = getOffsetParent(nearestEscapableParent);\n    if (isOverflowElement(nearestEscapableParent)) {\n      clipperElement = nearestEscapableParent;\n    }\n    else if (isHTMLElement(offsetParent)) {\n      clipperElement = offsetParent;\n    }\n  }\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n  return clippingAncestors.filter((clippingAncestors) => clipperElement &&\n    isElement(clippingAncestors) &&\n    contains(clippingAncestors, clipperElement) &&\n    getNodeName(clippingAncestors) !== \"body\");\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n  let { element, boundary, rootBoundary, strategy } = _ref;\n  const mainClippingAncestors = boundary === \"clippingAncestors\" ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nexport { getClippingRect, getElementRects, getOffsetParent };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}