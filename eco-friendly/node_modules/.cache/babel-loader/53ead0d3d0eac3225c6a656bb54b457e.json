{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.25/esri/copyright.txt for details.\n*/\nimport { c as e } from \"../../../../../../chunks/vec3f64.js\";\nimport { RgbaFloatEncoding as a } from \"../util/RgbaFloatEncoding.glsl.js\";\nimport { textureSize as s } from \"../util/WebGL2Utils.js\";\nimport { Float4PassUniform as o } from \"../../shaderModules/Float4PassUniform.js\";\nimport { IntegerPassUniform as t } from \"../../shaderModules/IntegerPassUniform.js\";\nimport { NoParameters as i, glsl as r } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4sDrawUniform as d } from \"../../shaderModules/Matrix4sDrawUniform.js\";\nimport { Matrix4sPassUniform as l } from \"../../shaderModules/Matrix4sPassUniform.js\";\nimport { createTexture2DPassSizeUniforms as p } from \"../../shaderModules/Texture2DPassUniform.js\";\nimport { TextureSizeUniformType as c } from \"../../shaderModules/TextureSizeUniformType.js\";\n\nclass n extends i {\n  constructor() {\n    super(...arguments), this.origin = e();\n  }\n\n}\n\nfunction h(e, a) {\n  a.receiveShadows && (e.fragment.uniforms.add(new l(\"shadowMapMatrix\", (e, a) => a.shadowMap.getShadowMapMatrices(e.origin), 4)), f(e, a));\n}\n\nfunction v(e, a) {\n  a.receiveShadows && (e.fragment.uniforms.add(new d(\"shadowMapMatrix\", (e, a) => a.shadowMap.getShadowMapMatrices(e.origin), 4)), f(e, a));\n}\n\nfunction f(e, i) {\n  const d = e.fragment;\n  d.include(a), d.uniforms.add([...p(\"shadowMapTex\", (e, a) => a.shadowMap.depthTexture, i.hasWebGL2Context ? c.None : c.Size), new t(\"numCascades\", (e, a) => a.shadowMap.numCascades), new o(\"cascadeDistances\", (e, a) => a.shadowMap.cascadeDistances)]), d.code.add(r`\n    int chooseCascade(float depth, out mat4 mat) {\n      vec4 distance = cascadeDistances;\n\n      // choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      return i;\n    }\n\n    vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n      return 0.5 * lv.xyz + vec3(0.5);\n    }\n\n    vec2 cascadeCoordinates(int i, vec3 lvpos) {\n      return vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n    }\n\n    float readShadowMapDepth(vec2 uv, sampler2D _depthTex) {\n      return rgba2float(texture2D(_depthTex, uv));\n    }\n\n    float posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {\n      return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;\n    }\n\n    float filterShadow(vec2 uv, vec3 lvpos, float textureSize, sampler2D _depthTex) {\n      float halfPixelSize = 0.5 / textureSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * textureSize);\n\n      float s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);\n      float s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);\n      float s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);\n      float s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      mat4 mat;\n      int i = chooseCascade(_linearDepth, mat);\n\n      if (i >= numCascades) { return 0.0; }\n\n      vec3 lvpos = lightSpacePosition(_vpos, mat);\n\n      // vertex completely outside? -> no shadow\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = cascadeCoordinates(i, lvpos);\n\n      vec2 textureSize = ${s(i, \"shadowMapTex\")};\n\n      return filterShadow(uv, lvpos, textureSize.x, shadowMapTex);\n    }\n  `);\n}\n\nexport { n as ReadShadowMapBindParameters, v as ReadShadowMapDraw, h as ReadShadowMapPass };","map":{"version":3,"names":["c","e","RgbaFloatEncoding","a","textureSize","s","Float4PassUniform","o","IntegerPassUniform","t","NoParameters","i","glsl","r","Matrix4sDrawUniform","d","Matrix4sPassUniform","l","createTexture2DPassSizeUniforms","p","TextureSizeUniformType","n","constructor","arguments","origin","h","receiveShadows","fragment","uniforms","add","shadowMap","getShadowMapMatrices","f","v","include","depthTexture","hasWebGL2Context","None","Size","numCascades","cascadeDistances","code","ReadShadowMapBindParameters","ReadShadowMapDraw","ReadShadowMapPass"],"sources":["E:/各个学科/论文/毕业论文/Atmosphere/eco-friendly/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.25/esri/copyright.txt for details.\n*/\nimport{c as e}from\"../../../../../../chunks/vec3f64.js\";import{RgbaFloatEncoding as a}from\"../util/RgbaFloatEncoding.glsl.js\";import{textureSize as s}from\"../util/WebGL2Utils.js\";import{Float4PassUniform as o}from\"../../shaderModules/Float4PassUniform.js\";import{IntegerPassUniform as t}from\"../../shaderModules/IntegerPassUniform.js\";import{NoParameters as i,glsl as r}from\"../../shaderModules/interfaces.js\";import{Matrix4sDrawUniform as d}from\"../../shaderModules/Matrix4sDrawUniform.js\";import{Matrix4sPassUniform as l}from\"../../shaderModules/Matrix4sPassUniform.js\";import{createTexture2DPassSizeUniforms as p}from\"../../shaderModules/Texture2DPassUniform.js\";import{TextureSizeUniformType as c}from\"../../shaderModules/TextureSizeUniformType.js\";class n extends i{constructor(){super(...arguments),this.origin=e()}}function h(e,a){a.receiveShadows&&(e.fragment.uniforms.add(new l(\"shadowMapMatrix\",((e,a)=>a.shadowMap.getShadowMapMatrices(e.origin)),4)),f(e,a))}function v(e,a){a.receiveShadows&&(e.fragment.uniforms.add(new d(\"shadowMapMatrix\",((e,a)=>a.shadowMap.getShadowMapMatrices(e.origin)),4)),f(e,a))}function f(e,i){const d=e.fragment;d.include(a),d.uniforms.add([...p(\"shadowMapTex\",((e,a)=>a.shadowMap.depthTexture),i.hasWebGL2Context?c.None:c.Size),new t(\"numCascades\",((e,a)=>a.shadowMap.numCascades)),new o(\"cascadeDistances\",((e,a)=>a.shadowMap.cascadeDistances))]),d.code.add(r`\n    int chooseCascade(float depth, out mat4 mat) {\n      vec4 distance = cascadeDistances;\n\n      // choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      return i;\n    }\n\n    vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n      return 0.5 * lv.xyz + vec3(0.5);\n    }\n\n    vec2 cascadeCoordinates(int i, vec3 lvpos) {\n      return vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n    }\n\n    float readShadowMapDepth(vec2 uv, sampler2D _depthTex) {\n      return rgba2float(texture2D(_depthTex, uv));\n    }\n\n    float posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {\n      return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;\n    }\n\n    float filterShadow(vec2 uv, vec3 lvpos, float textureSize, sampler2D _depthTex) {\n      float halfPixelSize = 0.5 / textureSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * textureSize);\n\n      float s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);\n      float s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);\n      float s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);\n      float s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      mat4 mat;\n      int i = chooseCascade(_linearDepth, mat);\n\n      if (i >= numCascades) { return 0.0; }\n\n      vec3 lvpos = lightSpacePosition(_vpos, mat);\n\n      // vertex completely outside? -> no shadow\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = cascadeCoordinates(i, lvpos);\n\n      vec2 textureSize = ${s(i,\"shadowMapTex\")};\n\n      return filterShadow(uv, lvpos, textureSize.x, shadowMapTex);\n    }\n  `)}export{n as ReadShadowMapBindParameters,v as ReadShadowMapDraw,h as ReadShadowMapPass};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}