{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { addVerticalOffset as e } from \"../attributes/VerticalOffset.glsl.js\";\nimport { HUDTransparentRenderStyle as t } from \"./HUDUniforms.js\";\nimport { ScreenSizePerspective as o, addScreenSizePerspectiveAlignment as a } from \"../util/ScreenSizePerspective.glsl.js\";\nimport { addProjViewLocalOrigin as i, addCameraPosition as r } from \"../util/View.glsl.js\";\nimport { Float4PassUniform as s } from \"../../shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as n } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as l } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as c } from \"../../shaderModules/Matrix4PassUniform.js\";\nimport { Texture2DPassUniform as f } from \"../../shaderModules/Texture2DPassUniform.js\";\nimport { VertexAttribute as d } from \"../../../lib/VertexAttribute.js\";\nvar p;\n\nfunction u(u, v) {\n  u.include(o), u.attributes.add(d.POSITION, \"vec3\"), u.attributes.add(d.NORMAL, \"vec3\"), u.attributes.add(d.AUXPOS1, \"vec4\");\n  const m = u.vertex;\n  i(u, v), r(m, v), m.uniforms.add([new s(\"viewport\", (e, t) => t.camera.fullViewport), new n(\"polygonOffset\", e => e.shaderPolygonOffset), new n(\"cameraGroundRelative\", (e, t) => t.camera.aboveGround ? 1 : -1), new n(\"renderTransparentlyOccludedHUD\", (e, o) => o.renderTransparentlyOccludedHUD === t.Occluded ? 1 : o.renderTransparentlyOccludedHUD === t.NotOccluded ? 0 : .75), new f(\"hudVisibilityTexture\", (e, t) => t.hudVisibilityTexture)]), v.hasVerticalOffset && e(m), m.constants.add(\"smallOffsetAngle\", \"float\", .984807753012208), m.code.add(l`struct ProjectHUDAux {\nvec3 posModel;\nvec3 posView;\nvec3 vnormal;\nfloat distanceToCamera;\nfloat absCosAngle;\n};`), m.code.add(l`float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\nfloat pointGroundSign = sign(pointGroundDistance);\nif (pointGroundSign == 0.0) {\npointGroundSign = cameraGroundRelative;\n}\nfloat groundRelative = cameraGroundRelative * pointGroundSign;\nif (polygonOffset > .0) {\nfloat cosAlpha = clamp(absCosAngle, 0.01, 1.0);\nfloat tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\nfloat factor = (1.0 - tanAlpha / viewport[2]);\nif (groundRelative > 0.0) {\nposView *= factor;\n}\nelse {\nposView /= factor;\n}\n}\nreturn groundRelative;\n}`), v.isDraped && !v.hasVerticalOffset || m.uniforms.add(new c(\"viewNormal\", (e, t) => t.camera.viewInverseTransposeMatrix)), v.isDraped || (m.uniforms.add(new n(\"perDistancePixelRatio\", (e, t) => Math.tan(t.camera.fovY / 2) / (t.camera.fullViewport[2] / 2))), m.code.add(l`void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\nfloat distanceToCamera = length(posView);\nfloat pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;\nvec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\nvec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\nposModel += modelOffset;\nposView += viewOffset;\n}`)), v.screenCenterOffsetUnitsEnabled === p.Screen && m.uniforms.add(new n(\"pixelRatio\", (e, t) => t.camera.pixelRatio)), v.hasScreenSizePerspective && a(m), m.code.add(l`\n    vec4 projectPositionHUD(out ProjectHUDAux aux) {\n      // centerOffset is in view space and is used to implement world size offsetting\n      // of labels with respect to objects. It also pulls the label towards the viewer\n      // so that the label is visible in front of the object.\n      vec3 centerOffset = auxpos1.xyz;\n\n      // The pointGroundDistance is the distance of the geometry to the ground and is\n      // negative if the point is below the ground, or positive if the point is above\n      // ground.\n      float pointGroundDistance = auxpos1.w;\n\n      aux.posModel = position;\n      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n      aux.vnormal = normal;\n      ${v.isDraped ? \"\" : \"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\"}\n\n      // Screen sized offset in world space, used for example for line callouts\n      // Note: keep this implementation in sync with the CPU implementation, see\n      //   - MaterialUtil.verticalOffsetAtDistance\n      //   - HUDMaterial.applyVerticalOffsetTransformation\n\n      aux.distanceToCamera = length(aux.posView);\n\n      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);\n      float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n\n      aux.absCosAngle = abs(cosAngle);\n\n      ${v.hasScreenSizePerspective && (v.hasVerticalOffset || v.screenCenterOffsetUnitsEnabled === p.Screen) ? \"vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\" : \"\"}\n\n      ${v.hasVerticalOffset ? v.hasScreenSizePerspective ? \"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\" : \"float verticalOffsetScreenHeight = verticalOffset.x;\" : \"\"}\n\n      ${v.hasVerticalOffset ? l`\n            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n            vec3 modelOffset = aux.vnormal * worldOffset;\n            aux.posModel += modelOffset;\n            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n            aux.posView += viewOffset;\n            // Since we elevate the object, we need to take that into account\n            // in the distance to ground\n            pointGroundDistance += worldOffset;` : \"\"}\n\n      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n\n      ${v.screenCenterOffsetUnitsEnabled !== p.Screen ? l`\n            // Apply x/y in view space, but z in screen space (i.e. along posView direction)\n            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n\n            // Same material all have same z != 0.0 condition so should not lead to\n            // branch fragmentation and will save a normalization if it's not needed\n            if (centerOffset.z != 0.0) {\n              aux.posView -= normalize(aux.posView) * centerOffset.z;\n            }\n          ` : \"\"}\n\n      vec4 posProj = proj * vec4(aux.posView, 1.0);\n\n      ${v.screenCenterOffsetUnitsEnabled === p.Screen ? v.hasScreenSizePerspective ? \"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\" : \"float centerOffsetY = centerOffset.y;\" : \"\"}\n\n      ${v.screenCenterOffsetUnitsEnabled === p.Screen ? \"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\" : \"\"}\n\n      // constant part of polygon offset emulation\n      posProj.z -= groundRelative * polygonOffset * posProj.w;\n      return posProj;\n    }\n  `), m.code.add(l`bool testVisibilityHUD(vec4 posProj) {\nvec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\nvec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\nif (renderTransparentlyOccludedHUD > 0.5) {\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;\n}\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n}`);\n}\n\n!function (e) {\n  e[e.World = 0] = \"World\", e[e.Screen = 1] = \"Screen\", e[e.COUNT = 2] = \"COUNT\";\n}(p || (p = {}));\nexport { u as HUD, p as HUDSpace };","map":{"version":3,"names":["addVerticalOffset","e","HUDTransparentRenderStyle","t","ScreenSizePerspective","o","addScreenSizePerspectiveAlignment","a","addProjViewLocalOrigin","i","addCameraPosition","r","Float4PassUniform","s","FloatPassUniform","n","glsl","l","Matrix4PassUniform","c","Texture2DPassUniform","f","VertexAttribute","d","p","u","v","include","attributes","add","POSITION","NORMAL","AUXPOS1","m","vertex","uniforms","camera","fullViewport","shaderPolygonOffset","aboveGround","renderTransparentlyOccludedHUD","Occluded","NotOccluded","hudVisibilityTexture","hasVerticalOffset","constants","code","isDraped","viewInverseTransposeMatrix","Math","tan","fovY","screenCenterOffsetUnitsEnabled","Screen","pixelRatio","hasScreenSizePerspective","World","COUNT","HUD","HUDSpace"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{addVerticalOffset as e}from\"../attributes/VerticalOffset.glsl.js\";import{HUDTransparentRenderStyle as t}from\"./HUDUniforms.js\";import{ScreenSizePerspective as o,addScreenSizePerspectiveAlignment as a}from\"../util/ScreenSizePerspective.glsl.js\";import{addProjViewLocalOrigin as i,addCameraPosition as r}from\"../util/View.glsl.js\";import{Float4PassUniform as s}from\"../../shaderModules/Float4PassUniform.js\";import{FloatPassUniform as n}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as l}from\"../../shaderModules/interfaces.js\";import{Matrix4PassUniform as c}from\"../../shaderModules/Matrix4PassUniform.js\";import{Texture2DPassUniform as f}from\"../../shaderModules/Texture2DPassUniform.js\";import{VertexAttribute as d}from\"../../../lib/VertexAttribute.js\";var p;function u(u,v){u.include(o),u.attributes.add(d.POSITION,\"vec3\"),u.attributes.add(d.NORMAL,\"vec3\"),u.attributes.add(d.AUXPOS1,\"vec4\");const m=u.vertex;i(u,v),r(m,v),m.uniforms.add([new s(\"viewport\",((e,t)=>t.camera.fullViewport)),new n(\"polygonOffset\",(e=>e.shaderPolygonOffset)),new n(\"cameraGroundRelative\",((e,t)=>t.camera.aboveGround?1:-1)),new n(\"renderTransparentlyOccludedHUD\",((e,o)=>o.renderTransparentlyOccludedHUD===t.Occluded?1:o.renderTransparentlyOccludedHUD===t.NotOccluded?0:.75)),new f(\"hudVisibilityTexture\",((e,t)=>t.hudVisibilityTexture))]),v.hasVerticalOffset&&e(m),m.constants.add(\"smallOffsetAngle\",\"float\",.984807753012208),m.code.add(l`struct ProjectHUDAux {\nvec3 posModel;\nvec3 posView;\nvec3 vnormal;\nfloat distanceToCamera;\nfloat absCosAngle;\n};`),m.code.add(l`float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\nfloat pointGroundSign = sign(pointGroundDistance);\nif (pointGroundSign == 0.0) {\npointGroundSign = cameraGroundRelative;\n}\nfloat groundRelative = cameraGroundRelative * pointGroundSign;\nif (polygonOffset > .0) {\nfloat cosAlpha = clamp(absCosAngle, 0.01, 1.0);\nfloat tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\nfloat factor = (1.0 - tanAlpha / viewport[2]);\nif (groundRelative > 0.0) {\nposView *= factor;\n}\nelse {\nposView /= factor;\n}\n}\nreturn groundRelative;\n}`),v.isDraped&&!v.hasVerticalOffset||m.uniforms.add(new c(\"viewNormal\",((e,t)=>t.camera.viewInverseTransposeMatrix))),v.isDraped||(m.uniforms.add(new n(\"perDistancePixelRatio\",((e,t)=>Math.tan(t.camera.fovY/2)/(t.camera.fullViewport[2]/2)))),m.code.add(l`void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\nfloat distanceToCamera = length(posView);\nfloat pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;\nvec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\nvec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\nposModel += modelOffset;\nposView += viewOffset;\n}`)),v.screenCenterOffsetUnitsEnabled===p.Screen&&m.uniforms.add(new n(\"pixelRatio\",((e,t)=>t.camera.pixelRatio))),v.hasScreenSizePerspective&&a(m),m.code.add(l`\n    vec4 projectPositionHUD(out ProjectHUDAux aux) {\n      // centerOffset is in view space and is used to implement world size offsetting\n      // of labels with respect to objects. It also pulls the label towards the viewer\n      // so that the label is visible in front of the object.\n      vec3 centerOffset = auxpos1.xyz;\n\n      // The pointGroundDistance is the distance of the geometry to the ground and is\n      // negative if the point is below the ground, or positive if the point is above\n      // ground.\n      float pointGroundDistance = auxpos1.w;\n\n      aux.posModel = position;\n      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n      aux.vnormal = normal;\n      ${v.isDraped?\"\":\"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\"}\n\n      // Screen sized offset in world space, used for example for line callouts\n      // Note: keep this implementation in sync with the CPU implementation, see\n      //   - MaterialUtil.verticalOffsetAtDistance\n      //   - HUDMaterial.applyVerticalOffsetTransformation\n\n      aux.distanceToCamera = length(aux.posView);\n\n      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);\n      float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n\n      aux.absCosAngle = abs(cosAngle);\n\n      ${v.hasScreenSizePerspective&&(v.hasVerticalOffset||v.screenCenterOffsetUnitsEnabled===p.Screen)?\"vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\":\"\"}\n\n      ${v.hasVerticalOffset?v.hasScreenSizePerspective?\"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\":\"float verticalOffsetScreenHeight = verticalOffset.x;\":\"\"}\n\n      ${v.hasVerticalOffset?l`\n            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n            vec3 modelOffset = aux.vnormal * worldOffset;\n            aux.posModel += modelOffset;\n            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n            aux.posView += viewOffset;\n            // Since we elevate the object, we need to take that into account\n            // in the distance to ground\n            pointGroundDistance += worldOffset;`:\"\"}\n\n      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n\n      ${v.screenCenterOffsetUnitsEnabled!==p.Screen?l`\n            // Apply x/y in view space, but z in screen space (i.e. along posView direction)\n            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n\n            // Same material all have same z != 0.0 condition so should not lead to\n            // branch fragmentation and will save a normalization if it's not needed\n            if (centerOffset.z != 0.0) {\n              aux.posView -= normalize(aux.posView) * centerOffset.z;\n            }\n          `:\"\"}\n\n      vec4 posProj = proj * vec4(aux.posView, 1.0);\n\n      ${v.screenCenterOffsetUnitsEnabled===p.Screen?v.hasScreenSizePerspective?\"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\":\"float centerOffsetY = centerOffset.y;\":\"\"}\n\n      ${v.screenCenterOffsetUnitsEnabled===p.Screen?\"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\":\"\"}\n\n      // constant part of polygon offset emulation\n      posProj.z -= groundRelative * polygonOffset * posProj.w;\n      return posProj;\n    }\n  `),m.code.add(l`bool testVisibilityHUD(vec4 posProj) {\nvec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\nvec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\nif (renderTransparentlyOccludedHUD > 0.5) {\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;\n}\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n}`)}!function(e){e[e.World=0]=\"World\",e[e.Screen=1]=\"Screen\",e[e.COUNT=2]=\"COUNT\"}(p||(p={}));export{u as HUD,p as HUDSpace};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}