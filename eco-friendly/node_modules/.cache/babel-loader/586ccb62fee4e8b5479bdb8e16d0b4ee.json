{"ast":null,"code":"import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\nlet dtfCache = {};\n\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\"\n    });\n  }\n\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n        parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n        [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n\n  for (let i = 0; i < formatted.length; i++) {\n    const {\n      type,\n      value\n    } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\n\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n\n    return ianaZoneCache[name];\n  }\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n\n\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\n   * @return {boolean}\n   */\n\n\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n\n\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n\n    try {\n      new Intl.DateTimeFormat(\"en-US\", {\n        timeZone: zone\n      }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n\n    this.zoneName = name;\n    /** @private **/\n\n    this.valid = IANAZone.isValidZone(name);\n  }\n  /** @override **/\n\n\n  get type() {\n    return \"iana\";\n  }\n  /** @override **/\n\n\n  get name() {\n    return this.zoneName;\n  }\n  /** @override **/\n\n\n  get isUniversal() {\n    return false;\n  }\n  /** @override **/\n\n\n  offsetName(ts, {\n    format,\n    locale\n  }) {\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n  /** @override **/\n\n\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n  /** @override **/\n\n\n  offset(ts) {\n    const date = new Date(ts);\n    if (isNaN(date)) return NaN;\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    } // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n\n\n    const adjustedHour = hour === 24 ? 0 : hour;\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0\n    });\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n  /** @override **/\n\n\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n  /** @override **/\n\n\n  get isValid() {\n    return this.valid;\n  }\n\n}","map":{"version":3,"names":["formatOffset","parseZoneInfo","isUndefined","objToLocalTS","Zone","dtfCache","makeDTF","zone","Intl","DateTimeFormat","hour12","timeZone","year","month","day","hour","minute","second","era","typeToPos","hackyOffset","dtf","date","formatted","format","replace","parsed","exec","fMonth","fDay","fYear","fadOrBc","fHour","fMinute","fSecond","partsOffset","formatToParts","filled","i","length","type","value","pos","parseInt","ianaZoneCache","IANAZone","create","name","resetCache","isValidSpecifier","s","isValidZone","e","constructor","zoneName","valid","isUniversal","offsetName","ts","locale","offset","Date","isNaN","NaN","adOrBc","Math","abs","adjustedHour","asUTC","millisecond","asTS","over","equals","otherZone","isValid"],"sources":["E:/各个学科/论文/毕业论文/Atmosphere/eco-friendly/node_modules/luxon/src/zones/IANAZone.js"],"sourcesContent":["import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\n\nlet dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\",\n    });\n  }\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6,\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n    return ianaZoneCache[name];\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /** @override **/\n  get type() {\n    return \"iana\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    const date = new Date(ts);\n\n    if (isNaN(date)) return NaN;\n\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\n      ? partsOffset(dtf, date)\n      : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0,\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /** @override **/\n  get isValid() {\n    return this.valid;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}