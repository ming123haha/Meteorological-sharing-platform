{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { unwrapOr as e } from \"../core/maybe.js\";\nimport { ShaderOutput as t } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js\";\nimport { SliceDraw as i } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { RibbonVertexPosition as o } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";\nimport { OutputDepth as n } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { LineStipple as r } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js\";\nimport { multipassTerrainTest as a } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { PiUtils as s } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js\";\nimport { symbolAlphaCutoff as l } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { ColorConversion as p } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { addProjViewLocalOrigin as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float2PassUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as v } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as h } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { TransparencyPassType as u } from \"../views/3d/webgl-engine/lib/basicInterfaces.js\";\nimport { VertexAttribute as D } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { CapType as S } from \"../views/3d/webgl-engine/shaders/RibbonLineTechniqueConfiguration.js\";\nconst x = 1;\n\nfunction b(b) {\n  const L = new h(),\n        w = b.hasMultipassTerrain && (b.output === t.Color || b.output === t.Alpha);\n  L.include(s), L.include(o, b), L.include(r, b), b.output === t.Depth && L.include(n, b), d(L, b);\n  const {\n    vertex: y,\n    fragment: C\n  } = L;\n  y.uniforms.add([new f(\"inverseProjectionMatrix\", (e, t) => t.camera.inverseProjectionMatrix), new c(\"nearFar\", (e, t) => t.camera.nearFar), new m(\"miterLimit\", e => \"miter\" !== e.join ? 0 : e.miterLimit), new g(\"viewport\", (e, t) => t.camera.fullViewport)]), y.constants.add(\"LARGE_HALF_FLOAT\", \"float\", 65500), L.attributes.add(D.POSITION, \"vec3\"), L.attributes.add(D.SUBDIVISIONFACTOR, \"float\"), L.attributes.add(D.UV0, \"vec2\"), L.attributes.add(D.AUXPOS1, \"vec3\"), L.attributes.add(D.AUXPOS2, \"vec3\"), L.varyings.add(\"vColor\", \"vec4\"), L.varyings.add(\"vpos\", \"vec3\"), L.varyings.add(\"linearDepth\", \"float\"), w && L.varyings.add(\"depth\", \"float\");\n  const j = b.capType === S.ROUND,\n        R = b.stippleEnabled && b.stippleScaleWithLineWidth || j;\n  R && L.varyings.add(\"vLineWidth\", \"float\");\n  const A = b.stippleEnabled && b.stippleScaleWithLineWidth;\n  A && L.varyings.add(\"vLineSizeInv\", \"float\");\n  const F = b.innerColorEnabled || j;\n  F && L.varyings.add(\"vLineDistance\", \"float\");\n  const P = b.stippleEnabled && j,\n        E = b.falloffEnabled || P;\n  E && L.varyings.add(\"vLineDistanceNorm\", \"float\"), j && (L.varyings.add(\"vSegmentSDF\", \"float\"), L.varyings.add(\"vReverseSegmentSDF\", \"float\")), y.code.add(v`#define PERPENDICULAR(v) vec2(v.y, -v.x);\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}\nvec2 rotate(vec2 v, float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, -s, s, c);\nreturn m * v;\n}`), y.code.add(v`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`), y.code.add(v`\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = nearFar[0] * 0.99;\n\n      if(pos.z > -nearFar[0]) {\n        //current pos behind ncp --> we need to clip\n        if (!isStartVertex) {\n          if(prev.z < -nearFar[0]) {\n            //previous in front of ncp\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        } else {\n          if(next.z < -nearFar[0]) {\n            //next in front of ncp\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        if (prev.z > -nearFar[0]) {\n          //previous behind ncp\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        if (next.z > -nearFar[0]) {\n          //next behind ncp\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      ${w ? \"depth = pos.z;\" : \"\"}\n      linearDepth = (-pos.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n  `), y.uniforms.add(new m(\"pixelRatio\", (e, t) => t.camera.pixelRatio)), y.code.add(v`\n  void main(void) {\n    // unpack values from uv0.y\n    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n\n    float coverage = 1.0;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isJoin = abs(uv0.y) < 3.0;\n\n      float lineSize = getSize();\n      float lineWidth = lineSize * pixelRatio;\n\n      ${R ? v`vLineWidth = lineWidth;` : \"\"}\n      ${A ? v`vLineSizeInv = 1.0 / lineSize;` : \"\"}\n\n      // convert sub-pixel coverage to alpha\n      if (lineWidth < 1.0) {\n        coverage = lineWidth;\n        lineWidth = 1.0;\n      }else{\n        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if\n        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly\n        // so we only really care to round anything larger than 1.\n        lineWidth = floor(lineWidth + 0.5);\n      }\n\n      vec4 pos  = view * vec4(position.xyz, 1.0);\n      vec4 prev = view * vec4(auxpos1.xyz, 1.0);\n      vec4 next = view * vec4(auxpos2.xyz, 1.0);\n\n      clipAndTransform(pos, prev, next, isStartVertex);\n\n      vec2 left = (pos.xy - prev.xy);\n      vec2 right = (next.xy - pos.xy);\n\n      float leftLen = length(left);\n      float rightLen = length(right);\n  `);\n  (b.stippleEnabled || j) && y.code.add(v`\n      float isEndVertex = float(!isStartVertex);\n      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);\n      vec2 segment = mix(right, left, isEndVertex);\n      ${j ? v`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);` : \"\"}\n    `), y.code.add(v`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\nright = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\nvec2 capDisplacementDir = vec2(0, 0);\nvec2 joinDisplacementDir = vec2(0, 0);\nfloat displacementLen = lineWidth;\nif (isJoin) {\nbool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;\njoinDisplacementDir = normalize(left + right);\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\nif (leftLen > 0.001 && rightLen > 0.001) {\nfloat nDotSeg = dot(joinDisplacementDir, left);\ndisplacementLen /= length(nDotSeg * left - joinDisplacementDir);\nif (!isOutside) {\ndisplacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n}\n}\nif (isOutside && (displacementLen > miterLimit * lineWidth)) {`), b.roundJoins ? y.code.add(v`\n        vec2 startDir = leftLen < 0.001 ? right : left;\n        startDir = PERPENDICULAR(startDir);\n\n        vec2 endDir = rightLen < 0.001 ? left : right;\n        endDir = PERPENDICULAR(endDir);\n\n        float factor = ${b.stippleEnabled ? v`min(1.0, subdivisionFactor * ${v.float((x + 2) / (x + 1))})` : v`subdivisionFactor`};\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);\n      `) : y.code.add(v`if (leftLen < 0.001) {\njoinDisplacementDir = right;\n}\nelse if (rightLen < 0.001) {\njoinDisplacementDir = left;\n}\nelse {\njoinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;\n}\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);\n  const T = b.capType !== S.BUTT;\n  return y.code.add(v`\n        displacementLen = lineWidth;\n      }\n    } else {\n      // CAP handling ---------------------------------------------------\n      joinDisplacementDir = isStartVertex ? right : left;\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n\n      ${T ? v`capDisplacementDir = isStartVertex ? -right : left;` : \"\"}\n    }\n  `), y.code.add(v`\n    // Displacement (in pixels) caused by join/or cap\n    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;\n\n    ${E || F ? v`float lineDistNorm = sign(uv0.y) * pos.w;` : \"\"}\n\n    ${F ? v`vLineDistance = lineWidth * lineDistNorm;` : \"\"}\n    ${E ? v`vLineDistanceNorm = lineDistNorm;` : \"\"}\n\n    pos.xy += dpos;\n  `), j && y.code.add(v`vec2 segmentDir = normalize(segment);\nvSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;\nvReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`), b.stippleEnabled && (b.draped ? y.uniforms.add(new m(\"worldToScreenRatio\", (e, t) => 1 / t.screenToPCSRatio)) : y.code.add(v`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);\nfloat worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`), y.code.add(v`float segmentLengthScreenDouble = length(segment);\nfloat segmentLengthScreen = segmentLengthScreenDouble * 0.5;\nfloat discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);\nfloat segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));\nvStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`), b.draped ? y.code.add(v`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;\nfloat startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`) : y.code.add(v`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;\nfloat segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`), y.code.add(v`\n      float patternLength = ${b.stippleScaleWithLineWidth ? \"lineSize * \" : \"\"} stipplePatternPixelSize;\n\n      // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader\n      vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);\n\n      vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);\n\n      // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)\n      if (segmentLengthScreenDouble >= 0.001) {\n        // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the\n        // original vertex positions, and slightly outside of that range at the displaced positions\n        vec2 stippleDisplacement = pos.xy - segmentOrigin;\n        float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);\n\n        // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)\n        vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);\n      }\n\n      // Cancel out perspective correct interpolation because we want this length the really represent the screen distance\n      vStippleDistanceLimits *= pos.w;\n      vStippleDistance *= pos.w;\n\n      // Disable stipple distance limits on caps\n      vStippleDistanceLimits = isJoin ?\n                                 vStippleDistanceLimits :\n                                 isStartVertex ?\n                                  vec2(-1e038, vStippleDistanceLimits.y) :\n                                  vec2(vStippleDistanceLimits.x, 1e038);\n    `)), y.code.add(v`\n      // Convert back into NDC\n      pos.xy = (pos.xy / viewport.zw) * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      ${b.wireframe && !b.draped ? \"pos.z -= 0.001 * pos.w;\" : \"\"}\n\n      // transform final position to camera space for slicing\n      vpos = (inverseProjectionMatrix * pos).xyz;\n      gl_Position = pos;\n    }\n  }\n  `), w && L.include(a, b), L.include(i, b), C.include(p), C.code.add(v`\n  void main() {\n    discardBySlice(vpos);\n    ${w ? \"terrainDepthTest(gl_FragCoord, depth);\" : \"\"}\n  `), b.wireframe ? C.code.add(v`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`) : (j && C.code.add(v`\n      float sdf = min(vSegmentSDF, vReverseSegmentSDF);\n      vec2 fragmentPosition = vec2(\n        min(sdf, 0.0),\n        vLineDistance\n      ) * gl_FragCoord.w;\n\n      float fragmentRadius = length(fragmentPosition);\n      float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n      float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);\n\n      if (capCoverage < ${v.float(l)}) {\n        discard;\n      }\n    `), P ? C.code.add(v`\n      vec2 stipplePosition = vec2(\n        min(getStippleSDF() * 2.0 - 1.0, 0.0),\n        vLineDistanceNorm * gl_FragCoord.w\n      );\n      float stippleRadius = length(stipplePosition * vLineWidth);\n      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);\n      float stippleAlpha = step(${v.float(l)}, stippleCoverage);\n      `) : C.code.add(v`float stippleAlpha = getStippleAlpha();`), C.uniforms.add(new g(\"intrinsicColor\", e => e.color)), C.code.add(v`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);\nvec4 color = intrinsicColor * vColor;`), b.innerColorEnabled && (C.uniforms.add(new g(\"innerColor\", t => e(t.innerColor, t.color))), C.uniforms.add(new m(\"innerWidth\", (e, t) => e.innerWidth * t.camera.pixelRatio)), C.code.add(v`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;\nfloat innerAA = clamp(0.5 - distToInner, 0.0, 1.0);\nfloat innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);\ncolor = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)), C.code.add(v`vec4 finalColor = blendStipple(color, stippleAlpha);`), b.falloffEnabled && (C.uniforms.add(new m(\"falloff\", e => e.falloff)), C.code.add(v`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`))), C.code.add(v`\n    if (finalColor.a < ${v.float(l)}) {\n      discard;\n    }\n\n    ${b.output === t.Alpha ? v`gl_FragColor = vec4(finalColor.a);` : \"\"}\n    ${b.output === t.Color ? v`gl_FragColor = highlightSlice(finalColor, vpos);` : \"\"}\n    ${b.output === t.Color && b.transparencyPassType === u.Color ? \"gl_FragColor = premultiplyAlpha(gl_FragColor);\" : \"\"}\n    ${b.output === t.Highlight ? v`gl_FragColor = vec4(1.0);` : \"\"}\n    ${b.output === t.Depth ? v`outputDepth(linearDepth);` : \"\"}\n  }\n  `), L;\n}\n\nconst L = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  NUM_ROUND_JOIN_SUBDIVISIONS: x,\n  build: b\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { x as N, L as R, b };","map":{"version":3,"names":["unwrapOr","e","ShaderOutput","t","SliceDraw","i","RibbonVertexPosition","o","OutputDepth","n","LineStipple","r","multipassTerrainTest","a","PiUtils","s","symbolAlphaCutoff","l","ColorConversion","p","addProjViewLocalOrigin","d","Float2PassUniform","c","Float4PassUniform","g","FloatPassUniform","m","glsl","v","Matrix4PassUniform","f","ShaderBuilder","h","TransparencyPassType","u","VertexAttribute","D","CapType","S","x","b","L","w","hasMultipassTerrain","output","Color","Alpha","include","Depth","vertex","y","fragment","C","uniforms","add","camera","inverseProjectionMatrix","nearFar","join","miterLimit","fullViewport","constants","attributes","POSITION","SUBDIVISIONFACTOR","UV0","AUXPOS1","AUXPOS2","varyings","j","capType","ROUND","R","stippleEnabled","stippleScaleWithLineWidth","A","F","innerColorEnabled","P","E","falloffEnabled","code","pixelRatio","roundJoins","float","T","BUTT","draped","screenToPCSRatio","wireframe","color","innerColor","innerWidth","falloff","transparencyPassType","Highlight","Object","freeze","defineProperty","__proto__","NUM_ROUND_JOIN_SUBDIVISIONS","build","Symbol","toStringTag","value","N"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/chunks/RibbonLine.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{unwrapOr as e}from\"../core/maybe.js\";import{ShaderOutput as t}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js\";import{SliceDraw as i}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{RibbonVertexPosition as o}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";import{OutputDepth as n}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{LineStipple as r}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js\";import{multipassTerrainTest as a}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{PiUtils as s}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js\";import{symbolAlphaCutoff as l}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";import{ColorConversion as p}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{addProjViewLocalOrigin as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float2PassUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as v}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as h}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{TransparencyPassType as u}from\"../views/3d/webgl-engine/lib/basicInterfaces.js\";import{VertexAttribute as D}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{CapType as S}from\"../views/3d/webgl-engine/shaders/RibbonLineTechniqueConfiguration.js\";const x=1;function b(b){const L=new h,w=b.hasMultipassTerrain&&(b.output===t.Color||b.output===t.Alpha);L.include(s),L.include(o,b),L.include(r,b),b.output===t.Depth&&L.include(n,b),d(L,b);const{vertex:y,fragment:C}=L;y.uniforms.add([new f(\"inverseProjectionMatrix\",((e,t)=>t.camera.inverseProjectionMatrix)),new c(\"nearFar\",((e,t)=>t.camera.nearFar)),new m(\"miterLimit\",(e=>\"miter\"!==e.join?0:e.miterLimit)),new g(\"viewport\",((e,t)=>t.camera.fullViewport))]),y.constants.add(\"LARGE_HALF_FLOAT\",\"float\",65500),L.attributes.add(D.POSITION,\"vec3\"),L.attributes.add(D.SUBDIVISIONFACTOR,\"float\"),L.attributes.add(D.UV0,\"vec2\"),L.attributes.add(D.AUXPOS1,\"vec3\"),L.attributes.add(D.AUXPOS2,\"vec3\"),L.varyings.add(\"vColor\",\"vec4\"),L.varyings.add(\"vpos\",\"vec3\"),L.varyings.add(\"linearDepth\",\"float\"),w&&L.varyings.add(\"depth\",\"float\");const j=b.capType===S.ROUND,R=b.stippleEnabled&&b.stippleScaleWithLineWidth||j;R&&L.varyings.add(\"vLineWidth\",\"float\");const A=b.stippleEnabled&&b.stippleScaleWithLineWidth;A&&L.varyings.add(\"vLineSizeInv\",\"float\");const F=b.innerColorEnabled||j;F&&L.varyings.add(\"vLineDistance\",\"float\");const P=b.stippleEnabled&&j,E=b.falloffEnabled||P;E&&L.varyings.add(\"vLineDistanceNorm\",\"float\"),j&&(L.varyings.add(\"vSegmentSDF\",\"float\"),L.varyings.add(\"vReverseSegmentSDF\",\"float\")),y.code.add(v`#define PERPENDICULAR(v) vec2(v.y, -v.x);\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}\nvec2 rotate(vec2 v, float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, -s, s, c);\nreturn m * v;\n}`),y.code.add(v`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`),y.code.add(v`\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = nearFar[0] * 0.99;\n\n      if(pos.z > -nearFar[0]) {\n        //current pos behind ncp --> we need to clip\n        if (!isStartVertex) {\n          if(prev.z < -nearFar[0]) {\n            //previous in front of ncp\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        } else {\n          if(next.z < -nearFar[0]) {\n            //next in front of ncp\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        if (prev.z > -nearFar[0]) {\n          //previous behind ncp\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        if (next.z > -nearFar[0]) {\n          //next behind ncp\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      ${w?\"depth = pos.z;\":\"\"}\n      linearDepth = (-pos.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n  `),y.uniforms.add(new m(\"pixelRatio\",((e,t)=>t.camera.pixelRatio))),y.code.add(v`\n  void main(void) {\n    // unpack values from uv0.y\n    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n\n    float coverage = 1.0;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isJoin = abs(uv0.y) < 3.0;\n\n      float lineSize = getSize();\n      float lineWidth = lineSize * pixelRatio;\n\n      ${R?v`vLineWidth = lineWidth;`:\"\"}\n      ${A?v`vLineSizeInv = 1.0 / lineSize;`:\"\"}\n\n      // convert sub-pixel coverage to alpha\n      if (lineWidth < 1.0) {\n        coverage = lineWidth;\n        lineWidth = 1.0;\n      }else{\n        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if\n        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly\n        // so we only really care to round anything larger than 1.\n        lineWidth = floor(lineWidth + 0.5);\n      }\n\n      vec4 pos  = view * vec4(position.xyz, 1.0);\n      vec4 prev = view * vec4(auxpos1.xyz, 1.0);\n      vec4 next = view * vec4(auxpos2.xyz, 1.0);\n\n      clipAndTransform(pos, prev, next, isStartVertex);\n\n      vec2 left = (pos.xy - prev.xy);\n      vec2 right = (next.xy - pos.xy);\n\n      float leftLen = length(left);\n      float rightLen = length(right);\n  `);(b.stippleEnabled||j)&&y.code.add(v`\n      float isEndVertex = float(!isStartVertex);\n      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);\n      vec2 segment = mix(right, left, isEndVertex);\n      ${j?v`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:\"\"}\n    `),y.code.add(v`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\nright = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\nvec2 capDisplacementDir = vec2(0, 0);\nvec2 joinDisplacementDir = vec2(0, 0);\nfloat displacementLen = lineWidth;\nif (isJoin) {\nbool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;\njoinDisplacementDir = normalize(left + right);\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\nif (leftLen > 0.001 && rightLen > 0.001) {\nfloat nDotSeg = dot(joinDisplacementDir, left);\ndisplacementLen /= length(nDotSeg * left - joinDisplacementDir);\nif (!isOutside) {\ndisplacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n}\n}\nif (isOutside && (displacementLen > miterLimit * lineWidth)) {`),b.roundJoins?y.code.add(v`\n        vec2 startDir = leftLen < 0.001 ? right : left;\n        startDir = PERPENDICULAR(startDir);\n\n        vec2 endDir = rightLen < 0.001 ? left : right;\n        endDir = PERPENDICULAR(endDir);\n\n        float factor = ${b.stippleEnabled?v`min(1.0, subdivisionFactor * ${v.float((x+2)/(x+1))})`:v`subdivisionFactor`};\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);\n      `):y.code.add(v`if (leftLen < 0.001) {\njoinDisplacementDir = right;\n}\nelse if (rightLen < 0.001) {\njoinDisplacementDir = left;\n}\nelse {\njoinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;\n}\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);const T=b.capType!==S.BUTT;return y.code.add(v`\n        displacementLen = lineWidth;\n      }\n    } else {\n      // CAP handling ---------------------------------------------------\n      joinDisplacementDir = isStartVertex ? right : left;\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n\n      ${T?v`capDisplacementDir = isStartVertex ? -right : left;`:\"\"}\n    }\n  `),y.code.add(v`\n    // Displacement (in pixels) caused by join/or cap\n    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;\n\n    ${E||F?v`float lineDistNorm = sign(uv0.y) * pos.w;`:\"\"}\n\n    ${F?v`vLineDistance = lineWidth * lineDistNorm;`:\"\"}\n    ${E?v`vLineDistanceNorm = lineDistNorm;`:\"\"}\n\n    pos.xy += dpos;\n  `),j&&y.code.add(v`vec2 segmentDir = normalize(segment);\nvSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;\nvReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),b.stippleEnabled&&(b.draped?y.uniforms.add(new m(\"worldToScreenRatio\",((e,t)=>1/t.screenToPCSRatio))):y.code.add(v`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);\nfloat worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),y.code.add(v`float segmentLengthScreenDouble = length(segment);\nfloat segmentLengthScreen = segmentLengthScreenDouble * 0.5;\nfloat discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);\nfloat segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));\nvStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),b.draped?y.code.add(v`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;\nfloat startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`):y.code.add(v`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;\nfloat segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),y.code.add(v`\n      float patternLength = ${b.stippleScaleWithLineWidth?\"lineSize * \":\"\"} stipplePatternPixelSize;\n\n      // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader\n      vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);\n\n      vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);\n\n      // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)\n      if (segmentLengthScreenDouble >= 0.001) {\n        // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the\n        // original vertex positions, and slightly outside of that range at the displaced positions\n        vec2 stippleDisplacement = pos.xy - segmentOrigin;\n        float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);\n\n        // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)\n        vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);\n      }\n\n      // Cancel out perspective correct interpolation because we want this length the really represent the screen distance\n      vStippleDistanceLimits *= pos.w;\n      vStippleDistance *= pos.w;\n\n      // Disable stipple distance limits on caps\n      vStippleDistanceLimits = isJoin ?\n                                 vStippleDistanceLimits :\n                                 isStartVertex ?\n                                  vec2(-1e038, vStippleDistanceLimits.y) :\n                                  vec2(vStippleDistanceLimits.x, 1e038);\n    `)),y.code.add(v`\n      // Convert back into NDC\n      pos.xy = (pos.xy / viewport.zw) * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      ${b.wireframe&&!b.draped?\"pos.z -= 0.001 * pos.w;\":\"\"}\n\n      // transform final position to camera space for slicing\n      vpos = (inverseProjectionMatrix * pos).xyz;\n      gl_Position = pos;\n    }\n  }\n  `),w&&L.include(a,b),L.include(i,b),C.include(p),C.code.add(v`\n  void main() {\n    discardBySlice(vpos);\n    ${w?\"terrainDepthTest(gl_FragCoord, depth);\":\"\"}\n  `),b.wireframe?C.code.add(v`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(j&&C.code.add(v`\n      float sdf = min(vSegmentSDF, vReverseSegmentSDF);\n      vec2 fragmentPosition = vec2(\n        min(sdf, 0.0),\n        vLineDistance\n      ) * gl_FragCoord.w;\n\n      float fragmentRadius = length(fragmentPosition);\n      float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n      float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);\n\n      if (capCoverage < ${v.float(l)}) {\n        discard;\n      }\n    `),P?C.code.add(v`\n      vec2 stipplePosition = vec2(\n        min(getStippleSDF() * 2.0 - 1.0, 0.0),\n        vLineDistanceNorm * gl_FragCoord.w\n      );\n      float stippleRadius = length(stipplePosition * vLineWidth);\n      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);\n      float stippleAlpha = step(${v.float(l)}, stippleCoverage);\n      `):C.code.add(v`float stippleAlpha = getStippleAlpha();`),C.uniforms.add(new g(\"intrinsicColor\",(e=>e.color))),C.code.add(v`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);\nvec4 color = intrinsicColor * vColor;`),b.innerColorEnabled&&(C.uniforms.add(new g(\"innerColor\",(t=>e(t.innerColor,t.color)))),C.uniforms.add(new m(\"innerWidth\",((e,t)=>e.innerWidth*t.camera.pixelRatio))),C.code.add(v`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;\nfloat innerAA = clamp(0.5 - distToInner, 0.0, 1.0);\nfloat innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);\ncolor = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),C.code.add(v`vec4 finalColor = blendStipple(color, stippleAlpha);`),b.falloffEnabled&&(C.uniforms.add(new m(\"falloff\",(e=>e.falloff))),C.code.add(v`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`))),C.code.add(v`\n    if (finalColor.a < ${v.float(l)}) {\n      discard;\n    }\n\n    ${b.output===t.Alpha?v`gl_FragColor = vec4(finalColor.a);`:\"\"}\n    ${b.output===t.Color?v`gl_FragColor = highlightSlice(finalColor, vpos);`:\"\"}\n    ${b.output===t.Color&&b.transparencyPassType===u.Color?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}\n    ${b.output===t.Highlight?v`gl_FragColor = vec4(1.0);`:\"\"}\n    ${b.output===t.Depth?v`outputDepth(linearDepth);`:\"\"}\n  }\n  `),L}const L=Object.freeze(Object.defineProperty({__proto__:null,NUM_ROUND_JOIN_SUBDIVISIONS:x,build:b},Symbol.toStringTag,{value:\"Module\"}));export{x as N,L as R,b};\n"],"mappings":"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CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACjB;AACA;AACA;AACA,EAJI,CAT2gG,EAa3gGsB,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQc,CAAC,GAAC,gBAAD,GAAkB,EAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,GA1CI,CAb2gG,EAuD1gGQ,CAAC,CAACG,QAAF,CAAWC,GAAX,CAAe,IAAI5B,CAAJ,CAAM,YAAN,EAAoB,CAAC1B,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAACqD,MAAF,CAAS2B,UAApC,CAAf,CAvD0gG,EAuDz8FhC,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ4C,CAAC,GAAC5C,CAAE,yBAAH,GAA4B,EAAG;AACxC,QAAQ+C,CAAC,GAAC/C,CAAE,gCAAH,GAAmC,EAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GA7CsE,CAvDy8F;EAoG1gG,CAACY,CAAC,CAACiC,cAAF,IAAkBJ,CAAnB,KAAuBnB,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACzC;AACA;AACA;AACA,QAAQyC,CAAC,GAACzC,CAAE,sDAAH,GAAyD,EAAG;AACrE,KAL4B,CAAvB,EAKEsB,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAhBO,CALF,EAqB4DY,CAAC,CAAC2C,UAAF,GAAajC,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyBY,CAAC,CAACiC,cAAF,GAAiB7C,CAAE,gCAA+BA,CAAC,CAACwD,KAAF,CAAQ,CAAC7C,CAAC,GAAC,CAAH,KAAOA,CAAC,GAAC,CAAT,CAAR,CAAqB,GAAvE,GAA0EX,CAAE,mBAAmB;AACxH;AACA;AACA;AACA,OAX8E,CAAb,GAWxDsB,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DATS,CAhCJ;EAyCuD,MAAMyD,CAAC,GAAC7C,CAAC,CAAC8B,OAAF,KAAYhC,CAAC,CAACgD,IAAtB;EAA2B,OAAOpC,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQyD,CAAC,GAACzD,CAAE,qDAAH,GAAwD,EAAG;AACpE;AACA,GAV8F,GAUzFsB,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAClB;AACA;AACA;AACA,MAAMmD,CAAC,IAAEH,CAAH,GAAKhD,CAAE,2CAAP,GAAkD,EAAG;AAC3D;AACA,MAAMgD,CAAC,GAAChD,CAAE,2CAAH,GAA8C,EAAG;AACxD,MAAMmD,CAAC,GAACnD,CAAE,mCAAH,GAAsC,EAAG;AAChD;AACA;AACA,GAVK,CAVyF,EAoBzFyC,CAAC,IAAEnB,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACrB;AACA,sHAFQ,CApBsF,EAsB0BY,CAAC,CAACiC,cAAF,KAAmBjC,CAAC,CAAC+C,MAAF,GAASrC,CAAC,CAACG,QAAF,CAAWC,GAAX,CAAe,IAAI5B,CAAJ,CAAM,oBAAN,EAA4B,CAAC1B,CAAD,EAAGE,CAAH,KAAO,IAAEA,CAAC,CAACsF,gBAAvC,CAAf,CAAT,GAAmFtC,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAC3O,qEAD8N,CAAnF,EACpEsB,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACpF;AACA;AACA;AACA,0EAJuE,CADoE,EAK/DY,CAAC,CAAC+C,MAAF,GAASrC,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAClG,iHADqF,CAAT,GACuCsB,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAChI,oFADmH,CANwB,EAOrDsB,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACnG,8BAA8BY,CAAC,CAACkC,yBAAF,GAA4B,aAA5B,GAA0C,EAAG;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KA7BsF,CAPkC,CAtB1B,EA0DtFxB,CAAC,CAAC+B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQY,CAAC,CAACiD,SAAF,IAAa,CAACjD,CAAC,CAAC+C,MAAhB,GAAuB,yBAAvB,GAAiD,EAAG;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,GAdQ,CA1DsF,EAwEzF7C,CAAC,IAAED,CAAC,CAACM,OAAF,CAAUnC,CAAV,EAAY4B,CAAZ,CAxEsF,EAwEvEC,CAAC,CAACM,OAAF,CAAU3C,CAAV,EAAYoC,CAAZ,CAxEuE,EAwExDY,CAAC,CAACL,OAAF,CAAU7B,CAAV,CAxEwD,EAwE3CkC,CAAC,CAAC6B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAChE;AACA;AACA,MAAMc,CAAC,GAAC,wCAAD,GAA0C,EAAG;AACpD,GAJmD,CAxE2C,EA4EzFF,CAAC,CAACiD,SAAF,GAAYrC,CAAC,CAAC6B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE,6CAAb,CAAZ,IAAwEyC,CAAC,IAAEjB,CAAC,CAAC6B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0BA,CAAC,CAACwD,KAAF,CAAQpE,CAAR,CAAW;AACrC;AACA;AACA,KAdgF,CAAH,EActE8D,CAAC,GAAC1B,CAAC,CAAC6B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkCA,CAAC,CAACwD,KAAF,CAAQpE,CAAR,CAAW;AAC7C,OATS,CAAD,GASCoC,CAAC,CAAC6B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE,yCAAb,CAvBoE,EAuBbwB,CAAC,CAACC,QAAF,CAAWC,GAAX,CAAe,IAAI9B,CAAJ,CAAM,gBAAN,EAAwBxB,CAAC,IAAEA,CAAC,CAAC0F,KAA7B,CAAf,CAvBa,EAuBwCtC,CAAC,CAAC6B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAClI,sCADqH,CAvBxC,EAwBrCY,CAAC,CAACqC,iBAAF,KAAsBzB,CAAC,CAACC,QAAF,CAAWC,GAAX,CAAe,IAAI9B,CAAJ,CAAM,YAAN,EAAoBtB,CAAC,IAAEF,CAAC,CAACE,CAAC,CAACyF,UAAH,EAAczF,CAAC,CAACwF,KAAhB,CAAxB,CAAf,GAAiEtC,CAAC,CAACC,QAAF,CAAWC,GAAX,CAAe,IAAI5B,CAAJ,CAAM,YAAN,EAAoB,CAAC1B,CAAD,EAAGE,CAAH,KAAOF,CAAC,CAAC4F,UAAF,GAAa1F,CAAC,CAACqD,MAAF,CAAS2B,UAAjD,CAAf,CAAjE,EAA+I9B,CAAC,CAAC6B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAC1N;AACA;AACA,+DAH6M,CAArK,CAxBqC,EA2BXwB,CAAC,CAAC6B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE,sDAAb,CA3BW,EA2ByDY,CAAC,CAACwC,cAAF,KAAmB5B,CAAC,CAACC,QAAF,CAAWC,GAAX,CAAe,IAAI5B,CAAJ,CAAM,SAAN,EAAiB1B,CAAC,IAAEA,CAAC,CAAC6F,OAAtB,CAAf,GAAgDzC,CAAC,CAAC6B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE,wFAAb,CAAnE,CA3BjI,CA5EyF,EAuGmNwB,CAAC,CAAC6B,IAAF,CAAO3B,GAAP,CAAW1B,CAAE;AAC9T,yBAAyBA,CAAC,CAACwD,KAAF,CAAQpE,CAAR,CAAW;AACpC;AACA;AACA;AACA,MAAMwB,CAAC,CAACI,MAAF,KAAW1C,CAAC,CAAC4C,KAAb,GAAmBlB,CAAE,oCAArB,GAAyD,EAAG;AAClE,MAAMY,CAAC,CAACI,MAAF,KAAW1C,CAAC,CAAC2C,KAAb,GAAmBjB,CAAE,kDAArB,GAAuE,EAAG;AAChF,MAAMY,CAAC,CAACI,MAAF,KAAW1C,CAAC,CAAC2C,KAAb,IAAoBL,CAAC,CAACsD,oBAAF,KAAyB5D,CAAC,CAACW,KAA/C,GAAqD,gDAArD,GAAsG,EAAG;AAC/G,MAAML,CAAC,CAACI,MAAF,KAAW1C,CAAC,CAAC6F,SAAb,GAAuBnE,CAAE,2BAAzB,GAAoD,EAAG;AAC7D,MAAMY,CAAC,CAACI,MAAF,KAAW1C,CAAC,CAAC8C,KAAb,GAAmBpB,CAAE,2BAArB,GAAgD,EAAG;AACzD;AACA,GAXiT,CAvGnN,EAkHzFa,CAlHkF;AAkHhF;;AAAA,MAAMA,CAAC,GAACuD,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,cAAP,CAAsB;EAACC,SAAS,EAAC,IAAX;EAAgBC,2BAA2B,EAAC7D,CAA5C;EAA8C8D,KAAK,EAAC7D;AAApD,CAAtB,EAA6E8D,MAAM,CAACC,WAApF,EAAgG;EAACC,KAAK,EAAC;AAAP,CAAhG,CAAd,CAAR;AAAyI,SAAOjE,CAAC,IAAIkE,CAAZ,EAAchE,CAAC,IAAI+B,CAAnB,EAAqBhC,CAArB"},"metadata":{},"sourceType":"module"}