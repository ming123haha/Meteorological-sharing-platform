{"ast":null,"code":"/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\n\nfunction defaultKeyGetter(item) {\n  return item;\n}\n\nvar DataDiffer =\n/** @class */\nfunction () {\n  /**\r\n   * @param context Can be visited by this.context in callback.\r\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter; // Visible in callback via `this.context`;\n\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\r\n   * Callback function when add a data\r\n   */\n\n\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\r\n   * Callback function when update a data\r\n   */\n\n\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\r\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\r\n   */\n\n\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\r\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\r\n   */\n\n\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\r\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\r\n   */\n\n\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\r\n   * Callback function when remove a data\r\n   */\n\n\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal); // idx can never be empty array here. see 'set null' logic below.\n\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\r\n   * For example, consider the case:\r\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\r\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\r\n   * Where:\r\n   *     o0, o1, n0 has key 'a' (many to one)\r\n   *     o5, n4, n5, n6 has key 'b' (one to many)\r\n   *     o2, n1 has key 'c' (one to one)\r\n   *     n2, n3 has key 'd' (add)\r\n   *     o3, o4 has key 'e' (remove)\r\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\r\n   * Then:\r\n   *     (The order of the following directives are not ensured.)\r\n   *     this._updateManyToOne(n0, [o0, o1]);\r\n   *     this._updateOneToMany([n4, n5, n6], o5);\r\n   *     this._update(n1, o2);\r\n   *     this._remove(o3);\r\n   *     this._remove(o4);\r\n   *     this._remove(o6);\r\n   *     this._remove(o7);\r\n   *     this._add(n2);\r\n   *     this._add(n3);\r\n   *     this._add(n7);\r\n   *     this._add(n8);\r\n   */\n\n\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      } // Support both `newDataKeyArr` are duplication removed or not removed.\n\n\n      newDataIndexMap[newKey] = null;\n    }\n  };\n\n  DataDiffer.prototype._initIndexMap = function (arr, // Can be null.\n  map, // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n\n      if (!map) {\n        continue;\n      }\n\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n\n  return DataDiffer;\n}();\n\nexport default DataDiffer;","map":{"version":3,"names":["dataIndexMapValueLength","valNumOrArrLengthMoreThan2","length","defaultKeyGetter","item","DataDiffer","oldArr","newArr","oldKeyGetter","newKeyGetter","context","diffMode","_old","_new","_oldKeyGetter","_newKeyGetter","_diffModeMultiple","prototype","add","func","_add","update","_update","updateManyToOne","_updateManyToOne","updateOneToMany","_updateOneToMany","updateManyToMany","_updateManyToMany","remove","_remove","execute","_executeOneToOne","newDataIndexMap","oldDataKeyArr","Array","newDataKeyArr","_initIndexMap","i","oldKey","newIdxMapVal","newIdxMapValLen","newIdx","shift","_performRestAdd","_executeMultiple","oldDataIndexMap","oldIdxMapVal","oldIdxMapValLen","i_1","newKey","idxMapValLen","j","arr","map","keyArr","keyGetterName","cbModeMultiple","key","idxMapVal","push"],"sources":["E:/各个学科/论文/毕业论文/Atmosphere/eco-friendly/node_modules/echarts/lib/data/DataDiffer.js"],"sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\r\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\r\n}\r\n\r\nfunction defaultKeyGetter(item) {\r\n  return item;\r\n}\r\n\r\nvar DataDiffer =\r\n/** @class */\r\nfunction () {\r\n  /**\r\n   * @param context Can be visited by this.context in callback.\r\n   */\r\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.\r\n  diffMode) {\r\n    this._old = oldArr;\r\n    this._new = newArr;\r\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\r\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter; // Visible in callback via `this.context`;\r\n\r\n    this.context = context;\r\n    this._diffModeMultiple = diffMode === 'multiple';\r\n  }\r\n  /**\r\n   * Callback function when add a data\r\n   */\r\n\r\n\r\n  DataDiffer.prototype.add = function (func) {\r\n    this._add = func;\r\n    return this;\r\n  };\r\n  /**\r\n   * Callback function when update a data\r\n   */\r\n\r\n\r\n  DataDiffer.prototype.update = function (func) {\r\n    this._update = func;\r\n    return this;\r\n  };\r\n  /**\r\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\r\n   */\r\n\r\n\r\n  DataDiffer.prototype.updateManyToOne = function (func) {\r\n    this._updateManyToOne = func;\r\n    return this;\r\n  };\r\n  /**\r\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\r\n   */\r\n\r\n\r\n  DataDiffer.prototype.updateOneToMany = function (func) {\r\n    this._updateOneToMany = func;\r\n    return this;\r\n  };\r\n  /**\r\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\r\n   */\r\n\r\n\r\n  DataDiffer.prototype.updateManyToMany = function (func) {\r\n    this._updateManyToMany = func;\r\n    return this;\r\n  };\r\n  /**\r\n   * Callback function when remove a data\r\n   */\r\n\r\n\r\n  DataDiffer.prototype.remove = function (func) {\r\n    this._remove = func;\r\n    return this;\r\n  };\r\n\r\n  DataDiffer.prototype.execute = function () {\r\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\r\n  };\r\n\r\n  DataDiffer.prototype._executeOneToOne = function () {\r\n    var oldArr = this._old;\r\n    var newArr = this._new;\r\n    var newDataIndexMap = {};\r\n    var oldDataKeyArr = new Array(oldArr.length);\r\n    var newDataKeyArr = new Array(newArr.length);\r\n\r\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\r\n\r\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\r\n\r\n    for (var i = 0; i < oldArr.length; i++) {\r\n      var oldKey = oldDataKeyArr[i];\r\n      var newIdxMapVal = newDataIndexMap[oldKey];\r\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal); // idx can never be empty array here. see 'set null' logic below.\r\n\r\n      if (newIdxMapValLen > 1) {\r\n        // Consider there is duplicate key (for example, use dataItem.name as key).\r\n        // We should make sure every item in newArr and oldArr can be visited.\r\n        var newIdx = newIdxMapVal.shift();\r\n\r\n        if (newIdxMapVal.length === 1) {\r\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\r\n        }\r\n\r\n        this._update && this._update(newIdx, i);\r\n      } else if (newIdxMapValLen === 1) {\r\n        newDataIndexMap[oldKey] = null;\r\n        this._update && this._update(newIdxMapVal, i);\r\n      } else {\r\n        this._remove && this._remove(i);\r\n      }\r\n    }\r\n\r\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\r\n  };\r\n  /**\r\n   * For example, consider the case:\r\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\r\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\r\n   * Where:\r\n   *     o0, o1, n0 has key 'a' (many to one)\r\n   *     o5, n4, n5, n6 has key 'b' (one to many)\r\n   *     o2, n1 has key 'c' (one to one)\r\n   *     n2, n3 has key 'd' (add)\r\n   *     o3, o4 has key 'e' (remove)\r\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\r\n   * Then:\r\n   *     (The order of the following directives are not ensured.)\r\n   *     this._updateManyToOne(n0, [o0, o1]);\r\n   *     this._updateOneToMany([n4, n5, n6], o5);\r\n   *     this._update(n1, o2);\r\n   *     this._remove(o3);\r\n   *     this._remove(o4);\r\n   *     this._remove(o6);\r\n   *     this._remove(o7);\r\n   *     this._add(n2);\r\n   *     this._add(n3);\r\n   *     this._add(n7);\r\n   *     this._add(n8);\r\n   */\r\n\r\n\r\n  DataDiffer.prototype._executeMultiple = function () {\r\n    var oldArr = this._old;\r\n    var newArr = this._new;\r\n    var oldDataIndexMap = {};\r\n    var newDataIndexMap = {};\r\n    var oldDataKeyArr = [];\r\n    var newDataKeyArr = [];\r\n\r\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\r\n\r\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\r\n\r\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\r\n      var oldKey = oldDataKeyArr[i];\r\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\r\n      var newIdxMapVal = newDataIndexMap[oldKey];\r\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\r\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\r\n\r\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\r\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\r\n        newDataIndexMap[oldKey] = null;\r\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\r\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\r\n        newDataIndexMap[oldKey] = null;\r\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\r\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\r\n        newDataIndexMap[oldKey] = null;\r\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\r\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\r\n        newDataIndexMap[oldKey] = null;\r\n      } else if (oldIdxMapValLen > 1) {\r\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\r\n          this._remove && this._remove(oldIdxMapVal[i_1]);\r\n        }\r\n      } else {\r\n        this._remove && this._remove(oldIdxMapVal);\r\n      }\r\n    }\r\n\r\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\r\n  };\r\n\r\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\r\n    for (var i = 0; i < newDataKeyArr.length; i++) {\r\n      var newKey = newDataKeyArr[i];\r\n      var newIdxMapVal = newDataIndexMap[newKey];\r\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\r\n\r\n      if (idxMapValLen > 1) {\r\n        for (var j = 0; j < idxMapValLen; j++) {\r\n          this._add && this._add(newIdxMapVal[j]);\r\n        }\r\n      } else if (idxMapValLen === 1) {\r\n        this._add && this._add(newIdxMapVal);\r\n      } // Support both `newDataKeyArr` are duplication removed or not removed.\r\n\r\n\r\n      newDataIndexMap[newKey] = null;\r\n    }\r\n  };\r\n\r\n  DataDiffer.prototype._initIndexMap = function (arr, // Can be null.\r\n  map, // In 'byKey', the output `keyArr` is duplication removed.\r\n  // In 'byIndex', the output `keyArr` is not duplication removed and\r\n  //     its indices are accurately corresponding to `arr`.\r\n  keyArr, keyGetterName) {\r\n    var cbModeMultiple = this._diffModeMultiple;\r\n\r\n    for (var i = 0; i < arr.length; i++) {\r\n      // Add prefix to avoid conflict with Object.prototype.\r\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\r\n\r\n      if (!cbModeMultiple) {\r\n        keyArr[i] = key;\r\n      }\r\n\r\n      if (!map) {\r\n        continue;\r\n      }\r\n\r\n      var idxMapVal = map[key];\r\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\r\n\r\n      if (idxMapValLen === 0) {\r\n        // Simple optimize: in most cases, one index has one key,\r\n        // do not need array.\r\n        map[key] = i;\r\n\r\n        if (cbModeMultiple) {\r\n          keyArr.push(key);\r\n        }\r\n      } else if (idxMapValLen === 1) {\r\n        map[key] = [idxMapVal, i];\r\n      } else {\r\n        idxMapVal.push(i);\r\n      }\r\n    }\r\n  };\r\n\r\n  return DataDiffer;\r\n}();\r\n\r\nexport default DataDiffer;"],"mappings":"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"},"metadata":{},"sourceType":"module"}