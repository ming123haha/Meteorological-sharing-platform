{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\n\n/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.97\n */\nimport { c as getElementDir, o as closestElementCrossShadowBoundary } from './dom.js';\nimport { Build } from '@stencil/core/internal/client/index.js';\nimport { d as debounce } from './debounce.js';\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\n\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\n\n\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n\nfunction within(min$1$1, value, max$1$1) {\n  return max$1(min$1$1, min$1(value, max$1$1));\n}\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\n\n\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\n\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\n\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\n\n\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\n\n\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\n\n\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\n\n\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\n\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\n\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\n\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\n\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some( // TS 4.1 compat\n  value => {\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\n\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n} // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {\n  let currentNode = element;\n\n  while (currentNode && !isLastTraversableNode(currentNode) && // @ts-expect-error\n  !clippingAncestors.includes(currentNode)) {\n    if (isElement(currentNode) && ['absolute', 'fixed'].includes(getComputedStyle(currentNode).position)) {\n      break;\n    }\n\n    const parentNode = getParentNode(currentNode);\n    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;\n  }\n\n  return currentNode;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);\n  let clipperElement = null;\n\n  if (nearestEscapableParent && isHTMLElement(nearestEscapableParent)) {\n    const offsetParent = getOffsetParent(nearestEscapableParent);\n\n    if (isOverflowElement(nearestEscapableParent)) {\n      clipperElement = nearestEscapableParent;\n    } else if (isHTMLElement(offsetParent)) {\n      clipperElement = offsetParent;\n    }\n  }\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => clipperElement && isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle(element).direction === 'rtl'\n};\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\n\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n/**\n * This module helps users provide custom configuration for component internals.\n *\n * @internal\n */\n\n\nconst configOverrides = globalThis[\"calciteComponentsConfig\"];\nconst config = {\n  /**\n   * We apply a custom fix to improve positioning for non-Chromium browsers.\n   * The fix comes at a performance cost, so provides users a way to opt-out if necessary.\n   *\n   * @internal\n   */\n  floatingUINonChromiumPositioningFix: true,\n  ...configOverrides\n};\nconst floatingUIBrowserCheck = patchFloatingUiForNonChromiumBrowsers();\n\nasync function patchFloatingUiForNonChromiumBrowsers() {\n  function getUAString() {\n    const uaData = navigator.userAgentData;\n\n    if (uaData === null || uaData === void 0 ? void 0 : uaData.brands) {\n      return uaData.brands.map(item => `${item.brand}/${item.version}`).join(\" \");\n    }\n\n    return navigator.userAgent;\n  }\n\n  if (Build.isBrowser && config.floatingUINonChromiumPositioningFix && // ⚠️ browser-sniffing is not a best practice and should be avoided ⚠️\n  /firefox|safari/i.test(getUAString())) {\n    const {\n      getClippingRect,\n      getElementRects,\n      getOffsetParent\n    } = await import('./nonChromiumPlatformUtils.js');\n    platform.getClippingRect = getClippingRect;\n    platform.getOffsetParent = getOffsetParent;\n    platform.getElementRects = getElementRects;\n  }\n}\n\nconst placementDataAttribute = \"data-placement\";\n/**\n * Exported for testing purposes only\n */\n\nconst repositionDebounceTimeout = 100;\nconst effectivePlacements = [\"top\", \"bottom\", \"right\", \"left\", \"top-start\", \"top-end\", \"bottom-start\", \"bottom-end\", \"right-start\", \"right-end\", \"left-start\", \"left-end\"];\nconst defaultMenuPlacement = \"bottom-start\";\nconst FloatingCSS = {\n  animation: \"calcite-floating-ui-anim\",\n  animationActive: \"calcite-floating-ui-anim--active\"\n};\n\nfunction getMiddleware({\n  placement,\n  disableFlip,\n  flipPlacements,\n  offsetDistance,\n  offsetSkidding,\n  arrowEl,\n  type\n}) {\n  const defaultMiddleware = [shift(), hide()];\n\n  if (type === \"menu\") {\n    return [...defaultMiddleware, flip({\n      fallbackPlacements: flipPlacements || [\"top-start\", \"top\", \"top-end\", \"bottom-start\", \"bottom\", \"bottom-end\"]\n    })];\n  }\n\n  if (type === \"popover\" || type === \"tooltip\") {\n    const middleware = [...defaultMiddleware, offset({\n      mainAxis: typeof offsetDistance === \"number\" ? offsetDistance : 0,\n      crossAxis: typeof offsetSkidding === \"number\" ? offsetSkidding : 0\n    })];\n\n    if (placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\") {\n      middleware.push(autoPlacement({\n        alignment: placement === \"auto-start\" ? \"start\" : placement === \"auto-end\" ? \"end\" : null\n      }));\n    } else if (!disableFlip) {\n      middleware.push(flip(flipPlacements ? {\n        fallbackPlacements: flipPlacements\n      } : {}));\n    }\n\n    if (arrowEl) {\n      middleware.push(arrow({\n        element: arrowEl\n      }));\n    }\n\n    return middleware;\n  }\n\n  return [];\n}\n\nfunction filterComputedPlacements(placements, el) {\n  const filteredPlacements = placements.filter(placement => effectivePlacements.includes(placement));\n\n  if (filteredPlacements.length !== placements.length) {\n    console.warn(`${el.tagName}: Invalid value found in: flipPlacements. Try any of these: ${effectivePlacements.map(placement => `\"${placement}\"`).join(\", \").trim()}`, {\n      el\n    });\n  }\n\n  return filteredPlacements;\n}\n/*\nIn floating-ui, \"*-start\" and \"*-end\" are already flipped in RTL.\nThere is no need for our \"*-leading\" and \"*-trailing\" values anymore.\nhttps://github.com/floating-ui/floating-ui/issues/1530\nhttps://github.com/floating-ui/floating-ui/issues/1563\n*/\n\n\nfunction getEffectivePlacement(floatingEl, placement) {\n  const placements = [\"left\", \"right\"];\n\n  if (getElementDir(floatingEl) === \"rtl\") {\n    placements.reverse();\n  }\n\n  return placement.replace(/-leading/gi, \"-start\").replace(/-trailing/gi, \"-end\").replace(/leading/gi, placements[0]).replace(/trailing/gi, placements[1]);\n}\n/**\n * Convenience function to manage `reposition` calls for FloatingUIComponents that use `positionFloatingUI.\n *\n * Note: this is not needed for components that use `calcite-popover`.\n *\n * @param component\n * @param options\n * @param options.referenceEl\n * @param options.floatingEl\n * @param options.overlayPositioning\n * @param options.placement\n * @param options.disableFlip\n * @param options.flipPlacements\n * @param options.offsetDistance\n * @param options.offsetSkidding\n * @param options.arrowEl\n * @param options.type\n * @param delayed\n */\n\n\nasync function reposition(component, options, delayed = false) {\n  if (!component.open) {\n    return;\n  }\n\n  return delayed ? debouncedReposition(options) : positionFloatingUI(options);\n}\n\nconst debouncedReposition = debounce(positionFloatingUI, repositionDebounceTimeout, {\n  leading: true,\n  maxWait: repositionDebounceTimeout\n});\n/**\n * Positions the floating element relative to the reference element.\n *\n * **Note:** exported for testing purposes only\n *\n * @param root0\n * @param root0.referenceEl\n * @param root0.floatingEl\n * @param root0.overlayPositioning\n * @param root0.placement\n * @param root0.disableFlip\n * @param root0.flipPlacements\n * @param root0.offsetDistance\n * @param root0.offsetSkidding\n * @param root0.arrowEl\n * @param root0.type\n * @param root0.includeArrow\n */\n\nasync function positionFloatingUI({\n  referenceEl,\n  floatingEl,\n  overlayPositioning = \"absolute\",\n  placement,\n  disableFlip,\n  flipPlacements,\n  offsetDistance,\n  offsetSkidding,\n  includeArrow = false,\n  arrowEl,\n  type\n}) {\n  var _a;\n\n  if (!referenceEl || !floatingEl || includeArrow && !arrowEl) {\n    return null;\n  }\n\n  await floatingUIBrowserCheck;\n  const {\n    x,\n    y,\n    placement: effectivePlacement,\n    strategy: position,\n    middlewareData\n  } = await computePosition(referenceEl, floatingEl, {\n    strategy: overlayPositioning,\n    placement: placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\" ? undefined : getEffectivePlacement(floatingEl, placement),\n    middleware: getMiddleware({\n      placement,\n      disableFlip,\n      flipPlacements,\n      offsetDistance,\n      offsetSkidding,\n      arrowEl,\n      type\n    })\n  });\n\n  if (middlewareData === null || middlewareData === void 0 ? void 0 : middlewareData.arrow) {\n    const {\n      x: arrowX,\n      y: arrowY\n    } = middlewareData.arrow;\n    Object.assign(arrowEl.style, {\n      left: arrowX != null ? `${arrowX}px` : \"\",\n      top: arrowY != null ? `${arrowY}px` : \"\"\n    });\n  }\n\n  const referenceHidden = (_a = middlewareData === null || middlewareData === void 0 ? void 0 : middlewareData.hide) === null || _a === void 0 ? void 0 : _a.referenceHidden;\n  const visibility = referenceHidden ? \"hidden\" : null;\n  const pointerEvents = visibility ? \"none\" : null;\n  floatingEl.setAttribute(placementDataAttribute, effectivePlacement);\n  const transform = `translate(${Math.round(x)}px,${Math.round(y)}px)`;\n  Object.assign(floatingEl.style, {\n    visibility,\n    pointerEvents,\n    position,\n    top: \"0\",\n    left: \"0\",\n    transform\n  });\n}\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\n\n\nconst cleanupMap = new WeakMap();\n/**\n * Helper to set up floating element interactions on connectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\n\nfunction connectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n\n  disconnectFloatingUI(component, referenceEl, floatingEl);\n  const position = component.overlayPositioning; // ensure position matches for initial positioning\n\n  floatingEl.style.position = position;\n\n  if (position === \"absolute\") {\n    moveOffScreen(floatingEl);\n  }\n\n  const runAutoUpdate = Build.isBrowser ? autoUpdate : (_refEl, _floatingEl, updateCallback) => {\n    updateCallback();\n    return () => {\n      /* noop */\n    };\n  };\n  cleanupMap.set(component, runAutoUpdate(referenceEl, floatingEl, () => component.reposition()));\n}\n/**\n * Helper to tear down floating element interactions on disconnectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\n\n\nfunction disconnectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n\n  getTransitionTarget(floatingEl).removeEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n  const cleanup = cleanupMap.get(component);\n\n  if (cleanup) {\n    cleanup();\n  }\n\n  cleanupMap.delete(component);\n}\n\nconst visiblePointerSize = 4;\n/**\n * Default offset the position of the floating element away from the reference element.\n *\n * @default 6\n */\n\nconst defaultOffsetDistance = Math.ceil(Math.hypot(visiblePointerSize, visiblePointerSize));\n/**\n * This utils applies floating element styles to avoid affecting layout when closed.\n *\n * This should be called when the closing transition will start.\n *\n * @param floatingEl\n */\n\nfunction updateAfterClose(floatingEl) {\n  if (!floatingEl || floatingEl.style.position !== \"absolute\") {\n    return;\n  }\n\n  getTransitionTarget(floatingEl).addEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n}\n\nfunction getTransitionTarget(floatingEl) {\n  // assumes floatingEl w/ shadowRoot is a FloatingUIComponent\n  return floatingEl.shadowRoot || floatingEl;\n}\n\nfunction handleTransitionElTransitionEnd(event) {\n  const floatingTransitionEl = event.target;\n\n  if ( // using any prop from floating-ui transition\n  event.propertyName === \"opacity\" && floatingTransitionEl.classList.contains(FloatingCSS.animation)) {\n    const floatingEl = getFloatingElFromTransitionTarget(floatingTransitionEl);\n    moveOffScreen(floatingEl);\n    getTransitionTarget(floatingEl).removeEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n  }\n}\n\nfunction moveOffScreen(floatingEl) {\n  floatingEl.style.transform = \"\";\n  floatingEl.style.top = \"-99999px\";\n  floatingEl.style.left = \"-99999px\";\n}\n\nfunction getFloatingElFromTransitionTarget(floatingTransitionEl) {\n  return closestElementCrossShadowBoundary(floatingTransitionEl, `[${placementDataAttribute}]`);\n}\n\nexport { FloatingCSS as F, disconnectFloatingUI as a, defaultOffsetDistance as b, connectFloatingUI as c, defaultMenuPlacement as d, rectToClientRect as e, filterComputedPlacements as f, reposition as r, updateAfterClose as u };","map":{"version":3,"names":["c","getElementDir","o","closestElementCrossShadowBoundary","Build","d","debounce","getSide","placement","split","getAlignment","getMainAxisFromPlacement","includes","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","x","width","commonY","y","height","mainAxis","length","commonAlign","side","isVertical","coords","computePosition$1","config","strategy","middleware","platform","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","i","name","fn","nextX","nextY","data","reset","initialPlacement","elements","expandPaddingObject","padding","top","right","bottom","left","getSideObjectFromPadding","rectToClientRect","rect","detectOverflow","middlewareArguments","options","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","altContext","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","offsetParent","getOffsetParent","min$1","Math","min","max$1","max","within","min$1$1","value","max$1$1","arrow","alignment","arrowDimensions","getDimensions","minProp","maxProp","endDiff","startDiff","arrowOffsetParent","clientSize","clientHeight","clientWidth","centerToReference","center","offset","alignmentPadding","shouldAddOffset","alignmentOffset","centerOffset","hash$1","getOppositePlacement","replace","matched","getAlignmentSides","mainAlignmentSide","main","cross","hash","start","end","getOppositeAlignmentPlacement","sides","allPlacements","reduce","acc","concat","getPlacementList","autoAlignment","allowedPlacements","allowedPlacementsSortedByAlignment","filter","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_middlewareData$autoP3","_middlewareData$autoP4","_placementsSortedByLe","detectOverflowOptions","placements","overflow","currentIndex","index","currentPlacement","currentOverflows","allOverflows","overflows","nextPlacement","placementsSortedByLeastOverflow","slice","sort","a","b","placementThatFitsOnAllSides","find","every","resetPlacement","getExpandedPlacements","oppositePlacement","flip","_middlewareData$flip","checkMainAxis","crossAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","isBasePlacement","overflowsData","push","_middlewareData$flip$","_middlewareData$flip2","nextIndex","_overflowsData$map$so","map","getSideOffsets","isAnySideFullyClipped","some","hide","_temp","offsets","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","alignmentAxis","diffCoords","getCrossAxis","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","isWindow","document","location","alert","setInterval","getWindow","node","window","ownerDocument","defaultView","getComputedStyle","getNodeName","nodeName","toLowerCase","getUAString","uaData","navigator","userAgentData","brands","item","brand","version","join","userAgent","isHTMLElement","HTMLElement","Element","isNode","Node","isShadowRoot","ShadowRoot","OwnElement","isOverflowElement","overflowX","overflowY","display","test","isTableElement","isContainingBlock","isFirefox","css","transform","perspective","willChange","contain","isLayoutViewport","isLastTraversableNode","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","offsetWidth","offsetHeight","win","addVisualOffsets","visualViewport","offsetLeft","offsetTop","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","isScaled","getRectRelativeToOffsetParent","isOffsetParentAnElement","scroll","offsetRect","clientLeft","clientTop","getParentNode","assignedSlot","parentNode","host","getTrueOffsetParent","position","getContainingBlock","currentNode","parent","getViewportRect","html","layoutViewport","getDocumentRect","_element$ownerDocumen","body","scrollWidth","scrollHeight","direction","getNearestOverflowAncestor","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","updatedList","contains","child","rootNode","getRootNode","next","getNearestParentCapableOfEscapingClipping","clippingAncestors","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingParent","getClippingAncestors","nearestEscapableParent","clipperElement","mainClippingAncestors","firstClippingAncestor","clippingRect","accRect","clippingAncestor","getClientRects","Array","from","autoUpdate","update","ancestorScroll","_ancestorScroll","ancestorResize","elementResize","animationFrame","ancestors","forEach","ancestor","addEventListener","passive","observer","initialUpdate","ResizeObserver","observe","frameId","prevRefRect","frameLoop","nextRefRect","requestAnimationFrame","_observer","removeEventListener","disconnect","cancelAnimationFrame","computePosition","configOverrides","globalThis","floatingUINonChromiumPositioningFix","floatingUIBrowserCheck","patchFloatingUiForNonChromiumBrowsers","isBrowser","placementDataAttribute","repositionDebounceTimeout","effectivePlacements","defaultMenuPlacement","FloatingCSS","animation","animationActive","getMiddleware","disableFlip","flipPlacements","offsetDistance","offsetSkidding","arrowEl","type","defaultMiddleware","filterComputedPlacements","el","filteredPlacements","console","warn","tagName","trim","getEffectivePlacement","floatingEl","reverse","reposition","component","delayed","open","debouncedReposition","positionFloatingUI","leading","maxWait","referenceEl","overlayPositioning","includeArrow","_a","effectivePlacement","undefined","arrowX","arrowY","Object","assign","style","visibility","pointerEvents","setAttribute","cleanupMap","WeakMap","connectFloatingUI","disconnectFloatingUI","moveOffScreen","runAutoUpdate","_refEl","_floatingEl","updateCallback","set","getTransitionTarget","handleTransitionElTransitionEnd","cleanup","get","delete","visiblePointerSize","defaultOffsetDistance","ceil","hypot","updateAfterClose","shadowRoot","event","floatingTransitionEl","propertyName","classList","getFloatingElFromTransitionTarget","F","e","f","r","u"],"sources":["E:/各个学科/论文/毕业论文/Atmosphere/eco-friendly/node_modules/@esri/calcite-components/dist/components/floating-ui.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.97\n */\nimport { c as getElementDir, o as closestElementCrossShadowBoundary } from './dom.js';\nimport { Build } from '@stencil/core/internal/client/index.js';\nimport { d as debounce } from './debounce.js';\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n\nfunction within(min$1$1, value, max$1$1) {\n  return max$1(min$1$1, min$1(value, max$1$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some( // TS 4.1 compat\n  value => {\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {\n  let currentNode = element;\n\n  while (currentNode && !isLastTraversableNode(currentNode) && // @ts-expect-error\n  !clippingAncestors.includes(currentNode)) {\n    if (isElement(currentNode) && ['absolute', 'fixed'].includes(getComputedStyle(currentNode).position)) {\n      break;\n    }\n\n    const parentNode = getParentNode(currentNode);\n    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;\n  }\n\n  return currentNode;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);\n  let clipperElement = null;\n\n  if (nearestEscapableParent && isHTMLElement(nearestEscapableParent)) {\n    const offsetParent = getOffsetParent(nearestEscapableParent);\n\n    if (isOverflowElement(nearestEscapableParent)) {\n      clipperElement = nearestEscapableParent;\n    } else if (isHTMLElement(offsetParent)) {\n      clipperElement = offsetParent;\n    }\n  }\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => clipperElement && isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\n/**\n * This module helps users provide custom configuration for component internals.\n *\n * @internal\n */\nconst configOverrides = globalThis[\"calciteComponentsConfig\"];\nconst config = {\n  /**\n   * We apply a custom fix to improve positioning for non-Chromium browsers.\n   * The fix comes at a performance cost, so provides users a way to opt-out if necessary.\n   *\n   * @internal\n   */\n  floatingUINonChromiumPositioningFix: true,\n  ...configOverrides\n};\n\nconst floatingUIBrowserCheck = patchFloatingUiForNonChromiumBrowsers();\nasync function patchFloatingUiForNonChromiumBrowsers() {\n  function getUAString() {\n    const uaData = navigator.userAgentData;\n    if (uaData === null || uaData === void 0 ? void 0 : uaData.brands) {\n      return uaData.brands.map((item) => `${item.brand}/${item.version}`).join(\" \");\n    }\n    return navigator.userAgent;\n  }\n  if (Build.isBrowser &&\n    config.floatingUINonChromiumPositioningFix &&\n    // ⚠️ browser-sniffing is not a best practice and should be avoided ⚠️\n    /firefox|safari/i.test(getUAString())) {\n    const { getClippingRect, getElementRects, getOffsetParent } = await import('./nonChromiumPlatformUtils.js');\n    platform.getClippingRect = getClippingRect;\n    platform.getOffsetParent = getOffsetParent;\n    platform.getElementRects = getElementRects;\n  }\n}\nconst placementDataAttribute = \"data-placement\";\n/**\n * Exported for testing purposes only\n */\nconst repositionDebounceTimeout = 100;\nconst effectivePlacements = [\n  \"top\",\n  \"bottom\",\n  \"right\",\n  \"left\",\n  \"top-start\",\n  \"top-end\",\n  \"bottom-start\",\n  \"bottom-end\",\n  \"right-start\",\n  \"right-end\",\n  \"left-start\",\n  \"left-end\"\n];\nconst defaultMenuPlacement = \"bottom-start\";\nconst FloatingCSS = {\n  animation: \"calcite-floating-ui-anim\",\n  animationActive: \"calcite-floating-ui-anim--active\"\n};\nfunction getMiddleware({ placement, disableFlip, flipPlacements, offsetDistance, offsetSkidding, arrowEl, type }) {\n  const defaultMiddleware = [shift(), hide()];\n  if (type === \"menu\") {\n    return [\n      ...defaultMiddleware,\n      flip({\n        fallbackPlacements: flipPlacements || [\"top-start\", \"top\", \"top-end\", \"bottom-start\", \"bottom\", \"bottom-end\"]\n      })\n    ];\n  }\n  if (type === \"popover\" || type === \"tooltip\") {\n    const middleware = [\n      ...defaultMiddleware,\n      offset({\n        mainAxis: typeof offsetDistance === \"number\" ? offsetDistance : 0,\n        crossAxis: typeof offsetSkidding === \"number\" ? offsetSkidding : 0\n      })\n    ];\n    if (placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\") {\n      middleware.push(autoPlacement({ alignment: placement === \"auto-start\" ? \"start\" : placement === \"auto-end\" ? \"end\" : null }));\n    }\n    else if (!disableFlip) {\n      middleware.push(flip(flipPlacements ? { fallbackPlacements: flipPlacements } : {}));\n    }\n    if (arrowEl) {\n      middleware.push(arrow({\n        element: arrowEl\n      }));\n    }\n    return middleware;\n  }\n  return [];\n}\nfunction filterComputedPlacements(placements, el) {\n  const filteredPlacements = placements.filter((placement) => effectivePlacements.includes(placement));\n  if (filteredPlacements.length !== placements.length) {\n    console.warn(`${el.tagName}: Invalid value found in: flipPlacements. Try any of these: ${effectivePlacements\n      .map((placement) => `\"${placement}\"`)\n      .join(\", \")\n      .trim()}`, { el });\n  }\n  return filteredPlacements;\n}\n/*\nIn floating-ui, \"*-start\" and \"*-end\" are already flipped in RTL.\nThere is no need for our \"*-leading\" and \"*-trailing\" values anymore.\nhttps://github.com/floating-ui/floating-ui/issues/1530\nhttps://github.com/floating-ui/floating-ui/issues/1563\n*/\nfunction getEffectivePlacement(floatingEl, placement) {\n  const placements = [\"left\", \"right\"];\n  if (getElementDir(floatingEl) === \"rtl\") {\n    placements.reverse();\n  }\n  return placement\n    .replace(/-leading/gi, \"-start\")\n    .replace(/-trailing/gi, \"-end\")\n    .replace(/leading/gi, placements[0])\n    .replace(/trailing/gi, placements[1]);\n}\n/**\n * Convenience function to manage `reposition` calls for FloatingUIComponents that use `positionFloatingUI.\n *\n * Note: this is not needed for components that use `calcite-popover`.\n *\n * @param component\n * @param options\n * @param options.referenceEl\n * @param options.floatingEl\n * @param options.overlayPositioning\n * @param options.placement\n * @param options.disableFlip\n * @param options.flipPlacements\n * @param options.offsetDistance\n * @param options.offsetSkidding\n * @param options.arrowEl\n * @param options.type\n * @param delayed\n */\nasync function reposition(component, options, delayed = false) {\n  if (!component.open) {\n    return;\n  }\n  return delayed ? debouncedReposition(options) : positionFloatingUI(options);\n}\nconst debouncedReposition = debounce(positionFloatingUI, repositionDebounceTimeout, {\n  leading: true,\n  maxWait: repositionDebounceTimeout\n});\n/**\n * Positions the floating element relative to the reference element.\n *\n * **Note:** exported for testing purposes only\n *\n * @param root0\n * @param root0.referenceEl\n * @param root0.floatingEl\n * @param root0.overlayPositioning\n * @param root0.placement\n * @param root0.disableFlip\n * @param root0.flipPlacements\n * @param root0.offsetDistance\n * @param root0.offsetSkidding\n * @param root0.arrowEl\n * @param root0.type\n * @param root0.includeArrow\n */\nasync function positionFloatingUI({ referenceEl, floatingEl, overlayPositioning = \"absolute\", placement, disableFlip, flipPlacements, offsetDistance, offsetSkidding, includeArrow = false, arrowEl, type }) {\n  var _a;\n  if (!referenceEl || !floatingEl || (includeArrow && !arrowEl)) {\n    return null;\n  }\n  await floatingUIBrowserCheck;\n  const { x, y, placement: effectivePlacement, strategy: position, middlewareData } = await computePosition(referenceEl, floatingEl, {\n    strategy: overlayPositioning,\n    placement: placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\"\n      ? undefined\n      : getEffectivePlacement(floatingEl, placement),\n    middleware: getMiddleware({\n      placement,\n      disableFlip,\n      flipPlacements,\n      offsetDistance,\n      offsetSkidding,\n      arrowEl,\n      type\n    })\n  });\n  if (middlewareData === null || middlewareData === void 0 ? void 0 : middlewareData.arrow) {\n    const { x: arrowX, y: arrowY } = middlewareData.arrow;\n    Object.assign(arrowEl.style, {\n      left: arrowX != null ? `${arrowX}px` : \"\",\n      top: arrowY != null ? `${arrowY}px` : \"\"\n    });\n  }\n  const referenceHidden = (_a = middlewareData === null || middlewareData === void 0 ? void 0 : middlewareData.hide) === null || _a === void 0 ? void 0 : _a.referenceHidden;\n  const visibility = referenceHidden ? \"hidden\" : null;\n  const pointerEvents = visibility ? \"none\" : null;\n  floatingEl.setAttribute(placementDataAttribute, effectivePlacement);\n  const transform = `translate(${Math.round(x)}px,${Math.round(y)}px)`;\n  Object.assign(floatingEl.style, {\n    visibility,\n    pointerEvents,\n    position,\n    top: \"0\",\n    left: \"0\",\n    transform\n  });\n}\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\nconst cleanupMap = new WeakMap();\n/**\n * Helper to set up floating element interactions on connectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\nfunction connectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n  disconnectFloatingUI(component, referenceEl, floatingEl);\n  const position = component.overlayPositioning;\n  // ensure position matches for initial positioning\n  floatingEl.style.position = position;\n  if (position === \"absolute\") {\n    moveOffScreen(floatingEl);\n  }\n  const runAutoUpdate = Build.isBrowser\n    ? autoUpdate\n    : (_refEl, _floatingEl, updateCallback) => {\n      updateCallback();\n      return () => {\n        /* noop */\n      };\n    };\n  cleanupMap.set(component, runAutoUpdate(referenceEl, floatingEl, () => component.reposition()));\n}\n/**\n * Helper to tear down floating element interactions on disconnectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\nfunction disconnectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n  getTransitionTarget(floatingEl).removeEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n  const cleanup = cleanupMap.get(component);\n  if (cleanup) {\n    cleanup();\n  }\n  cleanupMap.delete(component);\n}\nconst visiblePointerSize = 4;\n/**\n * Default offset the position of the floating element away from the reference element.\n *\n * @default 6\n */\nconst defaultOffsetDistance = Math.ceil(Math.hypot(visiblePointerSize, visiblePointerSize));\n/**\n * This utils applies floating element styles to avoid affecting layout when closed.\n *\n * This should be called when the closing transition will start.\n *\n * @param floatingEl\n */\nfunction updateAfterClose(floatingEl) {\n  if (!floatingEl || floatingEl.style.position !== \"absolute\") {\n    return;\n  }\n  getTransitionTarget(floatingEl).addEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n}\nfunction getTransitionTarget(floatingEl) {\n  // assumes floatingEl w/ shadowRoot is a FloatingUIComponent\n  return floatingEl.shadowRoot || floatingEl;\n}\nfunction handleTransitionElTransitionEnd(event) {\n  const floatingTransitionEl = event.target;\n  if (\n  // using any prop from floating-ui transition\n  event.propertyName === \"opacity\" &&\n    floatingTransitionEl.classList.contains(FloatingCSS.animation)) {\n    const floatingEl = getFloatingElFromTransitionTarget(floatingTransitionEl);\n    moveOffScreen(floatingEl);\n    getTransitionTarget(floatingEl).removeEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n  }\n}\nfunction moveOffScreen(floatingEl) {\n  floatingEl.style.transform = \"\";\n  floatingEl.style.top = \"-99999px\";\n  floatingEl.style.left = \"-99999px\";\n}\nfunction getFloatingElFromTransitionTarget(floatingTransitionEl) {\n  return closestElementCrossShadowBoundary(floatingTransitionEl, `[${placementDataAttribute}]`);\n}\n\nexport { FloatingCSS as F, disconnectFloatingUI as a, defaultOffsetDistance as b, connectFloatingUI as c, defaultMenuPlacement as d, rectToClientRect as e, filterComputedPlacements as f, reposition as r, updateAfterClose as u };\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,CAAC,IAAIC,aAAd,EAA6BC,CAAC,IAAIC,iCAAlC,QAA2E,UAA3E;AACA,SAASC,KAAT,QAAsB,wCAAtB;AACA,SAASC,CAAC,IAAIC,QAAd,QAA8B,eAA9B;;AAEA,SAASC,OAAT,CAAiBC,SAAjB,EAA4B;EAC1B,OAAOA,SAAS,CAACC,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAP;AACD;;AAED,SAASC,YAAT,CAAsBF,SAAtB,EAAiC;EAC/B,OAAOA,SAAS,CAACC,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAP;AACD;;AAED,SAASE,wBAAT,CAAkCH,SAAlC,EAA6C;EAC3C,OAAO,CAAC,KAAD,EAAQ,QAAR,EAAkBI,QAAlB,CAA2BL,OAAO,CAACC,SAAD,CAAlC,IAAiD,GAAjD,GAAuD,GAA9D;AACD;;AAED,SAASK,iBAAT,CAA2BC,IAA3B,EAAiC;EAC/B,OAAOA,IAAI,KAAK,GAAT,GAAe,QAAf,GAA0B,OAAjC;AACD;;AAED,SAASC,0BAAT,CAAoCC,IAApC,EAA0CR,SAA1C,EAAqDS,GAArD,EAA0D;EACxD,IAAI;IACFC,SADE;IAEFC;EAFE,IAGAH,IAHJ;EAIA,MAAMI,OAAO,GAAGF,SAAS,CAACG,CAAV,GAAcH,SAAS,CAACI,KAAV,GAAkB,CAAhC,GAAoCH,QAAQ,CAACG,KAAT,GAAiB,CAArE;EACA,MAAMC,OAAO,GAAGL,SAAS,CAACM,CAAV,GAAcN,SAAS,CAACO,MAAV,GAAmB,CAAjC,GAAqCN,QAAQ,CAACM,MAAT,GAAkB,CAAvE;EACA,MAAMC,QAAQ,GAAGf,wBAAwB,CAACH,SAAD,CAAzC;EACA,MAAMmB,MAAM,GAAGd,iBAAiB,CAACa,QAAD,CAAhC;EACA,MAAME,WAAW,GAAGV,SAAS,CAACS,MAAD,CAAT,GAAoB,CAApB,GAAwBR,QAAQ,CAACQ,MAAD,CAAR,GAAmB,CAA/D;EACA,MAAME,IAAI,GAAGtB,OAAO,CAACC,SAAD,CAApB;EACA,MAAMsB,UAAU,GAAGJ,QAAQ,KAAK,GAAhC;EACA,IAAIK,MAAJ;;EAEA,QAAQF,IAAR;IACE,KAAK,KAAL;MACEE,MAAM,GAAG;QACPV,CAAC,EAAED,OADI;QAEPI,CAAC,EAAEN,SAAS,CAACM,CAAV,GAAcL,QAAQ,CAACM;MAFnB,CAAT;MAIA;;IAEF,KAAK,QAAL;MACEM,MAAM,GAAG;QACPV,CAAC,EAAED,OADI;QAEPI,CAAC,EAAEN,SAAS,CAACM,CAAV,GAAcN,SAAS,CAACO;MAFpB,CAAT;MAIA;;IAEF,KAAK,OAAL;MACEM,MAAM,GAAG;QACPV,CAAC,EAAEH,SAAS,CAACG,CAAV,GAAcH,SAAS,CAACI,KADpB;QAEPE,CAAC,EAAED;MAFI,CAAT;MAIA;;IAEF,KAAK,MAAL;MACEQ,MAAM,GAAG;QACPV,CAAC,EAAEH,SAAS,CAACG,CAAV,GAAcF,QAAQ,CAACG,KADnB;QAEPE,CAAC,EAAED;MAFI,CAAT;MAIA;;IAEF;MACEQ,MAAM,GAAG;QACPV,CAAC,EAAEH,SAAS,CAACG,CADN;QAEPG,CAAC,EAAEN,SAAS,CAACM;MAFN,CAAT;EA9BJ;;EAoCA,QAAQd,YAAY,CAACF,SAAD,CAApB;IACE,KAAK,OAAL;MACEuB,MAAM,CAACL,QAAD,CAAN,IAAoBE,WAAW,IAAIX,GAAG,IAAIa,UAAP,GAAoB,CAAC,CAArB,GAAyB,CAA7B,CAA/B;MACA;;IAEF,KAAK,KAAL;MACEC,MAAM,CAACL,QAAD,CAAN,IAAoBE,WAAW,IAAIX,GAAG,IAAIa,UAAP,GAAoB,CAAC,CAArB,GAAyB,CAA7B,CAA/B;MACA;EAPJ;;EAUA,OAAOC,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMC,iBAAiB,GAAG,OAAOd,SAAP,EAAkBC,QAAlB,EAA4Bc,MAA5B,KAAuC;EAC/D,MAAM;IACJzB,SAAS,GAAG,QADR;IAEJ0B,QAAQ,GAAG,UAFP;IAGJC,UAAU,GAAG,EAHT;IAIJC;EAJI,IAKFH,MALJ;EAMA,MAAMhB,GAAG,GAAG,OAAOmB,QAAQ,CAACC,KAAT,IAAkB,IAAlB,GAAyB,KAAK,CAA9B,GAAkCD,QAAQ,CAACC,KAAT,CAAelB,QAAf,CAAzC,CAAZ;EAEA,IAAImB,KAAK,GAAG,MAAMF,QAAQ,CAACG,eAAT,CAAyB;IACzCrB,SADyC;IAEzCC,QAFyC;IAGzCe;EAHyC,CAAzB,CAAlB;EAKA,IAAI;IACFb,CADE;IAEFG;EAFE,IAGAT,0BAA0B,CAACuB,KAAD,EAAQ9B,SAAR,EAAmBS,GAAnB,CAH9B;EAIA,IAAIuB,iBAAiB,GAAGhC,SAAxB;EACA,IAAIiC,cAAc,GAAG,EAArB;EACA,IAAIC,UAAU,GAAG,CAAjB;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,UAAU,CAACR,MAA/B,EAAuCgB,CAAC,EAAxC,EAA4C;IAC1C,MAAM;MACJC,IADI;MAEJC;IAFI,IAGFV,UAAU,CAACQ,CAAD,CAHd;IAIA,MAAM;MACJtB,CAAC,EAAEyB,KADC;MAEJtB,CAAC,EAAEuB,KAFC;MAGJC,IAHI;MAIJC;IAJI,IAKF,MAAMJ,EAAE,CAAC;MACXxB,CADW;MAEXG,CAFW;MAGX0B,gBAAgB,EAAE1C,SAHP;MAIXA,SAAS,EAAEgC,iBAJA;MAKXN,QALW;MAMXO,cANW;MAOXH,KAPW;MAQXF,QARW;MASXe,QAAQ,EAAE;QACRjC,SADQ;QAERC;MAFQ;IATC,CAAD,CALZ;IAmBAE,CAAC,GAAGyB,KAAK,IAAI,IAAT,GAAgBA,KAAhB,GAAwBzB,CAA5B;IACAG,CAAC,GAAGuB,KAAK,IAAI,IAAT,GAAgBA,KAAhB,GAAwBvB,CAA5B;IACAiB,cAAc,GAAG,EAAE,GAAGA,cAAL;MACf,CAACG,IAAD,GAAQ,EAAE,GAAGH,cAAc,CAACG,IAAD,CAAnB;QACN,GAAGI;MADG;IADO,CAAjB;;IAMA,IAAIC,KAAK,IAAIP,UAAU,IAAI,EAA3B,EAA+B;MAC7BA,UAAU;;MAEV,IAAI,OAAOO,KAAP,KAAiB,QAArB,EAA+B;QAC7B,IAAIA,KAAK,CAACzC,SAAV,EAAqB;UACnBgC,iBAAiB,GAAGS,KAAK,CAACzC,SAA1B;QACD;;QAED,IAAIyC,KAAK,CAACX,KAAV,EAAiB;UACfA,KAAK,GAAGW,KAAK,CAACX,KAAN,KAAgB,IAAhB,GAAuB,MAAMF,QAAQ,CAACG,eAAT,CAAyB;YAC5DrB,SAD4D;YAE5DC,QAF4D;YAG5De;UAH4D,CAAzB,CAA7B,GAIHe,KAAK,CAACX,KAJX;QAKD;;QAED,CAAC;UACCjB,CADD;UAECG;QAFD,IAGGT,0BAA0B,CAACuB,KAAD,EAAQE,iBAAR,EAA2BvB,GAA3B,CAH9B;MAID;;MAED0B,CAAC,GAAG,CAAC,CAAL;MACA;IACD;EACF;;EAED,OAAO;IACLtB,CADK;IAELG,CAFK;IAGLhB,SAAS,EAAEgC,iBAHN;IAILN,QAJK;IAKLO;EALK,CAAP;AAOD,CAxFD;;AA0FA,SAASW,mBAAT,CAA6BC,OAA7B,EAAsC;EACpC,OAAO;IACLC,GAAG,EAAE,CADA;IAELC,KAAK,EAAE,CAFF;IAGLC,MAAM,EAAE,CAHH;IAILC,IAAI,EAAE,CAJD;IAKL,GAAGJ;EALE,CAAP;AAOD;;AAED,SAASK,wBAAT,CAAkCL,OAAlC,EAA2C;EACzC,OAAO,OAAOA,OAAP,KAAmB,QAAnB,GAA8BD,mBAAmB,CAACC,OAAD,CAAjD,GAA6D;IAClEC,GAAG,EAAED,OAD6D;IAElEE,KAAK,EAAEF,OAF2D;IAGlEG,MAAM,EAAEH,OAH0D;IAIlEI,IAAI,EAAEJ;EAJ4D,CAApE;AAMD;;AAED,SAASM,gBAAT,CAA0BC,IAA1B,EAAgC;EAC9B,OAAO,EAAE,GAAGA,IAAL;IACLN,GAAG,EAAEM,IAAI,CAACpC,CADL;IAELiC,IAAI,EAAEG,IAAI,CAACvC,CAFN;IAGLkC,KAAK,EAAEK,IAAI,CAACvC,CAAL,GAASuC,IAAI,CAACtC,KAHhB;IAILkC,MAAM,EAAEI,IAAI,CAACpC,CAAL,GAASoC,IAAI,CAACnC;EAJjB,CAAP;AAMD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeoC,cAAf,CAA8BC,mBAA9B,EAAmDC,OAAnD,EAA4D;EAC1D,IAAIC,qBAAJ;;EAEA,IAAID,OAAO,KAAK,KAAK,CAArB,EAAwB;IACtBA,OAAO,GAAG,EAAV;EACD;;EAED,MAAM;IACJ1C,CADI;IAEJG,CAFI;IAGJY,QAHI;IAIJE,KAJI;IAKJa,QALI;IAMJjB;EANI,IAOF4B,mBAPJ;EAQA,MAAM;IACJG,QAAQ,GAAG,mBADP;IAEJC,YAAY,GAAG,UAFX;IAGJC,cAAc,GAAG,UAHb;IAIJC,WAAW,GAAG,KAJV;IAKJf,OAAO,GAAG;EALN,IAMFU,OANJ;EAOA,MAAMM,aAAa,GAAGX,wBAAwB,CAACL,OAAD,CAA9C;EACA,MAAMiB,UAAU,GAAGH,cAAc,KAAK,UAAnB,GAAgC,WAAhC,GAA8C,UAAjE;EACA,MAAMI,OAAO,GAAGpB,QAAQ,CAACiB,WAAW,GAAGE,UAAH,GAAgBH,cAA5B,CAAxB;EACA,MAAMK,kBAAkB,GAAGb,gBAAgB,CAAC,MAAMvB,QAAQ,CAACqC,eAAT,CAAyB;IACzEF,OAAO,EAAE,CAAC,CAACP,qBAAqB,GAAG,OAAO5B,QAAQ,CAACsC,SAAT,IAAsB,IAAtB,GAA6B,KAAK,CAAlC,GAAsCtC,QAAQ,CAACsC,SAAT,CAAmBH,OAAnB,CAA7C,CAAzB,KAAuG,IAAvG,GAA8GP,qBAA9G,GAAsI,IAAvI,IAA+IO,OAA/I,GAAyJA,OAAO,CAACI,cAAR,KAA2B,OAAOvC,QAAQ,CAACwC,kBAAT,IAA+B,IAA/B,GAAsC,KAAK,CAA3C,GAA+CxC,QAAQ,CAACwC,kBAAT,CAA4BzB,QAAQ,CAAChC,QAArC,CAAtD,CAA3B,CADzF;IAEzE8C,QAFyE;IAGzEC,YAHyE;IAIzEhC;EAJyE,CAAzB,CAAP,CAA3C;EAMA,MAAM2C,iBAAiB,GAAGlB,gBAAgB,CAACvB,QAAQ,CAAC0C,qDAAT,GAAiE,MAAM1C,QAAQ,CAAC0C,qDAAT,CAA+D;IAC/KlB,IAAI,EAAEO,cAAc,KAAK,UAAnB,GAAgC,EAAE,GAAG7B,KAAK,CAACnB,QAAX;MACpCE,CADoC;MAEpCG;IAFoC,CAAhC,GAGFc,KAAK,CAACpB,SAJqK;IAK/K6D,YAAY,EAAE,OAAO3C,QAAQ,CAAC4C,eAAT,IAA4B,IAA5B,GAAmC,KAAK,CAAxC,GAA4C5C,QAAQ,CAAC4C,eAAT,CAAyB7B,QAAQ,CAAChC,QAAlC,CAAnD,CALiK;IAM/Ke;EAN+K,CAA/D,CAAvE,GAOtCI,KAAK,CAAC6B,cAAD,CAPgC,CAA1C;EAQA,OAAO;IACLb,GAAG,EAAEkB,kBAAkB,CAAClB,GAAnB,GAAyBuB,iBAAiB,CAACvB,GAA3C,GAAiDe,aAAa,CAACf,GAD/D;IAELE,MAAM,EAAEqB,iBAAiB,CAACrB,MAAlB,GAA2BgB,kBAAkB,CAAChB,MAA9C,GAAuDa,aAAa,CAACb,MAFxE;IAGLC,IAAI,EAAEe,kBAAkB,CAACf,IAAnB,GAA0BoB,iBAAiB,CAACpB,IAA5C,GAAmDY,aAAa,CAACZ,IAHlE;IAILF,KAAK,EAAEsB,iBAAiB,CAACtB,KAAlB,GAA0BiB,kBAAkB,CAACjB,KAA7C,GAAqDc,aAAa,CAACd;EAJrE,CAAP;AAMD;;AAED,MAAM0B,KAAK,GAAGC,IAAI,CAACC,GAAnB;AACA,MAAMC,KAAK,GAAGF,IAAI,CAACG,GAAnB;;AAEA,SAASC,MAAT,CAAgBC,OAAhB,EAAyBC,KAAzB,EAAgCC,OAAhC,EAAyC;EACvC,OAAOL,KAAK,CAACG,OAAD,EAAUN,KAAK,CAACO,KAAD,EAAQC,OAAR,CAAf,CAAZ;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,MAAMC,KAAK,GAAG3B,OAAO,KAAK;EACxBnB,IAAI,EAAE,OADkB;EAExBmB,OAFwB;;EAIxB,MAAMlB,EAAN,CAASiB,mBAAT,EAA8B;IAC5B;IACA,MAAM;MACJS,OADI;MAEJlB,OAAO,GAAG;IAFN,IAGFU,OAAO,IAAI,IAAX,GAAkBA,OAAlB,GAA4B,EAHhC;IAIA,MAAM;MACJ1C,CADI;MAEJG,CAFI;MAGJhB,SAHI;MAIJ8B,KAJI;MAKJF;IALI,IAMF0B,mBANJ;;IAQA,IAAIS,OAAO,IAAI,IAAf,EAAqB;MAEnB,OAAO,EAAP;IACD;;IAED,MAAMF,aAAa,GAAGX,wBAAwB,CAACL,OAAD,CAA9C;IACA,MAAMtB,MAAM,GAAG;MACbV,CADa;MAEbG;IAFa,CAAf;IAIA,MAAMV,IAAI,GAAGH,wBAAwB,CAACH,SAAD,CAArC;IACA,MAAMmF,SAAS,GAAGjF,YAAY,CAACF,SAAD,CAA9B;IACA,MAAMmB,MAAM,GAAGd,iBAAiB,CAACC,IAAD,CAAhC;IACA,MAAM8E,eAAe,GAAG,MAAMxD,QAAQ,CAACyD,aAAT,CAAuBtB,OAAvB,CAA9B;IACA,MAAMuB,OAAO,GAAGhF,IAAI,KAAK,GAAT,GAAe,KAAf,GAAuB,MAAvC;IACA,MAAMiF,OAAO,GAAGjF,IAAI,KAAK,GAAT,GAAe,QAAf,GAA0B,OAA1C;IACA,MAAMkF,OAAO,GAAG1D,KAAK,CAACpB,SAAN,CAAgBS,MAAhB,IAA0BW,KAAK,CAACpB,SAAN,CAAgBJ,IAAhB,CAA1B,GAAkDiB,MAAM,CAACjB,IAAD,CAAxD,GAAiEwB,KAAK,CAACnB,QAAN,CAAeQ,MAAf,CAAjF;IACA,MAAMsE,SAAS,GAAGlE,MAAM,CAACjB,IAAD,CAAN,GAAewB,KAAK,CAACpB,SAAN,CAAgBJ,IAAhB,CAAjC;IACA,MAAMoF,iBAAiB,GAAG,OAAO9D,QAAQ,CAAC4C,eAAT,IAA4B,IAA5B,GAAmC,KAAK,CAAxC,GAA4C5C,QAAQ,CAAC4C,eAAT,CAAyBT,OAAzB,CAAnD,CAA1B;IACA,IAAI4B,UAAU,GAAGD,iBAAiB,GAAGpF,IAAI,KAAK,GAAT,GAAeoF,iBAAiB,CAACE,YAAlB,IAAkC,CAAjD,GAAqDF,iBAAiB,CAACG,WAAlB,IAAiC,CAAzF,GAA6F,CAA/H;;IAEA,IAAIF,UAAU,KAAK,CAAnB,EAAsB;MACpBA,UAAU,GAAG7D,KAAK,CAACnB,QAAN,CAAeQ,MAAf,CAAb;IACD;;IAED,MAAM2E,iBAAiB,GAAGN,OAAO,GAAG,CAAV,GAAcC,SAAS,GAAG,CAApD,CAvC4B,CAuC2B;IACvD;;IAEA,MAAMd,GAAG,GAAGd,aAAa,CAACyB,OAAD,CAAzB;IACA,MAAMT,GAAG,GAAGc,UAAU,GAAGP,eAAe,CAACjE,MAAD,CAA5B,GAAuC0C,aAAa,CAAC0B,OAAD,CAAhE;IACA,MAAMQ,MAAM,GAAGJ,UAAU,GAAG,CAAb,GAAiBP,eAAe,CAACjE,MAAD,CAAf,GAA0B,CAA3C,GAA+C2E,iBAA9D;IACA,MAAME,MAAM,GAAGlB,MAAM,CAACH,GAAD,EAAMoB,MAAN,EAAclB,GAAd,CAArB,CA7C4B,CA6Ca;;IAEzC,MAAMoB,gBAAgB,GAAGd,SAAS,KAAK,OAAd,GAAwBtB,aAAa,CAACyB,OAAD,CAArC,GAAiDzB,aAAa,CAAC0B,OAAD,CAAvF;IACA,MAAMW,eAAe,GAAGD,gBAAgB,GAAG,CAAnB,IAAwBF,MAAM,KAAKC,MAAnC,IAA6ClE,KAAK,CAACpB,SAAN,CAAgBS,MAAhB,KAA2BW,KAAK,CAACnB,QAAN,CAAeQ,MAAf,CAAhG;IACA,MAAMgF,eAAe,GAAGD,eAAe,GAAGH,MAAM,GAAGpB,GAAT,GAAeA,GAAG,GAAGoB,MAArB,GAA8BlB,GAAG,GAAGkB,MAAvC,GAAgD,CAAvF;IACA,OAAO;MACL,CAACzF,IAAD,GAAQiB,MAAM,CAACjB,IAAD,CAAN,GAAe6F,eADlB;MAEL3D,IAAI,EAAE;QACJ,CAAClC,IAAD,GAAQ0F,MADJ;QAEJI,YAAY,EAAEL,MAAM,GAAGC;MAFnB;IAFD,CAAP;EAOD;;AA7DuB,CAAL,CAArB;;AAiEA,MAAMK,MAAM,GAAG;EACbpD,IAAI,EAAE,OADO;EAEbF,KAAK,EAAE,MAFM;EAGbC,MAAM,EAAE,KAHK;EAIbF,GAAG,EAAE;AAJQ,CAAf;;AAMA,SAASwD,oBAAT,CAA8BtG,SAA9B,EAAyC;EACvC,OAAOA,SAAS,CAACuG,OAAV,CAAkB,wBAAlB,EAA4CC,OAAO,IAAIH,MAAM,CAACG,OAAD,CAA7D,CAAP;AACD;;AAED,SAASC,iBAAT,CAA2BzG,SAA3B,EAAsC8B,KAAtC,EAA6CrB,GAA7C,EAAkD;EAChD,IAAIA,GAAG,KAAK,KAAK,CAAjB,EAAoB;IAClBA,GAAG,GAAG,KAAN;EACD;;EAED,MAAM0E,SAAS,GAAGjF,YAAY,CAACF,SAAD,CAA9B;EACA,MAAMkB,QAAQ,GAAGf,wBAAwB,CAACH,SAAD,CAAzC;EACA,MAAMmB,MAAM,GAAGd,iBAAiB,CAACa,QAAD,CAAhC;EACA,IAAIwF,iBAAiB,GAAGxF,QAAQ,KAAK,GAAb,GAAmBiE,SAAS,MAAM1E,GAAG,GAAG,KAAH,GAAW,OAApB,CAAT,GAAwC,OAAxC,GAAkD,MAArE,GAA8E0E,SAAS,KAAK,OAAd,GAAwB,QAAxB,GAAmC,KAAzI;;EAEA,IAAIrD,KAAK,CAACpB,SAAN,CAAgBS,MAAhB,IAA0BW,KAAK,CAACnB,QAAN,CAAeQ,MAAf,CAA9B,EAAsD;IACpDuF,iBAAiB,GAAGJ,oBAAoB,CAACI,iBAAD,CAAxC;EACD;;EAED,OAAO;IACLC,IAAI,EAAED,iBADD;IAELE,KAAK,EAAEN,oBAAoB,CAACI,iBAAD;EAFtB,CAAP;AAID;;AAED,MAAMG,IAAI,GAAG;EACXC,KAAK,EAAE,KADI;EAEXC,GAAG,EAAE;AAFM,CAAb;;AAIA,SAASC,6BAAT,CAAuChH,SAAvC,EAAkD;EAChD,OAAOA,SAAS,CAACuG,OAAV,CAAkB,YAAlB,EAAgCC,OAAO,IAAIK,IAAI,CAACL,OAAD,CAA/C,CAAP;AACD;;AAED,MAAMS,KAAK,GAAG,CAAC,KAAD,EAAQ,OAAR,EAAiB,QAAjB,EAA2B,MAA3B,CAAd;AACA,MAAMC,aAAa,GAAG,aAAaD,KAAK,CAACE,MAAN,CAAa,CAACC,GAAD,EAAM/F,IAAN,KAAe+F,GAAG,CAACC,MAAJ,CAAWhG,IAAX,EAAiBA,IAAI,GAAG,QAAxB,EAAkCA,IAAI,GAAG,MAAzC,CAA5B,EAA8E,EAA9E,CAAnC;;AAEA,SAASiG,gBAAT,CAA0BnC,SAA1B,EAAqCoC,aAArC,EAAoDC,iBAApD,EAAuE;EACrE,MAAMC,kCAAkC,GAAGtC,SAAS,GAAG,CAAC,GAAGqC,iBAAiB,CAACE,MAAlB,CAAyB1H,SAAS,IAAIE,YAAY,CAACF,SAAD,CAAZ,KAA4BmF,SAAlE,CAAJ,EAAkF,GAAGqC,iBAAiB,CAACE,MAAlB,CAAyB1H,SAAS,IAAIE,YAAY,CAACF,SAAD,CAAZ,KAA4BmF,SAAlE,CAArF,CAAH,GAAwKqC,iBAAiB,CAACE,MAAlB,CAAyB1H,SAAS,IAAID,OAAO,CAACC,SAAD,CAAP,KAAuBA,SAA7D,CAA5N;EACA,OAAOyH,kCAAkC,CAACC,MAAnC,CAA0C1H,SAAS,IAAI;IAC5D,IAAImF,SAAJ,EAAe;MACb,OAAOjF,YAAY,CAACF,SAAD,CAAZ,KAA4BmF,SAA5B,KAA0CoC,aAAa,GAAGP,6BAA6B,CAAChH,SAAD,CAA7B,KAA6CA,SAAhD,GAA4D,KAAnH,CAAP;IACD;;IAED,OAAO,IAAP;EACD,CANM,CAAP;AAOD;AAED;AACA;AACA;AACA;;;AACA,MAAM2H,aAAa,GAAG,UAAUpE,OAAV,EAAmB;EACvC,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IACtBA,OAAO,GAAG,EAAV;EACD;;EAED,OAAO;IACLnB,IAAI,EAAE,eADD;IAELmB,OAFK;;IAIL,MAAMlB,EAAN,CAASiB,mBAAT,EAA8B;MAC5B,IAAIsE,qBAAJ,EAA2BC,sBAA3B,EAAmDC,sBAAnD,EAA2EC,sBAA3E,EAAmGC,qBAAnG;;MAEA,MAAM;QACJnH,CADI;QAEJG,CAFI;QAGJc,KAHI;QAIJG,cAJI;QAKJjC,SALI;QAMJ4B,QANI;QAOJe;MAPI,IAQFW,mBARJ;MASA,MAAM;QACJ6B,SAAS,GAAG,IADR;QAEJqC,iBAAiB,GAAGN,aAFhB;QAGJK,aAAa,GAAG,IAHZ;QAIJ,GAAGU;MAJC,IAKF1E,OALJ;MAMA,MAAM2E,UAAU,GAAGZ,gBAAgB,CAACnC,SAAD,EAAYoC,aAAZ,EAA2BC,iBAA3B,CAAnC;MACA,MAAMW,QAAQ,GAAG,MAAM9E,cAAc,CAACC,mBAAD,EAAsB2E,qBAAtB,CAArC;MACA,MAAMG,YAAY,GAAG,CAACR,qBAAqB,GAAG,CAACC,sBAAsB,GAAG5F,cAAc,CAAC0F,aAAzC,KAA2D,IAA3D,GAAkE,KAAK,CAAvE,GAA2EE,sBAAsB,CAACQ,KAA3H,KAAqI,IAArI,GAA4IT,qBAA5I,GAAoK,CAAzL;MACA,MAAMU,gBAAgB,GAAGJ,UAAU,CAACE,YAAD,CAAnC;;MAEA,IAAIE,gBAAgB,IAAI,IAAxB,EAA8B;QAC5B,OAAO,EAAP;MACD;;MAED,MAAM;QACJ3B,IADI;QAEJC;MAFI,IAGFH,iBAAiB,CAAC6B,gBAAD,EAAmBxG,KAAnB,EAA0B,OAAOF,QAAQ,CAACC,KAAT,IAAkB,IAAlB,GAAyB,KAAK,CAA9B,GAAkCD,QAAQ,CAACC,KAAT,CAAec,QAAQ,CAAChC,QAAxB,CAAzC,CAA1B,CAHrB,CA3B4B,CA8BiG;;MAE7H,IAAIX,SAAS,KAAKsI,gBAAlB,EAAoC;QAClC,OAAO;UACLzH,CADK;UAELG,CAFK;UAGLyB,KAAK,EAAE;YACLzC,SAAS,EAAEkI,UAAU,CAAC,CAAD;UADhB;QAHF,CAAP;MAOD;;MAED,MAAMK,gBAAgB,GAAG,CAACJ,QAAQ,CAACpI,OAAO,CAACuI,gBAAD,CAAR,CAAT,EAAsCH,QAAQ,CAACxB,IAAD,CAA9C,EAAsDwB,QAAQ,CAACvB,KAAD,CAA9D,CAAzB;MACA,MAAM4B,YAAY,GAAG,CAAC,IAAI,CAACV,sBAAsB,GAAG,CAACC,sBAAsB,GAAG9F,cAAc,CAAC0F,aAAzC,KAA2D,IAA3D,GAAkE,KAAK,CAAvE,GAA2EI,sBAAsB,CAACU,SAA5H,KAA0I,IAA1I,GAAiJX,sBAAjJ,GAA0K,EAA9K,CAAD,EAAoL;QACvM9H,SAAS,EAAEsI,gBAD4L;QAEvMG,SAAS,EAAEF;MAF4L,CAApL,CAArB;MAIA,MAAMG,aAAa,GAAGR,UAAU,CAACE,YAAY,GAAG,CAAhB,CAAhC,CA/C4B,CA+CwB;;MAEpD,IAAIM,aAAJ,EAAmB;QACjB,OAAO;UACLlG,IAAI,EAAE;YACJ6F,KAAK,EAAED,YAAY,GAAG,CADlB;YAEJK,SAAS,EAAED;UAFP,CADD;UAKL/F,KAAK,EAAE;YACLzC,SAAS,EAAE0I;UADN;QALF,CAAP;MASD;;MAED,MAAMC,+BAA+B,GAAGH,YAAY,CAACI,KAAb,GAAqBC,IAArB,CAA0B,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACL,SAAF,CAAY,CAAZ,IAAiBM,CAAC,CAACN,SAAF,CAAY,CAAZ,CAArD,CAAxC;MACA,MAAMO,2BAA2B,GAAG,CAAChB,qBAAqB,GAAGW,+BAA+B,CAACM,IAAhC,CAAqCzI,IAAI,IAAI;QACxG,IAAI;UACFiI;QADE,IAEAjI,IAFJ;QAGA,OAAOiI,SAAS,CAACS,KAAV,CAAgBf,QAAQ,IAAIA,QAAQ,IAAI,CAAxC,CAAP;MACD,CAL4D,CAAzB,KAK7B,IAL6B,GAKtB,KAAK,CALiB,GAKbH,qBAAqB,CAAChI,SAL7C;MAMA,MAAMmJ,cAAc,GAAGH,2BAA2B,IAAI,IAA/B,GAAsCA,2BAAtC,GAAoEL,+BAA+B,CAAC,CAAD,CAA/B,CAAmC3I,SAA9H;;MAEA,IAAImJ,cAAc,KAAKnJ,SAAvB,EAAkC;QAChC,OAAO;UACLwC,IAAI,EAAE;YACJ6F,KAAK,EAAED,YAAY,GAAG,CADlB;YAEJK,SAAS,EAAED;UAFP,CADD;UAKL/F,KAAK,EAAE;YACLzC,SAAS,EAAEmJ;UADN;QALF,CAAP;MASD;;MAED,OAAO,EAAP;IACD;;EAvFI,CAAP;AA0FD,CA/FD;;AAiGA,SAASC,qBAAT,CAA+BpJ,SAA/B,EAA0C;EACxC,MAAMqJ,iBAAiB,GAAG/C,oBAAoB,CAACtG,SAAD,CAA9C;EACA,OAAO,CAACgH,6BAA6B,CAAChH,SAAD,CAA9B,EAA2CqJ,iBAA3C,EAA8DrC,6BAA6B,CAACqC,iBAAD,CAA3F,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,MAAMC,IAAI,GAAG,UAAU/F,OAAV,EAAmB;EAC9B,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IACtBA,OAAO,GAAG,EAAV;EACD;;EAED,OAAO;IACLnB,IAAI,EAAE,MADD;IAELmB,OAFK;;IAIL,MAAMlB,EAAN,CAASiB,mBAAT,EAA8B;MAC5B,IAAIiG,oBAAJ;;MAEA,MAAM;QACJvJ,SADI;QAEJiC,cAFI;QAGJH,KAHI;QAIJY,gBAJI;QAKJd,QALI;QAMJe;MANI,IAOFW,mBAPJ;MAQA,MAAM;QACJpC,QAAQ,EAAEsI,aAAa,GAAG,IADtB;QAEJC,SAAS,EAAEC,cAAc,GAAG,IAFxB;QAGJC,kBAAkB,EAAEC,2BAHhB;QAIJC,gBAAgB,GAAG,SAJf;QAKJC,aAAa,GAAG,IALZ;QAMJ,GAAG7B;MANC,IAOF1E,OAPJ;MAQA,MAAMlC,IAAI,GAAGtB,OAAO,CAACC,SAAD,CAApB;MACA,MAAM+J,eAAe,GAAG1I,IAAI,KAAKqB,gBAAjC;MACA,MAAMiH,kBAAkB,GAAGC,2BAA2B,KAAKG,eAAe,IAAI,CAACD,aAApB,GAAoC,CAACxD,oBAAoB,CAAC5D,gBAAD,CAArB,CAApC,GAA+E0G,qBAAqB,CAAC1G,gBAAD,CAAzG,CAAtD;MACA,MAAMwF,UAAU,GAAG,CAACxF,gBAAD,EAAmB,GAAGiH,kBAAtB,CAAnB;MACA,MAAMxB,QAAQ,GAAG,MAAM9E,cAAc,CAACC,mBAAD,EAAsB2E,qBAAtB,CAArC;MACA,MAAMQ,SAAS,GAAG,EAAlB;MACA,IAAIuB,aAAa,GAAG,CAAC,CAACT,oBAAoB,GAAGtH,cAAc,CAACqH,IAAvC,KAAgD,IAAhD,GAAuD,KAAK,CAA5D,GAAgEC,oBAAoB,CAACd,SAAtF,KAAoG,EAAxH;;MAEA,IAAIe,aAAJ,EAAmB;QACjBf,SAAS,CAACwB,IAAV,CAAe9B,QAAQ,CAAC9G,IAAD,CAAvB;MACD;;MAED,IAAIqI,cAAJ,EAAoB;QAClB,MAAM;UACJ/C,IADI;UAEJC;QAFI,IAGFH,iBAAiB,CAACzG,SAAD,EAAY8B,KAAZ,EAAmB,OAAOF,QAAQ,CAACC,KAAT,IAAkB,IAAlB,GAAyB,KAAK,CAA9B,GAAkCD,QAAQ,CAACC,KAAT,CAAec,QAAQ,CAAChC,QAAxB,CAAzC,CAAnB,CAHrB;QAIA8H,SAAS,CAACwB,IAAV,CAAe9B,QAAQ,CAACxB,IAAD,CAAvB,EAA+BwB,QAAQ,CAACvB,KAAD,CAAvC;MACD;;MAEDoD,aAAa,GAAG,CAAC,GAAGA,aAAJ,EAAmB;QACjChK,SADiC;QAEjCyI;MAFiC,CAAnB,CAAhB,CAvC4B,CA0CxB;;MAEJ,IAAI,CAACA,SAAS,CAACS,KAAV,CAAgB7H,IAAI,IAAIA,IAAI,IAAI,CAAhC,CAAL,EAAyC;QACvC,IAAI6I,qBAAJ,EAA2BC,qBAA3B;;QAEA,MAAMC,SAAS,GAAG,CAAC,CAACF,qBAAqB,GAAG,CAACC,qBAAqB,GAAGlI,cAAc,CAACqH,IAAxC,KAAiD,IAAjD,GAAwD,KAAK,CAA7D,GAAiEa,qBAAqB,CAAC9B,KAAhH,KAA0H,IAA1H,GAAiI6B,qBAAjI,GAAyJ,CAA1J,IAA+J,CAAjL;QACA,MAAMxB,aAAa,GAAGR,UAAU,CAACkC,SAAD,CAAhC;;QAEA,IAAI1B,aAAJ,EAAmB;UACjB;UACA,OAAO;YACLlG,IAAI,EAAE;cACJ6F,KAAK,EAAE+B,SADH;cAEJ3B,SAAS,EAAEuB;YAFP,CADD;YAKLvH,KAAK,EAAE;cACLzC,SAAS,EAAE0I;YADN;UALF,CAAP;QASD;;QAED,IAAIS,cAAc,GAAG,QAArB;;QAEA,QAAQU,gBAAR;UACE,KAAK,SAAL;YACE;cACE,IAAIQ,qBAAJ;;cAEA,MAAMrK,SAAS,GAAG,CAACqK,qBAAqB,GAAGL,aAAa,CAACM,GAAd,CAAkBzK,CAAC,IAAI,CAACA,CAAD,EAAIA,CAAC,CAAC4I,SAAF,CAAYf,MAAZ,CAAmBS,QAAQ,IAAIA,QAAQ,GAAG,CAA1C,EAA6ChB,MAA7C,CAAoD,CAACC,GAAD,EAAMe,QAAN,KAAmBf,GAAG,GAAGe,QAA7E,EAAuF,CAAvF,CAAJ,CAAvB,EAAuHU,IAAvH,CAA4H,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAA9I,EAAmJ,CAAnJ,CAAzB,KAAmL,IAAnL,GAA0L,KAAK,CAA/L,GAAmMsB,qBAAqB,CAAC,CAAD,CAArB,CAAyBrK,SAA9O;;cAEA,IAAIA,SAAJ,EAAe;gBACbmJ,cAAc,GAAGnJ,SAAjB;cACD;;cAED;YACD;;UAEH,KAAK,kBAAL;YACEmJ,cAAc,GAAGzG,gBAAjB;YACA;QAhBJ;;QAmBA,IAAI1C,SAAS,KAAKmJ,cAAlB,EAAkC;UAChC,OAAO;YACL1G,KAAK,EAAE;cACLzC,SAAS,EAAEmJ;YADN;UADF,CAAP;QAKD;MACF;;MAED,OAAO,EAAP;IACD;;EAlGI,CAAP;AAqGD,CA1GD;;AA4GA,SAASoB,cAAT,CAAwBpC,QAAxB,EAAkC/E,IAAlC,EAAwC;EACtC,OAAO;IACLN,GAAG,EAAEqF,QAAQ,CAACrF,GAAT,GAAeM,IAAI,CAACnC,MADpB;IAEL8B,KAAK,EAAEoF,QAAQ,CAACpF,KAAT,GAAiBK,IAAI,CAACtC,KAFxB;IAGLkC,MAAM,EAAEmF,QAAQ,CAACnF,MAAT,GAAkBI,IAAI,CAACnC,MAH1B;IAILgC,IAAI,EAAEkF,QAAQ,CAAClF,IAAT,GAAgBG,IAAI,CAACtC;EAJtB,CAAP;AAMD;;AAED,SAAS0J,qBAAT,CAA+BrC,QAA/B,EAAyC;EACvC,OAAOlB,KAAK,CAACwD,IAAN,CAAWpJ,IAAI,IAAI8G,QAAQ,CAAC9G,IAAD,CAAR,IAAkB,CAArC,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,MAAMqJ,IAAI,GAAG,UAAUC,KAAV,EAAiB;EAC5B,IAAI;IACFjJ,QAAQ,GAAG,iBADT;IAEF,GAAGuG;EAFD,IAGA0C,KAAK,KAAK,KAAK,CAAf,GAAmB,EAAnB,GAAwBA,KAH5B;EAIA,OAAO;IACLvI,IAAI,EAAE,MADD;;IAGL,MAAMC,EAAN,CAASiB,mBAAT,EAA8B;MAC5B,MAAM;QACJxB;MADI,IAEFwB,mBAFJ;;MAIA,QAAQ5B,QAAR;QACE,KAAK,iBAAL;UACE;YACE,MAAMyG,QAAQ,GAAG,MAAM9E,cAAc,CAACC,mBAAD,EAAsB,EAAE,GAAG2E,qBAAL;cACzDtE,cAAc,EAAE;YADyC,CAAtB,CAArC;YAGA,MAAMiH,OAAO,GAAGL,cAAc,CAACpC,QAAD,EAAWrG,KAAK,CAACpB,SAAjB,CAA9B;YACA,OAAO;cACL8B,IAAI,EAAE;gBACJqI,sBAAsB,EAAED,OADpB;gBAEJE,eAAe,EAAEN,qBAAqB,CAACI,OAAD;cAFlC;YADD,CAAP;UAMD;;QAEH,KAAK,SAAL;UACE;YACE,MAAMzC,QAAQ,GAAG,MAAM9E,cAAc,CAACC,mBAAD,EAAsB,EAAE,GAAG2E,qBAAL;cACzDrE,WAAW,EAAE;YAD4C,CAAtB,CAArC;YAGA,MAAMgH,OAAO,GAAGL,cAAc,CAACpC,QAAD,EAAWrG,KAAK,CAACnB,QAAjB,CAA9B;YACA,OAAO;cACL6B,IAAI,EAAE;gBACJuI,cAAc,EAAEH,OADZ;gBAEJI,OAAO,EAAER,qBAAqB,CAACI,OAAD;cAF1B;YADD,CAAP;UAMD;;QAEH;UACE;YACE,OAAO,EAAP;UACD;MAhCL;IAkCD;;EA1CI,CAAP;AA6CD,CAlDD;;AAoDA,eAAeK,oBAAf,CAAoC3H,mBAApC,EAAyD0B,KAAzD,EAAgE;EAC9D,MAAM;IACJhF,SADI;IAEJ4B,QAFI;IAGJe;EAHI,IAIFW,mBAJJ;EAKA,MAAM7C,GAAG,GAAG,OAAOmB,QAAQ,CAACC,KAAT,IAAkB,IAAlB,GAAyB,KAAK,CAA9B,GAAkCD,QAAQ,CAACC,KAAT,CAAec,QAAQ,CAAChC,QAAxB,CAAzC,CAAZ;EACA,MAAMU,IAAI,GAAGtB,OAAO,CAACC,SAAD,CAApB;EACA,MAAMmF,SAAS,GAAGjF,YAAY,CAACF,SAAD,CAA9B;EACA,MAAMsB,UAAU,GAAGnB,wBAAwB,CAACH,SAAD,CAAxB,KAAwC,GAA3D;EACA,MAAMkL,aAAa,GAAG,CAAC,MAAD,EAAS,KAAT,EAAgB9K,QAAhB,CAAyBiB,IAAzB,IAAiC,CAAC,CAAlC,GAAsC,CAA5D;EACA,MAAM8J,cAAc,GAAG1K,GAAG,IAAIa,UAAP,GAAoB,CAAC,CAArB,GAAyB,CAAhD;EACA,MAAM8J,QAAQ,GAAG,OAAOpG,KAAP,KAAiB,UAAjB,GAA8BA,KAAK,CAAC1B,mBAAD,CAAnC,GAA2D0B,KAA5E,CAZ8D,CAYqB;;EAEnF,IAAI;IACF9D,QADE;IAEFuI,SAFE;IAGF4B;EAHE,IAIA,OAAOD,QAAP,KAAoB,QAApB,GAA+B;IACjClK,QAAQ,EAAEkK,QADuB;IAEjC3B,SAAS,EAAE,CAFsB;IAGjC4B,aAAa,EAAE;EAHkB,CAA/B,GAIA;IACFnK,QAAQ,EAAE,CADR;IAEFuI,SAAS,EAAE,CAFT;IAGF4B,aAAa,EAAE,IAHb;IAIF,GAAGD;EAJD,CARJ;;EAeA,IAAIjG,SAAS,IAAI,OAAOkG,aAAP,KAAyB,QAA1C,EAAoD;IAClD5B,SAAS,GAAGtE,SAAS,KAAK,KAAd,GAAsBkG,aAAa,GAAG,CAAC,CAAvC,GAA2CA,aAAvD;EACD;;EAED,OAAO/J,UAAU,GAAG;IAClBT,CAAC,EAAE4I,SAAS,GAAG0B,cADG;IAElBnK,CAAC,EAAEE,QAAQ,GAAGgK;EAFI,CAAH,GAGb;IACFrK,CAAC,EAAEK,QAAQ,GAAGgK,aADZ;IAEFlK,CAAC,EAAEyI,SAAS,GAAG0B;EAFb,CAHJ;AAOD;AACD;AACA;AACA;AACA;;;AAEA,MAAMnF,MAAM,GAAG,UAAUhB,KAAV,EAAiB;EAC9B,IAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;IACpBA,KAAK,GAAG,CAAR;EACD;;EAED,OAAO;IACL5C,IAAI,EAAE,QADD;IAELmB,OAAO,EAAEyB,KAFJ;;IAIL,MAAM3C,EAAN,CAASiB,mBAAT,EAA8B;MAC5B,MAAM;QACJzC,CADI;QAEJG;MAFI,IAGFsC,mBAHJ;MAIA,MAAMgI,UAAU,GAAG,MAAML,oBAAoB,CAAC3H,mBAAD,EAAsB0B,KAAtB,CAA7C;MACA,OAAO;QACLnE,CAAC,EAAEA,CAAC,GAAGyK,UAAU,CAACzK,CADb;QAELG,CAAC,EAAEA,CAAC,GAAGsK,UAAU,CAACtK,CAFb;QAGLwB,IAAI,EAAE8I;MAHD,CAAP;IAKD;;EAfI,CAAP;AAkBD,CAvBD;;AAyBA,SAASC,YAAT,CAAsBjL,IAAtB,EAA4B;EAC1B,OAAOA,IAAI,KAAK,GAAT,GAAe,GAAf,GAAqB,GAA5B;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,MAAMkL,KAAK,GAAG,UAAUjI,OAAV,EAAmB;EAC/B,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IACtBA,OAAO,GAAG,EAAV;EACD;;EAED,OAAO;IACLnB,IAAI,EAAE,OADD;IAELmB,OAFK;;IAIL,MAAMlB,EAAN,CAASiB,mBAAT,EAA8B;MAC5B,MAAM;QACJzC,CADI;QAEJG,CAFI;QAGJhB;MAHI,IAIFsD,mBAJJ;MAKA,MAAM;QACJpC,QAAQ,EAAEsI,aAAa,GAAG,IADtB;QAEJC,SAAS,EAAEC,cAAc,GAAG,KAFxB;QAGJ+B,OAAO,GAAG;UACRpJ,EAAE,EAAE7B,IAAI,IAAI;YACV,IAAI;cACFK,CADE;cAEFG;YAFE,IAGAR,IAHJ;YAIA,OAAO;cACLK,CADK;cAELG;YAFK,CAAP;UAID;QAVO,CAHN;QAeJ,GAAGiH;MAfC,IAgBF1E,OAhBJ;MAiBA,MAAMhC,MAAM,GAAG;QACbV,CADa;QAEbG;MAFa,CAAf;MAIA,MAAMmH,QAAQ,GAAG,MAAM9E,cAAc,CAACC,mBAAD,EAAsB2E,qBAAtB,CAArC;MACA,MAAM/G,QAAQ,GAAGf,wBAAwB,CAACJ,OAAO,CAACC,SAAD,CAAR,CAAzC;MACA,MAAMyJ,SAAS,GAAG8B,YAAY,CAACrK,QAAD,CAA9B;MACA,IAAIwK,aAAa,GAAGnK,MAAM,CAACL,QAAD,CAA1B;MACA,IAAIyK,cAAc,GAAGpK,MAAM,CAACkI,SAAD,CAA3B;;MAEA,IAAID,aAAJ,EAAmB;QACjB,MAAMoC,OAAO,GAAG1K,QAAQ,KAAK,GAAb,GAAmB,KAAnB,GAA2B,MAA3C;QACA,MAAM2K,OAAO,GAAG3K,QAAQ,KAAK,GAAb,GAAmB,QAAnB,GAA8B,OAA9C;QACA,MAAMyD,GAAG,GAAG+G,aAAa,GAAGvD,QAAQ,CAACyD,OAAD,CAApC;QACA,MAAM/G,GAAG,GAAG6G,aAAa,GAAGvD,QAAQ,CAAC0D,OAAD,CAApC;QACAH,aAAa,GAAG5G,MAAM,CAACH,GAAD,EAAM+G,aAAN,EAAqB7G,GAArB,CAAtB;MACD;;MAED,IAAI6E,cAAJ,EAAoB;QAClB,MAAMkC,OAAO,GAAGnC,SAAS,KAAK,GAAd,GAAoB,KAApB,GAA4B,MAA5C;QACA,MAAMoC,OAAO,GAAGpC,SAAS,KAAK,GAAd,GAAoB,QAApB,GAA+B,OAA/C;QACA,MAAM9E,GAAG,GAAGgH,cAAc,GAAGxD,QAAQ,CAACyD,OAAD,CAArC;QACA,MAAM/G,GAAG,GAAG8G,cAAc,GAAGxD,QAAQ,CAAC0D,OAAD,CAArC;QACAF,cAAc,GAAG7G,MAAM,CAACH,GAAD,EAAMgH,cAAN,EAAsB9G,GAAtB,CAAvB;MACD;;MAED,MAAMiH,aAAa,GAAGL,OAAO,CAACpJ,EAAR,CAAW,EAAE,GAAGiB,mBAAL;QAC/B,CAACpC,QAAD,GAAYwK,aADmB;QAE/B,CAACjC,SAAD,GAAakC;MAFkB,CAAX,CAAtB;MAIA,OAAO,EAAE,GAAGG,aAAL;QACLtJ,IAAI,EAAE;UACJ3B,CAAC,EAAEiL,aAAa,CAACjL,CAAd,GAAkBA,CADjB;UAEJG,CAAC,EAAE8K,aAAa,CAAC9K,CAAd,GAAkBA;QAFjB;MADD,CAAP;IAMD;;EA/DI,CAAP;AAkED,CAvED;;AAyEA,SAAS+K,QAAT,CAAkB/G,KAAlB,EAAyB;EACvB,OAAOA,KAAK,IAAIA,KAAK,CAACgH,QAAf,IAA2BhH,KAAK,CAACiH,QAAjC,IAA6CjH,KAAK,CAACkH,KAAnD,IAA4DlH,KAAK,CAACmH,WAAzE;AACD;;AACD,SAASC,SAAT,CAAmBC,IAAnB,EAAyB;EACvB,IAAIA,IAAI,IAAI,IAAZ,EAAkB;IAChB,OAAOC,MAAP;EACD;;EAED,IAAI,CAACP,QAAQ,CAACM,IAAD,CAAb,EAAqB;IACnB,MAAME,aAAa,GAAGF,IAAI,CAACE,aAA3B;IACA,OAAOA,aAAa,GAAGA,aAAa,CAACC,WAAd,IAA6BF,MAAhC,GAAyCA,MAA7D;EACD;;EAED,OAAOD,IAAP;AACD;;AAED,SAASI,gBAAT,CAA0B1I,OAA1B,EAAmC;EACjC,OAAOqI,SAAS,CAACrI,OAAD,CAAT,CAAmB0I,gBAAnB,CAAoC1I,OAApC,CAAP;AACD;;AAED,SAAS2I,WAAT,CAAqBL,IAArB,EAA2B;EACzB,OAAON,QAAQ,CAACM,IAAD,CAAR,GAAiB,EAAjB,GAAsBA,IAAI,GAAG,CAACA,IAAI,CAACM,QAAL,IAAiB,EAAlB,EAAsBC,WAAtB,EAAH,GAAyC,EAA1E;AACD;;AAED,SAASC,WAAT,GAAuB;EACrB,MAAMC,MAAM,GAAGC,SAAS,CAACC,aAAzB;;EAEA,IAAIF,MAAM,IAAI,IAAV,IAAkBA,MAAM,CAACG,MAA7B,EAAqC;IACnC,OAAOH,MAAM,CAACG,MAAP,CAAc3C,GAAd,CAAkB4C,IAAI,IAAIA,IAAI,CAACC,KAAL,GAAa,GAAb,GAAmBD,IAAI,CAACE,OAAlD,EAA2DC,IAA3D,CAAgE,GAAhE,CAAP;EACD;;EAED,OAAON,SAAS,CAACO,SAAjB;AACD;;AAED,SAASC,aAAT,CAAuBvI,KAAvB,EAA8B;EAC5B,OAAOA,KAAK,YAAYoH,SAAS,CAACpH,KAAD,CAAT,CAAiBwI,WAAzC;AACD;;AACD,SAAStJ,SAAT,CAAmBc,KAAnB,EAA0B;EACxB,OAAOA,KAAK,YAAYoH,SAAS,CAACpH,KAAD,CAAT,CAAiByI,OAAzC;AACD;;AACD,SAASC,MAAT,CAAgB1I,KAAhB,EAAuB;EACrB,OAAOA,KAAK,YAAYoH,SAAS,CAACpH,KAAD,CAAT,CAAiB2I,IAAzC;AACD;;AACD,SAASC,YAAT,CAAsBvB,IAAtB,EAA4B;EAC1B;EACA,IAAI,OAAOwB,UAAP,KAAsB,WAA1B,EAAuC;IACrC,OAAO,KAAP;EACD;;EAED,MAAMC,UAAU,GAAG1B,SAAS,CAACC,IAAD,CAAT,CAAgBwB,UAAnC;EACA,OAAOxB,IAAI,YAAYyB,UAAhB,IAA8BzB,IAAI,YAAYwB,UAArD;AACD;;AACD,SAASE,iBAAT,CAA2BhK,OAA3B,EAAoC;EAClC;EACA,MAAM;IACJoE,QADI;IAEJ6F,SAFI;IAGJC,SAHI;IAIJC;EAJI,IAKFzB,gBAAgB,CAAC1I,OAAD,CALpB;EAMA,OAAO,6BAA6BoK,IAA7B,CAAkChG,QAAQ,GAAG8F,SAAX,GAAuBD,SAAzD,KAAuE,CAAC,CAAC,QAAD,EAAW,UAAX,EAAuB5N,QAAvB,CAAgC8N,OAAhC,CAA/E;AACD;;AACD,SAASE,cAAT,CAAwBrK,OAAxB,EAAiC;EAC/B,OAAO,CAAC,OAAD,EAAU,IAAV,EAAgB,IAAhB,EAAsB3D,QAAtB,CAA+BsM,WAAW,CAAC3I,OAAD,CAA1C,CAAP;AACD;;AACD,SAASsK,iBAAT,CAA2BtK,OAA3B,EAAoC;EAClC;EACA,MAAMuK,SAAS,GAAG,WAAWH,IAAX,CAAgBtB,WAAW,EAA3B,CAAlB;EACA,MAAM0B,GAAG,GAAG9B,gBAAgB,CAAC1I,OAAD,CAA5B,CAHkC,CAGK;EACvC;EACA;;EAEA,OAAOwK,GAAG,CAACC,SAAJ,KAAkB,MAAlB,IAA4BD,GAAG,CAACE,WAAJ,KAAoB,MAAhD,IAA0DH,SAAS,IAAIC,GAAG,CAACG,UAAJ,KAAmB,QAA1F,IAAsGJ,SAAS,KAAKC,GAAG,CAAC7G,MAAJ,GAAa6G,GAAG,CAAC7G,MAAJ,KAAe,MAA5B,GAAqC,KAA1C,CAA/G,IAAmK,CAAC,WAAD,EAAc,aAAd,EAA6B+C,IAA7B,CAAkCzF,KAAK,IAAIuJ,GAAG,CAACG,UAAJ,CAAetO,QAAf,CAAwB4E,KAAxB,CAA3C,CAAnK,IAAiP,CAAC,OAAD,EAAU,QAAV,EAAoB,QAApB,EAA8B,SAA9B,EAAyCyF,IAAzC,EAA+C;EACvSzF,KAAK,IAAI;IACP,MAAM2J,OAAO,GAAGJ,GAAG,CAACI,OAApB;IACA,OAAOA,OAAO,IAAI,IAAX,GAAkBA,OAAO,CAACvO,QAAR,CAAiB4E,KAAjB,CAAlB,GAA4C,KAAnD;EACD,CAJuP,CAAxP;AAKD;;AACD,SAAS4J,gBAAT,GAA4B;EAC1B;EACA,OAAO,CAAC,iCAAiCT,IAAjC,CAAsCtB,WAAW,EAAjD,CAAR,CAF0B,CAEoC;EAC9D;EACA;EACA;EACA;AACD;;AACD,SAASgC,qBAAT,CAA+BxC,IAA/B,EAAqC;EACnC,OAAO,CAAC,MAAD,EAAS,MAAT,EAAiB,WAAjB,EAA8BjM,QAA9B,CAAuCsM,WAAW,CAACL,IAAD,CAAlD,CAAP;AACD;;AAED,MAAM1H,GAAG,GAAGD,IAAI,CAACC,GAAjB;AACA,MAAME,GAAG,GAAGH,IAAI,CAACG,GAAjB;AACA,MAAMiK,KAAK,GAAGpK,IAAI,CAACoK,KAAnB;;AAEA,SAASC,qBAAT,CAA+BhL,OAA/B,EAAwCiL,YAAxC,EAAsDC,eAAtD,EAAuE;EACrE,IAAIC,qBAAJ,EAA2BC,mBAA3B,EAAgDC,sBAAhD,EAAwEC,oBAAxE;;EAEA,IAAIL,YAAY,KAAK,KAAK,CAA1B,EAA6B;IAC3BA,YAAY,GAAG,KAAf;EACD;;EAED,IAAIC,eAAe,KAAK,KAAK,CAA7B,EAAgC;IAC9BA,eAAe,GAAG,KAAlB;EACD;;EAED,MAAMK,UAAU,GAAGvL,OAAO,CAACgL,qBAAR,EAAnB;EACA,IAAIQ,MAAM,GAAG,CAAb;EACA,IAAIC,MAAM,GAAG,CAAb;;EAEA,IAAIR,YAAY,IAAIzB,aAAa,CAACxJ,OAAD,CAAjC,EAA4C;IAC1CwL,MAAM,GAAGxL,OAAO,CAAC0L,WAAR,GAAsB,CAAtB,GAA0BX,KAAK,CAACQ,UAAU,CAACxO,KAAZ,CAAL,GAA0BiD,OAAO,CAAC0L,WAAlC,IAAiD,CAA3E,GAA+E,CAAxF;IACAD,MAAM,GAAGzL,OAAO,CAAC2L,YAAR,GAAuB,CAAvB,GAA2BZ,KAAK,CAACQ,UAAU,CAACrO,MAAZ,CAAL,GAA2B8C,OAAO,CAAC2L,YAAnC,IAAmD,CAA9E,GAAkF,CAA3F;EACD;;EAED,MAAMC,GAAG,GAAGzL,SAAS,CAACH,OAAD,CAAT,GAAqBqI,SAAS,CAACrI,OAAD,CAA9B,GAA0CuI,MAAtD;EACA,MAAMsD,gBAAgB,GAAG,CAAChB,gBAAgB,EAAjB,IAAuBK,eAAhD;EACA,MAAMpO,CAAC,GAAG,CAACyO,UAAU,CAACrM,IAAX,IAAmB2M,gBAAgB,GAAG,CAACV,qBAAqB,GAAG,CAACC,mBAAmB,GAAGQ,GAAG,CAACE,cAA3B,KAA8C,IAA9C,GAAqD,KAAK,CAA1D,GAA8DV,mBAAmB,CAACW,UAA3G,KAA0H,IAA1H,GAAiIZ,qBAAjI,GAAyJ,CAA5J,GAAgK,CAAnM,CAAD,IAA0MK,MAApN;EACA,MAAMvO,CAAC,GAAG,CAACsO,UAAU,CAACxM,GAAX,IAAkB8M,gBAAgB,GAAG,CAACR,sBAAsB,GAAG,CAACC,oBAAoB,GAAGM,GAAG,CAACE,cAA5B,KAA+C,IAA/C,GAAsD,KAAK,CAA3D,GAA+DR,oBAAoB,CAACU,SAA9G,KAA4H,IAA5H,GAAmIX,sBAAnI,GAA4J,CAA/J,GAAmK,CAArM,CAAD,IAA4MI,MAAtN;EACA,MAAM1O,KAAK,GAAGwO,UAAU,CAACxO,KAAX,GAAmByO,MAAjC;EACA,MAAMtO,MAAM,GAAGqO,UAAU,CAACrO,MAAX,GAAoBuO,MAAnC;EACA,OAAO;IACL1O,KADK;IAELG,MAFK;IAGL6B,GAAG,EAAE9B,CAHA;IAIL+B,KAAK,EAAElC,CAAC,GAAGC,KAJN;IAKLkC,MAAM,EAAEhC,CAAC,GAAGC,MALP;IAMLgC,IAAI,EAAEpC,CAND;IAOLA,CAPK;IAQLG;EARK,CAAP;AAUD;;AAED,SAASoD,kBAAT,CAA4BiI,IAA5B,EAAkC;EAChC,OAAO,CAAC,CAACqB,MAAM,CAACrB,IAAD,CAAN,GAAeA,IAAI,CAACE,aAApB,GAAoCF,IAAI,CAACL,QAA1C,KAAuDM,MAAM,CAACN,QAA/D,EAAyEgE,eAAhF;AACD;;AAED,SAASC,aAAT,CAAuBlM,OAAvB,EAAgC;EAC9B,IAAIG,SAAS,CAACH,OAAD,CAAb,EAAwB;IACtB,OAAO;MACLmM,UAAU,EAAEnM,OAAO,CAACmM,UADf;MAELC,SAAS,EAAEpM,OAAO,CAACoM;IAFd,CAAP;EAID;;EAED,OAAO;IACLD,UAAU,EAAEnM,OAAO,CAACqM,WADf;IAELD,SAAS,EAAEpM,OAAO,CAACsM;EAFd,CAAP;AAID;;AAED,SAASC,mBAAT,CAA6BvM,OAA7B,EAAsC;EACpC;EACA;EACA,OAAOgL,qBAAqB,CAAC3K,kBAAkB,CAACL,OAAD,CAAnB,CAArB,CAAmDd,IAAnD,GAA0DgN,aAAa,CAAClM,OAAD,CAAb,CAAuBmM,UAAxF;AACD;;AAED,SAASK,QAAT,CAAkBxM,OAAlB,EAA2B;EACzB,MAAMX,IAAI,GAAG2L,qBAAqB,CAAChL,OAAD,CAAlC;EACA,OAAO+K,KAAK,CAAC1L,IAAI,CAACtC,KAAN,CAAL,KAAsBiD,OAAO,CAAC0L,WAA9B,IAA6CX,KAAK,CAAC1L,IAAI,CAACnC,MAAN,CAAL,KAAuB8C,OAAO,CAAC2L,YAAnF;AACD;;AAED,SAASc,6BAAT,CAAuCzM,OAAvC,EAAgDQ,YAAhD,EAA8D7C,QAA9D,EAAwE;EACtE,MAAM+O,uBAAuB,GAAGlD,aAAa,CAAChJ,YAAD,CAA7C;EACA,MAAMyL,eAAe,GAAG5L,kBAAkB,CAACG,YAAD,CAA1C;EACA,MAAMnB,IAAI,GAAG2L,qBAAqB,CAAChL,OAAD,EAAU;EAC5C0M,uBAAuB,IAAIF,QAAQ,CAAChM,YAAD,CADD,EACiB7C,QAAQ,KAAK,OAD9B,CAAlC;EAEA,IAAIgP,MAAM,GAAG;IACXR,UAAU,EAAE,CADD;IAEXC,SAAS,EAAE;EAFA,CAAb;EAIA,MAAMvF,OAAO,GAAG;IACd/J,CAAC,EAAE,CADW;IAEdG,CAAC,EAAE;EAFW,CAAhB;;EAKA,IAAIyP,uBAAuB,IAAI,CAACA,uBAAD,IAA4B/O,QAAQ,KAAK,OAAxE,EAAiF;IAC/E,IAAIgL,WAAW,CAACnI,YAAD,CAAX,KAA8B,MAA9B,IAAwCwJ,iBAAiB,CAACiC,eAAD,CAA7D,EAAgF;MAC9EU,MAAM,GAAGT,aAAa,CAAC1L,YAAD,CAAtB;IACD;;IAED,IAAIgJ,aAAa,CAAChJ,YAAD,CAAjB,EAAiC;MAC/B,MAAMoM,UAAU,GAAG5B,qBAAqB,CAACxK,YAAD,EAAe,IAAf,CAAxC;MACAqG,OAAO,CAAC/J,CAAR,GAAY8P,UAAU,CAAC9P,CAAX,GAAe0D,YAAY,CAACqM,UAAxC;MACAhG,OAAO,CAAC5J,CAAR,GAAY2P,UAAU,CAAC3P,CAAX,GAAeuD,YAAY,CAACsM,SAAxC;IACD,CAJD,MAIO,IAAIb,eAAJ,EAAqB;MAC1BpF,OAAO,CAAC/J,CAAR,GAAYyP,mBAAmB,CAACN,eAAD,CAA/B;IACD;EACF;;EAED,OAAO;IACLnP,CAAC,EAAEuC,IAAI,CAACH,IAAL,GAAYyN,MAAM,CAACR,UAAnB,GAAgCtF,OAAO,CAAC/J,CADtC;IAELG,CAAC,EAAEoC,IAAI,CAACN,GAAL,GAAW4N,MAAM,CAACP,SAAlB,GAA8BvF,OAAO,CAAC5J,CAFpC;IAGLF,KAAK,EAAEsC,IAAI,CAACtC,KAHP;IAILG,MAAM,EAAEmC,IAAI,CAACnC;EAJR,CAAP;AAMD;;AAED,SAAS6P,aAAT,CAAuBzE,IAAvB,EAA6B;EAC3B,IAAIK,WAAW,CAACL,IAAD,CAAX,KAAsB,MAA1B,EAAkC;IAChC,OAAOA,IAAP;EACD;;EAED,OAAQ;IACN;IACAA,IAAI,CAAC0E,YAAL,IAAqB;IACrB1E,IAAI,CAAC2E,UADL,MACqB;IACrBpD,YAAY,CAACvB,IAAD,CAAZ,GAAqBA,IAAI,CAAC4E,IAA1B,GAAiC,IAFjC,KAE0C;IAC1C7M,kBAAkB,CAACiI,IAAD,CALpB,CAK2B;;EAL3B;AAQD;;AAED,SAAS6E,mBAAT,CAA6BnN,OAA7B,EAAsC;EACpC,IAAI,CAACwJ,aAAa,CAACxJ,OAAD,CAAd,IAA2B0I,gBAAgB,CAAC1I,OAAD,CAAhB,CAA0BoN,QAA1B,KAAuC,OAAtE,EAA+E;IAC7E,OAAO,IAAP;EACD;;EAED,OAAOpN,OAAO,CAACQ,YAAf;AACD;;AAED,SAAS6M,kBAAT,CAA4BrN,OAA5B,EAAqC;EACnC,IAAIsN,WAAW,GAAGP,aAAa,CAAC/M,OAAD,CAA/B;;EAEA,IAAI6J,YAAY,CAACyD,WAAD,CAAhB,EAA+B;IAC7BA,WAAW,GAAGA,WAAW,CAACJ,IAA1B;EACD;;EAED,OAAO1D,aAAa,CAAC8D,WAAD,CAAb,IAA8B,CAACxC,qBAAqB,CAACwC,WAAD,CAA3D,EAA0E;IACxE,IAAIhD,iBAAiB,CAACgD,WAAD,CAArB,EAAoC;MAClC,OAAOA,WAAP;IACD,CAFD,MAEO;MACL,MAAMC,MAAM,GAAGD,WAAW,CAACL,UAA3B;MACAK,WAAW,GAAGzD,YAAY,CAAC0D,MAAD,CAAZ,GAAuBA,MAAM,CAACL,IAA9B,GAAqCK,MAAnD;IACD;EACF;;EAED,OAAO,IAAP;AACD,C,CAAC;AACF;;;AAGA,SAAS9M,eAAT,CAAyBT,OAAzB,EAAkC;EAChC,MAAMuI,MAAM,GAAGF,SAAS,CAACrI,OAAD,CAAxB;EACA,IAAIQ,YAAY,GAAG2M,mBAAmB,CAACnN,OAAD,CAAtC;;EAEA,OAAOQ,YAAY,IAAI6J,cAAc,CAAC7J,YAAD,CAA9B,IAAgDkI,gBAAgB,CAAClI,YAAD,CAAhB,CAA+B4M,QAA/B,KAA4C,QAAnG,EAA6G;IAC3G5M,YAAY,GAAG2M,mBAAmB,CAAC3M,YAAD,CAAlC;EACD;;EAED,IAAIA,YAAY,KAAKmI,WAAW,CAACnI,YAAD,CAAX,KAA8B,MAA9B,IAAwCmI,WAAW,CAACnI,YAAD,CAAX,KAA8B,MAA9B,IAAwCkI,gBAAgB,CAAClI,YAAD,CAAhB,CAA+B4M,QAA/B,KAA4C,QAApF,IAAgG,CAAC9C,iBAAiB,CAAC9J,YAAD,CAA/J,CAAhB,EAAgM;IAC9L,OAAO+H,MAAP;EACD;;EAED,OAAO/H,YAAY,IAAI6M,kBAAkB,CAACrN,OAAD,CAAlC,IAA+CuI,MAAtD;AACD;;AAED,SAASjH,aAAT,CAAuBtB,OAAvB,EAAgC;EAC9B,IAAIwJ,aAAa,CAACxJ,OAAD,CAAjB,EAA4B;IAC1B,OAAO;MACLjD,KAAK,EAAEiD,OAAO,CAAC0L,WADV;MAELxO,MAAM,EAAE8C,OAAO,CAAC2L;IAFX,CAAP;EAID;;EAED,MAAMtM,IAAI,GAAG2L,qBAAqB,CAAChL,OAAD,CAAlC;EACA,OAAO;IACLjD,KAAK,EAAEsC,IAAI,CAACtC,KADP;IAELG,MAAM,EAAEmC,IAAI,CAACnC;EAFR,CAAP;AAID;;AAED,SAASqD,qDAAT,CAA+D9D,IAA/D,EAAqE;EACnE,IAAI;IACF4C,IADE;IAEFmB,YAFE;IAGF7C;EAHE,IAIAlB,IAJJ;EAKA,MAAMiQ,uBAAuB,GAAGlD,aAAa,CAAChJ,YAAD,CAA7C;EACA,MAAMyL,eAAe,GAAG5L,kBAAkB,CAACG,YAAD,CAA1C;;EAEA,IAAIA,YAAY,KAAKyL,eAArB,EAAsC;IACpC,OAAO5M,IAAP;EACD;;EAED,IAAIsN,MAAM,GAAG;IACXR,UAAU,EAAE,CADD;IAEXC,SAAS,EAAE;EAFA,CAAb;EAIA,MAAMvF,OAAO,GAAG;IACd/J,CAAC,EAAE,CADW;IAEdG,CAAC,EAAE;EAFW,CAAhB;;EAKA,IAAIyP,uBAAuB,IAAI,CAACA,uBAAD,IAA4B/O,QAAQ,KAAK,OAAxE,EAAiF;IAC/E,IAAIgL,WAAW,CAACnI,YAAD,CAAX,KAA8B,MAA9B,IAAwCwJ,iBAAiB,CAACiC,eAAD,CAA7D,EAAgF;MAC9EU,MAAM,GAAGT,aAAa,CAAC1L,YAAD,CAAtB;IACD;;IAED,IAAIgJ,aAAa,CAAChJ,YAAD,CAAjB,EAAiC;MAC/B,MAAMoM,UAAU,GAAG5B,qBAAqB,CAACxK,YAAD,EAAe,IAAf,CAAxC;MACAqG,OAAO,CAAC/J,CAAR,GAAY8P,UAAU,CAAC9P,CAAX,GAAe0D,YAAY,CAACqM,UAAxC;MACAhG,OAAO,CAAC5J,CAAR,GAAY2P,UAAU,CAAC3P,CAAX,GAAeuD,YAAY,CAACsM,SAAxC;IACD,CAT8E,CAS7E;IACF;IACA;IACA;;EAED;;EAED,OAAO,EAAE,GAAGzN,IAAL;IACLvC,CAAC,EAAEuC,IAAI,CAACvC,CAAL,GAAS6P,MAAM,CAACR,UAAhB,GAA6BtF,OAAO,CAAC/J,CADnC;IAELG,CAAC,EAAEoC,IAAI,CAACpC,CAAL,GAAS0P,MAAM,CAACP,SAAhB,GAA4BvF,OAAO,CAAC5J;EAFlC,CAAP;AAID;;AAED,SAASuQ,eAAT,CAAyBxN,OAAzB,EAAkCrC,QAAlC,EAA4C;EAC1C,MAAMiO,GAAG,GAAGvD,SAAS,CAACrI,OAAD,CAArB;EACA,MAAMyN,IAAI,GAAGpN,kBAAkB,CAACL,OAAD,CAA/B;EACA,MAAM8L,cAAc,GAAGF,GAAG,CAACE,cAA3B;EACA,IAAI/O,KAAK,GAAG0Q,IAAI,CAAC3L,WAAjB;EACA,IAAI5E,MAAM,GAAGuQ,IAAI,CAAC5L,YAAlB;EACA,IAAI/E,CAAC,GAAG,CAAR;EACA,IAAIG,CAAC,GAAG,CAAR;;EAEA,IAAI6O,cAAJ,EAAoB;IAClB/O,KAAK,GAAG+O,cAAc,CAAC/O,KAAvB;IACAG,MAAM,GAAG4O,cAAc,CAAC5O,MAAxB;IACA,MAAMwQ,cAAc,GAAG7C,gBAAgB,EAAvC;;IAEA,IAAI6C,cAAc,IAAI,CAACA,cAAD,IAAmB/P,QAAQ,KAAK,OAAtD,EAA+D;MAC7Db,CAAC,GAAGgP,cAAc,CAACC,UAAnB;MACA9O,CAAC,GAAG6O,cAAc,CAACE,SAAnB;IACD;EACF;;EAED,OAAO;IACLjP,KADK;IAELG,MAFK;IAGLJ,CAHK;IAILG;EAJK,CAAP;AAMD,C,CAED;;;AAEA,SAAS0Q,eAAT,CAAyB3N,OAAzB,EAAkC;EAChC,IAAI4N,qBAAJ;;EAEA,MAAMH,IAAI,GAAGpN,kBAAkB,CAACL,OAAD,CAA/B;EACA,MAAM2M,MAAM,GAAGT,aAAa,CAAClM,OAAD,CAA5B;EACA,MAAM6N,IAAI,GAAG,CAACD,qBAAqB,GAAG5N,OAAO,CAACwI,aAAjC,KAAmD,IAAnD,GAA0D,KAAK,CAA/D,GAAmEoF,qBAAqB,CAACC,IAAtG;EACA,MAAM9Q,KAAK,GAAG+D,GAAG,CAAC2M,IAAI,CAACK,WAAN,EAAmBL,IAAI,CAAC3L,WAAxB,EAAqC+L,IAAI,GAAGA,IAAI,CAACC,WAAR,GAAsB,CAA/D,EAAkED,IAAI,GAAGA,IAAI,CAAC/L,WAAR,GAAsB,CAA5F,CAAjB;EACA,MAAM5E,MAAM,GAAG4D,GAAG,CAAC2M,IAAI,CAACM,YAAN,EAAoBN,IAAI,CAAC5L,YAAzB,EAAuCgM,IAAI,GAAGA,IAAI,CAACE,YAAR,GAAuB,CAAlE,EAAqEF,IAAI,GAAGA,IAAI,CAAChM,YAAR,GAAuB,CAAhG,CAAlB;EACA,IAAI/E,CAAC,GAAG,CAAC6P,MAAM,CAACR,UAAR,GAAqBI,mBAAmB,CAACvM,OAAD,CAAhD;EACA,MAAM/C,CAAC,GAAG,CAAC0P,MAAM,CAACP,SAAlB;;EAEA,IAAI1D,gBAAgB,CAACmF,IAAI,IAAIJ,IAAT,CAAhB,CAA+BO,SAA/B,KAA6C,KAAjD,EAAwD;IACtDlR,CAAC,IAAIgE,GAAG,CAAC2M,IAAI,CAAC3L,WAAN,EAAmB+L,IAAI,GAAGA,IAAI,CAAC/L,WAAR,GAAsB,CAA7C,CAAH,GAAqD/E,KAA1D;EACD;;EAED,OAAO;IACLA,KADK;IAELG,MAFK;IAGLJ,CAHK;IAILG;EAJK,CAAP;AAMD;;AAED,SAASgR,0BAAT,CAAoC3F,IAApC,EAA0C;EACxC,MAAM2E,UAAU,GAAGF,aAAa,CAACzE,IAAD,CAAhC;;EAEA,IAAIwC,qBAAqB,CAACmC,UAAD,CAAzB,EAAuC;IACrC;IACA,OAAO3E,IAAI,CAACE,aAAL,CAAmBqF,IAA1B;EACD;;EAED,IAAIrE,aAAa,CAACyD,UAAD,CAAb,IAA6BjD,iBAAiB,CAACiD,UAAD,CAAlD,EAAgE;IAC9D,OAAOA,UAAP;EACD;;EAED,OAAOgB,0BAA0B,CAAChB,UAAD,CAAjC;AACD;;AAED,SAASiB,oBAAT,CAA8B5F,IAA9B,EAAoC6F,IAApC,EAA0C;EACxC,IAAIC,mBAAJ;;EAEA,IAAID,IAAI,KAAK,KAAK,CAAlB,EAAqB;IACnBA,IAAI,GAAG,EAAP;EACD;;EAED,MAAME,kBAAkB,GAAGJ,0BAA0B,CAAC3F,IAAD,CAArD;EACA,MAAMgG,MAAM,GAAGD,kBAAkB,MAAM,CAACD,mBAAmB,GAAG9F,IAAI,CAACE,aAA5B,KAA8C,IAA9C,GAAqD,KAAK,CAA1D,GAA8D4F,mBAAmB,CAACP,IAAxF,CAAjC;EACA,MAAMjC,GAAG,GAAGvD,SAAS,CAACgG,kBAAD,CAArB;EACA,MAAME,MAAM,GAAGD,MAAM,GAAG,CAAC1C,GAAD,EAAMtI,MAAN,CAAasI,GAAG,CAACE,cAAJ,IAAsB,EAAnC,EAAuC9B,iBAAiB,CAACqE,kBAAD,CAAjB,GAAwCA,kBAAxC,GAA6D,EAApG,CAAH,GAA6GA,kBAAlI;EACA,MAAMG,WAAW,GAAGL,IAAI,CAAC7K,MAAL,CAAYiL,MAAZ,CAApB;EACA,OAAOD,MAAM,GAAGE,WAAH,GAAiB;EAC9BA,WAAW,CAAClL,MAAZ,CAAmB4K,oBAAoB,CAACK,MAAD,CAAvC,CADA;AAED;;AAED,SAASE,QAAT,CAAkBlB,MAAlB,EAA0BmB,KAA1B,EAAiC;EAC/B,MAAMC,QAAQ,GAAGD,KAAK,CAACE,WAAN,IAAqB,IAArB,GAA4B,KAAK,CAAjC,GAAqCF,KAAK,CAACE,WAAN,EAAtD,CAD+B,CAC4C;;EAE3E,IAAIrB,MAAM,CAACkB,QAAP,CAAgBC,KAAhB,CAAJ,EAA4B;IAC1B,OAAO,IAAP;EACD,CAFD,CAEE;EAFF,KAGK,IAAIC,QAAQ,IAAI9E,YAAY,CAAC8E,QAAD,CAA5B,EAAwC;IAC3C,IAAIE,IAAI,GAAGH,KAAX;;IAEA,GAAG;MACD;MACA,IAAIG,IAAI,IAAItB,MAAM,KAAKsB,IAAvB,EAA6B;QAC3B,OAAO,IAAP;MACD,CAJA,CAIC;;;MAGFA,IAAI,GAAGA,IAAI,CAAC5B,UAAL,IAAmB4B,IAAI,CAAC3B,IAA/B;IACD,CARD,QAQS2B,IART;EASD;;EAED,OAAO,KAAP;AACD;;AAED,SAASC,yCAAT,CAAmD9O,OAAnD,EAA4D+O,iBAA5D,EAA+E;EAC7E,IAAIzB,WAAW,GAAGtN,OAAlB;;EAEA,OAAOsN,WAAW,IAAI,CAACxC,qBAAqB,CAACwC,WAAD,CAArC,IAAsD;EAC7D,CAACyB,iBAAiB,CAAC1S,QAAlB,CAA2BiR,WAA3B,CADD,EAC0C;IACxC,IAAInN,SAAS,CAACmN,WAAD,CAAT,IAA0B,CAAC,UAAD,EAAa,OAAb,EAAsBjR,QAAtB,CAA+BqM,gBAAgB,CAAC4E,WAAD,CAAhB,CAA8BF,QAA7D,CAA9B,EAAsG;MACpG;IACD;;IAED,MAAMH,UAAU,GAAGF,aAAa,CAACO,WAAD,CAAhC;IACAA,WAAW,GAAGzD,YAAY,CAACoD,UAAD,CAAZ,GAA2BA,UAAU,CAACC,IAAtC,GAA6CD,UAA3D;EACD;;EAED,OAAOK,WAAP;AACD;;AAED,SAAS0B,0BAAT,CAAoChP,OAApC,EAA6CrC,QAA7C,EAAuD;EACrD,MAAM4N,UAAU,GAAGP,qBAAqB,CAAChL,OAAD,EAAU,KAAV,EAAiBrC,QAAQ,KAAK,OAA9B,CAAxC;EACA,MAAMoB,GAAG,GAAGwM,UAAU,CAACxM,GAAX,GAAiBiB,OAAO,CAAC8M,SAArC;EACA,MAAM5N,IAAI,GAAGqM,UAAU,CAACrM,IAAX,GAAkBc,OAAO,CAAC6M,UAAvC;EACA,OAAO;IACL9N,GADK;IAELG,IAFK;IAGLpC,CAAC,EAAEoC,IAHE;IAILjC,CAAC,EAAE8B,GAJE;IAKLC,KAAK,EAAEE,IAAI,GAAGc,OAAO,CAAC8B,WALjB;IAML7C,MAAM,EAAEF,GAAG,GAAGiB,OAAO,CAAC6B,YANjB;IAOL9E,KAAK,EAAEiD,OAAO,CAAC8B,WAPV;IAQL5E,MAAM,EAAE8C,OAAO,CAAC6B;EARX,CAAP;AAUD;;AAED,SAASoN,iCAAT,CAA2CjP,OAA3C,EAAoDkP,cAApD,EAAoEvR,QAApE,EAA8E;EAC5E,IAAIuR,cAAc,KAAK,UAAvB,EAAmC;IACjC,OAAO9P,gBAAgB,CAACoO,eAAe,CAACxN,OAAD,EAAUrC,QAAV,CAAhB,CAAvB;EACD;;EAED,IAAIwC,SAAS,CAAC+O,cAAD,CAAb,EAA+B;IAC7B,OAAOF,0BAA0B,CAACE,cAAD,EAAiBvR,QAAjB,CAAjC;EACD;;EAED,OAAOyB,gBAAgB,CAACuO,eAAe,CAACtN,kBAAkB,CAACL,OAAD,CAAnB,CAAhB,CAAvB;AACD,C,CAAC;AACF;AACA;;;AAGA,SAASmP,oBAAT,CAA8BnP,OAA9B,EAAuC;EACrC,MAAM+O,iBAAiB,GAAGb,oBAAoB,CAAClO,OAAD,CAA9C;EACA,MAAMoP,sBAAsB,GAAGN,yCAAyC,CAAC9O,OAAD,EAAU+O,iBAAV,CAAxE;EACA,IAAIM,cAAc,GAAG,IAArB;;EAEA,IAAID,sBAAsB,IAAI5F,aAAa,CAAC4F,sBAAD,CAA3C,EAAqE;IACnE,MAAM5O,YAAY,GAAGC,eAAe,CAAC2O,sBAAD,CAApC;;IAEA,IAAIpF,iBAAiB,CAACoF,sBAAD,CAArB,EAA+C;MAC7CC,cAAc,GAAGD,sBAAjB;IACD,CAFD,MAEO,IAAI5F,aAAa,CAAChJ,YAAD,CAAjB,EAAiC;MACtC6O,cAAc,GAAG7O,YAAjB;IACD;EACF;;EAED,IAAI,CAACL,SAAS,CAACkP,cAAD,CAAd,EAAgC;IAC9B,OAAO,EAAP;EACD,CAjBoC,CAiBnC;;;EAGF,OAAON,iBAAiB,CAACpL,MAAlB,CAAyBoL,iBAAiB,IAAIM,cAAc,IAAIlP,SAAS,CAAC4O,iBAAD,CAA3B,IAAkDN,QAAQ,CAACM,iBAAD,EAAoBM,cAApB,CAA1D,IAAiG1G,WAAW,CAACoG,iBAAD,CAAX,KAAmC,MAAlL,CAAP;AACD,C,CAAC;AACF;;;AAGA,SAAS7O,eAAT,CAAyBzD,IAAzB,EAA+B;EAC7B,IAAI;IACFuD,OADE;IAEFN,QAFE;IAGFC,YAHE;IAIFhC;EAJE,IAKAlB,IALJ;EAMA,MAAM6S,qBAAqB,GAAG5P,QAAQ,KAAK,mBAAb,GAAmCyP,oBAAoB,CAACnP,OAAD,CAAvD,GAAmE,GAAGsD,MAAH,CAAU5D,QAAV,CAAjG;EACA,MAAMqP,iBAAiB,GAAG,CAAC,GAAGO,qBAAJ,EAA2B3P,YAA3B,CAA1B;EACA,MAAM4P,qBAAqB,GAAGR,iBAAiB,CAAC,CAAD,CAA/C;EACA,MAAMS,YAAY,GAAGT,iBAAiB,CAAC3L,MAAlB,CAAyB,CAACqM,OAAD,EAAUC,gBAAV,KAA+B;IAC3E,MAAMrQ,IAAI,GAAG4P,iCAAiC,CAACjP,OAAD,EAAU0P,gBAAV,EAA4B/R,QAA5B,CAA9C;IACA8R,OAAO,CAAC1Q,GAAR,GAAc+B,GAAG,CAACzB,IAAI,CAACN,GAAN,EAAW0Q,OAAO,CAAC1Q,GAAnB,CAAjB;IACA0Q,OAAO,CAACzQ,KAAR,GAAgB4B,GAAG,CAACvB,IAAI,CAACL,KAAN,EAAayQ,OAAO,CAACzQ,KAArB,CAAnB;IACAyQ,OAAO,CAACxQ,MAAR,GAAiB2B,GAAG,CAACvB,IAAI,CAACJ,MAAN,EAAcwQ,OAAO,CAACxQ,MAAtB,CAApB;IACAwQ,OAAO,CAACvQ,IAAR,GAAe4B,GAAG,CAACzB,IAAI,CAACH,IAAN,EAAYuQ,OAAO,CAACvQ,IAApB,CAAlB;IACA,OAAOuQ,OAAP;EACD,CAPoB,EAOlBR,iCAAiC,CAACjP,OAAD,EAAUuP,qBAAV,EAAiC5R,QAAjC,CAPf,CAArB;EAQA,OAAO;IACLZ,KAAK,EAAEyS,YAAY,CAACxQ,KAAb,GAAqBwQ,YAAY,CAACtQ,IADpC;IAELhC,MAAM,EAAEsS,YAAY,CAACvQ,MAAb,GAAsBuQ,YAAY,CAACzQ,GAFtC;IAGLjC,CAAC,EAAE0S,YAAY,CAACtQ,IAHX;IAILjC,CAAC,EAAEuS,YAAY,CAACzQ;EAJX,CAAP;AAMD;;AAED,MAAMlB,QAAQ,GAAG;EACfqC,eADe;EAEfK,qDAFe;EAGfJ,SAHe;EAIfmB,aAJe;EAKfb,eALe;EAMfJ,kBANe;EAOfrC,eAAe,EAAEvB,IAAI,IAAI;IACvB,IAAI;MACFE,SADE;MAEFC,QAFE;MAGFe;IAHE,IAIAlB,IAJJ;IAKA,OAAO;MACLE,SAAS,EAAE8P,6BAA6B,CAAC9P,SAAD,EAAY8D,eAAe,CAAC7D,QAAD,CAA3B,EAAuCe,QAAvC,CADnC;MAELf,QAAQ,EAAE,EAAE,GAAG0E,aAAa,CAAC1E,QAAD,CAAlB;QACRE,CAAC,EAAE,CADK;QAERG,CAAC,EAAE;MAFK;IAFL,CAAP;EAOD,CApBc;EAqBf0S,cAAc,EAAE3P,OAAO,IAAI4P,KAAK,CAACC,IAAN,CAAW7P,OAAO,CAAC2P,cAAR,EAAX,CArBZ;EAsBf7R,KAAK,EAAEkC,OAAO,IAAI0I,gBAAgB,CAAC1I,OAAD,CAAhB,CAA0BgO,SAA1B,KAAwC;AAtB3C,CAAjB;AAyBA;AACA;AACA;AACA;;AACA,SAAS8B,UAAT,CAAoBnT,SAApB,EAA+BC,QAA/B,EAAyCmT,MAAzC,EAAiDvQ,OAAjD,EAA0D;EACxD,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IACtBA,OAAO,GAAG,EAAV;EACD;;EAED,MAAM;IACJwQ,cAAc,EAAEC,eAAe,GAAG,IAD9B;IAEJC,cAAc,GAAG,IAFb;IAGJC,aAAa,GAAG,IAHZ;IAIJC,cAAc,GAAG;EAJb,IAKF5Q,OALJ;EAMA,MAAMwQ,cAAc,GAAGC,eAAe,IAAI,CAACG,cAA3C;EACA,MAAMC,SAAS,GAAGL,cAAc,IAAIE,cAAlB,GAAmC,CAAC,IAAI/P,SAAS,CAACxD,SAAD,CAAT,GAAuBuR,oBAAoB,CAACvR,SAAD,CAA3C,GAAyD,EAA7D,CAAD,EAAmE,GAAGuR,oBAAoB,CAACtR,QAAD,CAA1F,CAAnC,GAA2I,EAA7J;EACAyT,SAAS,CAACC,OAAV,CAAkBC,QAAQ,IAAI;IAC5BP,cAAc,IAAIO,QAAQ,CAACC,gBAAT,CAA0B,QAA1B,EAAoCT,MAApC,EAA4C;MAC5DU,OAAO,EAAE;IADmD,CAA5C,CAAlB;IAGAP,cAAc,IAAIK,QAAQ,CAACC,gBAAT,CAA0B,QAA1B,EAAoCT,MAApC,CAAlB;EACD,CALD;EAMA,IAAIW,QAAQ,GAAG,IAAf;;EAEA,IAAIP,aAAJ,EAAmB;IACjB,IAAIQ,aAAa,GAAG,IAApB;IACAD,QAAQ,GAAG,IAAIE,cAAJ,CAAmB,MAAM;MAClC,IAAI,CAACD,aAAL,EAAoB;QAClBZ,MAAM;MACP;;MAEDY,aAAa,GAAG,KAAhB;IACD,CANU,CAAX;IAOAxQ,SAAS,CAACxD,SAAD,CAAT,IAAwB,CAACyT,cAAzB,IAA2CM,QAAQ,CAACG,OAAT,CAAiBlU,SAAjB,CAA3C;IACA+T,QAAQ,CAACG,OAAT,CAAiBjU,QAAjB;EACD;;EAED,IAAIkU,OAAJ;EACA,IAAIC,WAAW,GAAGX,cAAc,GAAGpF,qBAAqB,CAACrO,SAAD,CAAxB,GAAsC,IAAtE;;EAEA,IAAIyT,cAAJ,EAAoB;IAClBY,SAAS;EACV;;EAED,SAASA,SAAT,GAAqB;IACnB,MAAMC,WAAW,GAAGjG,qBAAqB,CAACrO,SAAD,CAAzC;;IAEA,IAAIoU,WAAW,KAAKE,WAAW,CAACnU,CAAZ,KAAkBiU,WAAW,CAACjU,CAA9B,IAAmCmU,WAAW,CAAChU,CAAZ,KAAkB8T,WAAW,CAAC9T,CAAjE,IAAsEgU,WAAW,CAAClU,KAAZ,KAAsBgU,WAAW,CAAChU,KAAxG,IAAiHkU,WAAW,CAAC/T,MAAZ,KAAuB6T,WAAW,CAAC7T,MAAzJ,CAAf,EAAiL;MAC/K6S,MAAM;IACP;;IAEDgB,WAAW,GAAGE,WAAd;IACAH,OAAO,GAAGI,qBAAqB,CAACF,SAAD,CAA/B;EACD;;EAEDjB,MAAM;EACN,OAAO,MAAM;IACX,IAAIoB,SAAJ;;IAEAd,SAAS,CAACC,OAAV,CAAkBC,QAAQ,IAAI;MAC5BP,cAAc,IAAIO,QAAQ,CAACa,mBAAT,CAA6B,QAA7B,EAAuCrB,MAAvC,CAAlB;MACAG,cAAc,IAAIK,QAAQ,CAACa,mBAAT,CAA6B,QAA7B,EAAuCrB,MAAvC,CAAlB;IACD,CAHD;IAIA,CAACoB,SAAS,GAAGT,QAAb,KAA0B,IAA1B,GAAiC,KAAK,CAAtC,GAA0CS,SAAS,CAACE,UAAV,EAA1C;IACAX,QAAQ,GAAG,IAAX;;IAEA,IAAIN,cAAJ,EAAoB;MAClBkB,oBAAoB,CAACR,OAAD,CAApB;IACD;EACF,CAbD;AAcD;AAED;AACA;AACA;AACA;AACA;;;AAEA,MAAMS,eAAe,GAAG,CAAC5U,SAAD,EAAYC,QAAZ,EAAsB4C,OAAtB,KAAkC/B,iBAAiB,CAACd,SAAD,EAAYC,QAAZ,EAAsB;EAC/FiB,QAD+F;EAE/F,GAAG2B;AAF4F,CAAtB,CAA3E;AAKA;AACA;AACA;AACA;AACA;;;AACA,MAAMgS,eAAe,GAAGC,UAAU,CAAC,yBAAD,CAAlC;AACA,MAAM/T,MAAM,GAAG;EACb;AACF;AACA;AACA;AACA;AACA;EACEgU,mCAAmC,EAAE,IAPxB;EAQb,GAAGF;AARU,CAAf;AAWA,MAAMG,sBAAsB,GAAGC,qCAAqC,EAApE;;AACA,eAAeA,qCAAf,GAAuD;EACrD,SAAS9I,WAAT,GAAuB;IACrB,MAAMC,MAAM,GAAGC,SAAS,CAACC,aAAzB;;IACA,IAAIF,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACG,MAA3D,EAAmE;MACjE,OAAOH,MAAM,CAACG,MAAP,CAAc3C,GAAd,CAAmB4C,IAAD,IAAW,GAAEA,IAAI,CAACC,KAAM,IAAGD,IAAI,CAACE,OAAQ,EAA1D,EAA6DC,IAA7D,CAAkE,GAAlE,CAAP;IACD;;IACD,OAAON,SAAS,CAACO,SAAjB;EACD;;EACD,IAAI1N,KAAK,CAACgW,SAAN,IACFnU,MAAM,CAACgU,mCADL,IAEF;EACA,kBAAkBtH,IAAlB,CAAuBtB,WAAW,EAAlC,CAHF,EAGyC;IACvC,MAAM;MAAE5I,eAAF;MAAmBlC,eAAnB;MAAoCyC;IAApC,IAAwD,MAAM,OAAO,+BAAP,CAApE;IACA5C,QAAQ,CAACqC,eAAT,GAA2BA,eAA3B;IACArC,QAAQ,CAAC4C,eAAT,GAA2BA,eAA3B;IACA5C,QAAQ,CAACG,eAAT,GAA2BA,eAA3B;EACD;AACF;;AACD,MAAM8T,sBAAsB,GAAG,gBAA/B;AACA;AACA;AACA;;AACA,MAAMC,yBAAyB,GAAG,GAAlC;AACA,MAAMC,mBAAmB,GAAG,CAC1B,KAD0B,EAE1B,QAF0B,EAG1B,OAH0B,EAI1B,MAJ0B,EAK1B,WAL0B,EAM1B,SAN0B,EAO1B,cAP0B,EAQ1B,YAR0B,EAS1B,aAT0B,EAU1B,WAV0B,EAW1B,YAX0B,EAY1B,UAZ0B,CAA5B;AAcA,MAAMC,oBAAoB,GAAG,cAA7B;AACA,MAAMC,WAAW,GAAG;EAClBC,SAAS,EAAE,0BADO;EAElBC,eAAe,EAAE;AAFC,CAApB;;AAIA,SAASC,aAAT,CAAuB;EAAEpW,SAAF;EAAaqW,WAAb;EAA0BC,cAA1B;EAA0CC,cAA1C;EAA0DC,cAA1D;EAA0EC,OAA1E;EAAmFC;AAAnF,CAAvB,EAAkH;EAChH,MAAMC,iBAAiB,GAAG,CAACnL,KAAK,EAAN,EAAUd,IAAI,EAAd,CAA1B;;EACA,IAAIgM,IAAI,KAAK,MAAb,EAAqB;IACnB,OAAO,CACL,GAAGC,iBADE,EAELrN,IAAI,CAAC;MACHK,kBAAkB,EAAE2M,cAAc,IAAI,CAAC,WAAD,EAAc,KAAd,EAAqB,SAArB,EAAgC,cAAhC,EAAgD,QAAhD,EAA0D,YAA1D;IADnC,CAAD,CAFC,CAAP;EAMD;;EACD,IAAII,IAAI,KAAK,SAAT,IAAsBA,IAAI,KAAK,SAAnC,EAA8C;IAC5C,MAAM/U,UAAU,GAAG,CACjB,GAAGgV,iBADc,EAEjB3Q,MAAM,CAAC;MACL9E,QAAQ,EAAE,OAAOqV,cAAP,KAA0B,QAA1B,GAAqCA,cAArC,GAAsD,CAD3D;MAEL9M,SAAS,EAAE,OAAO+M,cAAP,KAA0B,QAA1B,GAAqCA,cAArC,GAAsD;IAF5D,CAAD,CAFW,CAAnB;;IAOA,IAAIxW,SAAS,KAAK,MAAd,IAAwBA,SAAS,KAAK,YAAtC,IAAsDA,SAAS,KAAK,UAAxE,EAAoF;MAClF2B,UAAU,CAACsI,IAAX,CAAgBtC,aAAa,CAAC;QAAExC,SAAS,EAAEnF,SAAS,KAAK,YAAd,GAA6B,OAA7B,GAAuCA,SAAS,KAAK,UAAd,GAA2B,KAA3B,GAAmC;MAAvF,CAAD,CAA7B;IACD,CAFD,MAGK,IAAI,CAACqW,WAAL,EAAkB;MACrB1U,UAAU,CAACsI,IAAX,CAAgBX,IAAI,CAACgN,cAAc,GAAG;QAAE3M,kBAAkB,EAAE2M;MAAtB,CAAH,GAA4C,EAA3D,CAApB;IACD;;IACD,IAAIG,OAAJ,EAAa;MACX9U,UAAU,CAACsI,IAAX,CAAgB/E,KAAK,CAAC;QACpBnB,OAAO,EAAE0S;MADW,CAAD,CAArB;IAGD;;IACD,OAAO9U,UAAP;EACD;;EACD,OAAO,EAAP;AACD;;AACD,SAASiV,wBAAT,CAAkC1O,UAAlC,EAA8C2O,EAA9C,EAAkD;EAChD,MAAMC,kBAAkB,GAAG5O,UAAU,CAACR,MAAX,CAAmB1H,SAAD,IAAe+V,mBAAmB,CAAC3V,QAApB,CAA6BJ,SAA7B,CAAjC,CAA3B;;EACA,IAAI8W,kBAAkB,CAAC3V,MAAnB,KAA8B+G,UAAU,CAAC/G,MAA7C,EAAqD;IACnD4V,OAAO,CAACC,IAAR,CAAc,GAAEH,EAAE,CAACI,OAAQ,+DAA8DlB,mBAAmB,CACzGzL,GADsF,CACjFtK,SAAD,IAAgB,IAAGA,SAAU,GADqD,EAEtFqN,IAFsF,CAEjF,IAFiF,EAGtF6J,IAHsF,EAG/E,EAHV,EAGa;MAAEL;IAAF,CAHb;EAID;;EACD,OAAOC,kBAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,qBAAT,CAA+BC,UAA/B,EAA2CpX,SAA3C,EAAsD;EACpD,MAAMkI,UAAU,GAAG,CAAC,MAAD,EAAS,OAAT,CAAnB;;EACA,IAAIzI,aAAa,CAAC2X,UAAD,CAAb,KAA8B,KAAlC,EAAyC;IACvClP,UAAU,CAACmP,OAAX;EACD;;EACD,OAAOrX,SAAS,CACbuG,OADI,CACI,YADJ,EACkB,QADlB,EAEJA,OAFI,CAEI,aAFJ,EAEmB,MAFnB,EAGJA,OAHI,CAGI,WAHJ,EAGiB2B,UAAU,CAAC,CAAD,CAH3B,EAIJ3B,OAJI,CAII,YAJJ,EAIkB2B,UAAU,CAAC,CAAD,CAJ5B,CAAP;AAKD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeoP,UAAf,CAA0BC,SAA1B,EAAqChU,OAArC,EAA8CiU,OAAO,GAAG,KAAxD,EAA+D;EAC7D,IAAI,CAACD,SAAS,CAACE,IAAf,EAAqB;IACnB;EACD;;EACD,OAAOD,OAAO,GAAGE,mBAAmB,CAACnU,OAAD,CAAtB,GAAkCoU,kBAAkB,CAACpU,OAAD,CAAlE;AACD;;AACD,MAAMmU,mBAAmB,GAAG5X,QAAQ,CAAC6X,kBAAD,EAAqB7B,yBAArB,EAAgD;EAClF8B,OAAO,EAAE,IADyE;EAElFC,OAAO,EAAE/B;AAFyE,CAAhD,CAApC;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe6B,kBAAf,CAAkC;EAAEG,WAAF;EAAeV,UAAf;EAA2BW,kBAAkB,GAAG,UAAhD;EAA4D/X,SAA5D;EAAuEqW,WAAvE;EAAoFC,cAApF;EAAoGC,cAApG;EAAoHC,cAApH;EAAoIwB,YAAY,GAAG,KAAnJ;EAA0JvB,OAA1J;EAAmKC;AAAnK,CAAlC,EAA6M;EAC3M,IAAIuB,EAAJ;;EACA,IAAI,CAACH,WAAD,IAAgB,CAACV,UAAjB,IAAgCY,YAAY,IAAI,CAACvB,OAArD,EAA+D;IAC7D,OAAO,IAAP;EACD;;EACD,MAAMf,sBAAN;EACA,MAAM;IAAE7U,CAAF;IAAKG,CAAL;IAAQhB,SAAS,EAAEkY,kBAAnB;IAAuCxW,QAAQ,EAAEyP,QAAjD;IAA2DlP;EAA3D,IAA8E,MAAMqT,eAAe,CAACwC,WAAD,EAAcV,UAAd,EAA0B;IACjI1V,QAAQ,EAAEqW,kBADuH;IAEjI/X,SAAS,EAAEA,SAAS,KAAK,MAAd,IAAwBA,SAAS,KAAK,YAAtC,IAAsDA,SAAS,KAAK,UAApE,GACPmY,SADO,GAEPhB,qBAAqB,CAACC,UAAD,EAAapX,SAAb,CAJwG;IAKjI2B,UAAU,EAAEyU,aAAa,CAAC;MACxBpW,SADwB;MAExBqW,WAFwB;MAGxBC,cAHwB;MAIxBC,cAJwB;MAKxBC,cALwB;MAMxBC,OANwB;MAOxBC;IAPwB,CAAD;EALwG,CAA1B,CAAzG;;EAeA,IAAIzU,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,CAACiD,KAAnF,EAA0F;IACxF,MAAM;MAAErE,CAAC,EAAEuX,MAAL;MAAapX,CAAC,EAAEqX;IAAhB,IAA2BpW,cAAc,CAACiD,KAAhD;IACAoT,MAAM,CAACC,MAAP,CAAc9B,OAAO,CAAC+B,KAAtB,EAA6B;MAC3BvV,IAAI,EAAEmV,MAAM,IAAI,IAAV,GAAkB,GAAEA,MAAO,IAA3B,GAAiC,EADZ;MAE3BtV,GAAG,EAAEuV,MAAM,IAAI,IAAV,GAAkB,GAAEA,MAAO,IAA3B,GAAiC;IAFX,CAA7B;EAID;;EACD,MAAMvN,eAAe,GAAG,CAACmN,EAAE,GAAGhW,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,CAACyI,IAArF,MAA+F,IAA/F,IAAuGuN,EAAE,KAAK,KAAK,CAAnH,GAAuH,KAAK,CAA5H,GAAgIA,EAAE,CAACnN,eAA3J;EACA,MAAM2N,UAAU,GAAG3N,eAAe,GAAG,QAAH,GAAc,IAAhD;EACA,MAAM4N,aAAa,GAAGD,UAAU,GAAG,MAAH,GAAY,IAA5C;EACArB,UAAU,CAACuB,YAAX,CAAwB9C,sBAAxB,EAAgDqC,kBAAhD;EACA,MAAM1J,SAAS,GAAI,aAAY9J,IAAI,CAACoK,KAAL,CAAWjO,CAAX,CAAc,MAAK6D,IAAI,CAACoK,KAAL,CAAW9N,CAAX,CAAc,KAAhE;EACAsX,MAAM,CAACC,MAAP,CAAcnB,UAAU,CAACoB,KAAzB,EAAgC;IAC9BC,UAD8B;IAE9BC,aAF8B;IAG9BvH,QAH8B;IAI9BrO,GAAG,EAAE,GAJyB;IAK9BG,IAAI,EAAE,GALwB;IAM9BuL;EAN8B,CAAhC;AAQD;AACD;AACA;AACA;AACA;AACA;;;AACA,MAAMoK,UAAU,GAAG,IAAIC,OAAJ,EAAnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,iBAAT,CAA2BvB,SAA3B,EAAsCO,WAAtC,EAAmDV,UAAnD,EAA+D;EAC7D,IAAI,CAACA,UAAD,IAAe,CAACU,WAApB,EAAiC;IAC/B;EACD;;EACDiB,oBAAoB,CAACxB,SAAD,EAAYO,WAAZ,EAAyBV,UAAzB,CAApB;EACA,MAAMjG,QAAQ,GAAGoG,SAAS,CAACQ,kBAA3B,CAL6D,CAM7D;;EACAX,UAAU,CAACoB,KAAX,CAAiBrH,QAAjB,GAA4BA,QAA5B;;EACA,IAAIA,QAAQ,KAAK,UAAjB,EAA6B;IAC3B6H,aAAa,CAAC5B,UAAD,CAAb;EACD;;EACD,MAAM6B,aAAa,GAAGrZ,KAAK,CAACgW,SAAN,GAClB/B,UADkB,GAElB,CAACqF,MAAD,EAASC,WAAT,EAAsBC,cAAtB,KAAyC;IACzCA,cAAc;IACd,OAAO,MAAM;MACX;IACD,CAFD;EAGD,CAPH;EAQAR,UAAU,CAACS,GAAX,CAAe9B,SAAf,EAA0B0B,aAAa,CAACnB,WAAD,EAAcV,UAAd,EAA0B,MAAMG,SAAS,CAACD,UAAV,EAAhC,CAAvC;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASyB,oBAAT,CAA8BxB,SAA9B,EAAyCO,WAAzC,EAAsDV,UAAtD,EAAkE;EAChE,IAAI,CAACA,UAAD,IAAe,CAACU,WAApB,EAAiC;IAC/B;EACD;;EACDwB,mBAAmB,CAAClC,UAAD,CAAnB,CAAgCjC,mBAAhC,CAAoD,eAApD,EAAqEoE,+BAArE;EACA,MAAMC,OAAO,GAAGZ,UAAU,CAACa,GAAX,CAAelC,SAAf,CAAhB;;EACA,IAAIiC,OAAJ,EAAa;IACXA,OAAO;EACR;;EACDZ,UAAU,CAACc,MAAX,CAAkBnC,SAAlB;AACD;;AACD,MAAMoC,kBAAkB,GAAG,CAA3B;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,qBAAqB,GAAGlV,IAAI,CAACmV,IAAL,CAAUnV,IAAI,CAACoV,KAAL,CAAWH,kBAAX,EAA+BA,kBAA/B,CAAV,CAA9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASI,gBAAT,CAA0B3C,UAA1B,EAAsC;EACpC,IAAI,CAACA,UAAD,IAAeA,UAAU,CAACoB,KAAX,CAAiBrH,QAAjB,KAA8B,UAAjD,EAA6D;IAC3D;EACD;;EACDmI,mBAAmB,CAAClC,UAAD,CAAnB,CAAgC7C,gBAAhC,CAAiD,eAAjD,EAAkEgF,+BAAlE;AACD;;AACD,SAASD,mBAAT,CAA6BlC,UAA7B,EAAyC;EACvC;EACA,OAAOA,UAAU,CAAC4C,UAAX,IAAyB5C,UAAhC;AACD;;AACD,SAASmC,+BAAT,CAAyCU,KAAzC,EAAgD;EAC9C,MAAMC,oBAAoB,GAAGD,KAAK,CAAC3H,MAAnC;;EACA,KACA;EACA2H,KAAK,CAACE,YAAN,KAAuB,SAAvB,IACED,oBAAoB,CAACE,SAArB,CAA+B5H,QAA/B,CAAwCyD,WAAW,CAACC,SAApD,CAHF,EAGkE;IAChE,MAAMkB,UAAU,GAAGiD,iCAAiC,CAACH,oBAAD,CAApD;IACAlB,aAAa,CAAC5B,UAAD,CAAb;IACAkC,mBAAmB,CAAClC,UAAD,CAAnB,CAAgCjC,mBAAhC,CAAoD,eAApD,EAAqEoE,+BAArE;EACD;AACF;;AACD,SAASP,aAAT,CAAuB5B,UAAvB,EAAmC;EACjCA,UAAU,CAACoB,KAAX,CAAiBhK,SAAjB,GAA6B,EAA7B;EACA4I,UAAU,CAACoB,KAAX,CAAiB1V,GAAjB,GAAuB,UAAvB;EACAsU,UAAU,CAACoB,KAAX,CAAiBvV,IAAjB,GAAwB,UAAxB;AACD;;AACD,SAASoX,iCAAT,CAA2CH,oBAA3C,EAAiE;EAC/D,OAAOva,iCAAiC,CAACua,oBAAD,EAAwB,IAAGrE,sBAAuB,GAAlD,CAAxC;AACD;;AAED,SAASI,WAAW,IAAIqE,CAAxB,EAA2BvB,oBAAoB,IAAIjQ,CAAnD,EAAsD8Q,qBAAqB,IAAI7Q,CAA/E,EAAkF+P,iBAAiB,IAAItZ,CAAvG,EAA0GwW,oBAAoB,IAAInW,CAAlI,EAAqIsD,gBAAgB,IAAIoX,CAAzJ,EAA4J3D,wBAAwB,IAAI4D,CAAxL,EAA2LlD,UAAU,IAAImD,CAAzM,EAA4MV,gBAAgB,IAAIW,CAAhO"},"metadata":{},"sourceType":"module"}