{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { Float4Uniform as e } from \"../views/3d/webgl-engine/core/shaderModules/Float4Uniform.js\";\nimport { glsl as o } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as t } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DUniform as r } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DUniform.js\";\nimport { SMAAOutput as s } from \"../views/3d/webgl-engine/lib/SMAATechniqueConfiguration.js\";\nimport { VertexAttribute as d } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nconst a = {\n  threshold: .05,\n  localConstrastAdaption: 2,\n  maxSearchSteps: 8,\n  maxDistanceAreaTex: 16\n};\n\nfunction x(x) {\n  const c = new t();\n  return x.output === s.EdgeDetector && (c.attributes.add(d.POSITION, \"vec2\"), c.vertex.uniforms.add(new e(\"resolution\")), c.varyings.add(\"fTexCoord\", \"vec2\"), c.varyings.add(\"fOffset[3]\", \"vec4\"), c.vertex.code.add(o`void SMAAEdgeDetectionVS( vec2 texcoord ) {\nfOffset[0] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\nfOffset[1] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\nfOffset[2] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\n}\nvoid main() {\nfTexCoord = (position + 1.0 ) * 0.5;\ngl_Position = vec4(position, 0, 1);\nSMAAEdgeDetectionVS( fTexCoord );\n}`), c.fragment.uniforms.add(new r(\"tColor\")), c.fragment.code.add(o`\n      vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n        vec2 threshold = vec2( ${o.float(a.threshold)} );\n\n        // Calculate color deltas:\n        vec4 delta;\n        vec3 C = texture2D( colorTex, texcoord ).rgb;\n\n        vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n        vec3 t = abs( C - Cleft );\n        delta.x = max( max( t.r, t.g ), t.b );\n\n        vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n        t = abs( C - Ctop );\n        delta.y = max( max( t.r, t.g ), t.b );\n\n        // We do the usual threshold:\n        vec2 edges = step( threshold, delta.xy );\n\n        // Then discard if there is no edge:\n        if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n            discard;\n\n        // Calculate right and bottom deltas:\n        vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n        t = abs( C - Cright );\n        delta.z = max( max( t.r, t.g ), t.b );\n\n        vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n        t = abs( C - Cbottom );\n        delta.w = max( max( t.r, t.g ), t.b );\n\n        // Calculate the maximum delta in the direct neighborhood:\n        float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n        // Calculate left-left and top-top deltas:\n        vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n        t = abs( C - Cleftleft );\n        delta.z = max( max( t.r, t.g ), t.b );\n\n        vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n        t = abs( C - Ctoptop );\n        delta.w = max( max( t.r, t.g ), t.b );\n\n        // Calculate the final maximum delta:\n        maxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n        // Local contrast adaptation in action:\n        edges.xy *= step( maxDelta, float(${o.float(a.localConstrastAdaption)}) * delta.xy );\n\n        return vec4( edges, 0.0, 0.0 );\n      }\n\n      void main() {\n        gl_FragColor = SMAAColorEdgeDetectionPS( fTexCoord, fOffset, tColor );\n      }\n    `)), x.output === s.BlendWeight && (c.attributes.add(d.POSITION, \"vec2\"), c.vertex.uniforms.add(new e(\"resolution\")), c.varyings.add(\"fTexCoord\", \"vec2\"), c.varyings.add(\"fOffset[3]\", \"vec4\"), c.varyings.add(\"fPixCoord\", \"vec2\"), c.vertex.code.add(o`\n      void SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n        fPixCoord = texcoord * resolution.zw;\n        fOffset[0] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\n        fOffset[1] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\n        fOffset[2] = vec4( fOffset[0].xz, fOffset[1].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( ${o.int(a.maxSearchSteps)} );\n      }\n\n      void main() {\n        fTexCoord = (position + 1.0 ) * 0.5;\n        gl_Position = vec4(position, 0, 1);\n        SMAABlendingWeightCalculationVS( fTexCoord );\n      }\n    `), c.fragment.uniforms.add(new r(\"tEdges\")), c.fragment.uniforms.add(new r(\"tArea\")), c.fragment.uniforms.add(new r(\"tSearch\")), c.fragment.uniforms.add(new r(\"tColor\")), c.fragment.uniforms.add(new e(\"resolution\")), c.fragment.code.add(o`\n      #define SMAA_AREATEX_PIXEL_SIZE ( 1.0 / vec2( 160.0, 560.0 ) )\n      #define SMAA_AREATEX_SUBTEX_SIZE ( 1.0 / 7.0 )\n\n      vec4 SMAASampleLevelZeroOffset(sampler2D texture, vec2 coord, vec2 offset) {\n        return texture2D(texture, coord + offset.x * resolution.xy, 0.0);\n      }\n\n      vec2 round( vec2 x ) {\n        return sign( x ) * floor( abs( x ) + 0.5 );\n      }\n\n      float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n        e.r = bias + e.r * scale;\n        return 255.0 * texture2D( searchTex, e, 0.0 ).r;\n      }\n\n      float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 2.0, 0.0 ) * resolution.xy;\n          if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x += 0.25 * resolution.x;\n        texcoord.x += resolution.x;\n        texcoord.x += 2.0 * resolution.x;\n        texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n        return texcoord.x;\n      }\n\n      float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 2.0, 0.0 ) * resolution.xy;\n          if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x -= 0.25 * resolution.x;\n        texcoord.x -= resolution.x;\n        texcoord.x -= 2.0 * resolution.x;\n        texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n        return texcoord.x;\n      }\n\n      float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 0.0, 2.0 ) * resolution.xy;\n          if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y -= 0.25 * resolution.y;\n        texcoord.y -= resolution.y;\n        texcoord.y -= 2.0 * resolution.y;\n        texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );\n        return texcoord.y;\n      }\n\n      float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 0.0, 2.0 ) * resolution.xy;\n          if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y += 0.25 * resolution.y;\n        texcoord.y += resolution.y;\n        texcoord.y += 2.0 * resolution.y;\n        texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );\n        return texcoord.y;\n      }\n\n      vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n        vec2 texcoord = float( ${o.int(a.maxDistanceAreaTex)} ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n        texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n        texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n        return texture2D( areaTex, texcoord, 0.0 ).rg;\n      }\n\n      vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n        vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n        vec2 e = texture2D( edgesTex, texcoord ).rg;\n        if ( e.g > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n          coords.y = offset[ 1 ].y;\n          d.x = coords.x;\n          float e1 = texture2D( edgesTex, coords, 0.0 ).r;\n          coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n          d.y = coords.x;\n          d = d * resolution.z - pixcoord.x;\n          vec2 sqrt_d = sqrt( abs( d ) );\n          coords.y -= 1.0 * resolution.y;\n          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 1.0, 0.0 ) ).r;\n          weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n        }\n\n        if ( e.r > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n          coords.x = offset[ 0 ].x;\n          d.x = coords.y;\n          float e1 = texture2D( edgesTex, coords, 0.0 ).g;\n          coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n          d.y = coords.y;\n          d = d * resolution.w - pixcoord.y;\n          vec2 sqrt_d = sqrt( abs( d ) );\n          coords.y -= 1.0 * resolution.y;\n          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 0.0, 1.0 ) ).g;\n          weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\n          // for some reason the following lines are necessary to prevent\n          // texture lookup precision issues on some Intel integrated graphics chips\n          vec4 dbg = (offset[ 0 ]+offset[ 1 ]+offset[ 2 ] + coords.xyyx);\n          weights.r += 0.00000001 * dot(vec4(0,1,0,1),dbg);\n        }\n        return weights;\n      }\n\n      void main() {\n        gl_FragColor = SMAABlendingWeightCalculationPS( fTexCoord, fPixCoord, fOffset, tEdges, tArea, tSearch, ivec4( 0.0 ) );\n      }\n    `)), x.output === s.Blur && (c.attributes.add(d.POSITION, \"vec2\"), c.vertex.uniforms.add(new e(\"resolution\")), c.varyings.add(\"fTexCoord\", \"vec2\"), c.varyings.add(\"fOffset[2]\", \"vec4\"), c.vertex.code.add(o`void SMAANeighborhoodBlendingVS( vec2 texcoord ) {\nfOffset[0] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );\nfOffset[1] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );\n}\nvoid main() {\nfTexCoord = (position + 1.0 ) * 0.5;\ngl_Position = vec4(position, 0, 1);\nSMAANeighborhoodBlendingVS(fTexCoord);\n}`), c.fragment.uniforms.add(new r(\"tBlendWeights\")), c.fragment.uniforms.add(new r(\"tColor\")), c.fragment.uniforms.add(new e(\"resolution\")), c.fragment.code.add(o`vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\nvec4 a;\na.xz = texture2D( blendTex, texcoord ).xz;\na.y = texture2D( blendTex, offset[ 1 ].zw ).g;\na.w = texture2D( blendTex, offset[ 1 ].xy ).a;\nif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\nreturn texture2D( colorTex, texcoord, 0.0 );\n} else {\nvec2 offset;\noffset.x = a.a > a.b ? a.a : -a.b;\noffset.y = a.g > a.r ? -a.g : a.r;\nif ( abs( offset.x ) > abs( offset.y )) {\noffset.y = 0.0;\n} else {\noffset.x = 0.0;\n}\nvec4 C = texture2D( colorTex, texcoord, 0.0 );\ntexcoord += sign( offset ) * resolution.xy;\nvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\nfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\nvec4 mixed = mix(C, Cop, s);\nreturn mixed;\n}\n}\nvoid main() {\ngl_FragColor = SMAANeighborhoodBlendingPS( fTexCoord, fOffset, tColor, tBlendWeights );\n}`)), c;\n}\n\nconst c = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: x\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { c as S, x as b };","map":{"version":3,"names":["Float4Uniform","e","glsl","o","ShaderBuilder","t","Texture2DUniform","r","SMAAOutput","s","VertexAttribute","d","a","threshold","localConstrastAdaption","maxSearchSteps","maxDistanceAreaTex","x","c","output","EdgeDetector","attributes","add","POSITION","vertex","uniforms","varyings","code","fragment","float","BlendWeight","int","Blur","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","S","b"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/chunks/SMAA.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{Float4Uniform as e}from\"../views/3d/webgl-engine/core/shaderModules/Float4Uniform.js\";import{glsl as o}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as t}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DUniform as r}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DUniform.js\";import{SMAAOutput as s}from\"../views/3d/webgl-engine/lib/SMAATechniqueConfiguration.js\";import{VertexAttribute as d}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";const a={threshold:.05,localConstrastAdaption:2,maxSearchSteps:8,maxDistanceAreaTex:16};function x(x){const c=new t;return x.output===s.EdgeDetector&&(c.attributes.add(d.POSITION,\"vec2\"),c.vertex.uniforms.add(new e(\"resolution\")),c.varyings.add(\"fTexCoord\",\"vec2\"),c.varyings.add(\"fOffset[3]\",\"vec4\"),c.vertex.code.add(o`void SMAAEdgeDetectionVS( vec2 texcoord ) {\nfOffset[0] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\nfOffset[1] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\nfOffset[2] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\n}\nvoid main() {\nfTexCoord = (position + 1.0 ) * 0.5;\ngl_Position = vec4(position, 0, 1);\nSMAAEdgeDetectionVS( fTexCoord );\n}`),c.fragment.uniforms.add(new r(\"tColor\")),c.fragment.code.add(o`\n      vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n        vec2 threshold = vec2( ${o.float(a.threshold)} );\n\n        // Calculate color deltas:\n        vec4 delta;\n        vec3 C = texture2D( colorTex, texcoord ).rgb;\n\n        vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n        vec3 t = abs( C - Cleft );\n        delta.x = max( max( t.r, t.g ), t.b );\n\n        vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n        t = abs( C - Ctop );\n        delta.y = max( max( t.r, t.g ), t.b );\n\n        // We do the usual threshold:\n        vec2 edges = step( threshold, delta.xy );\n\n        // Then discard if there is no edge:\n        if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n            discard;\n\n        // Calculate right and bottom deltas:\n        vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n        t = abs( C - Cright );\n        delta.z = max( max( t.r, t.g ), t.b );\n\n        vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n        t = abs( C - Cbottom );\n        delta.w = max( max( t.r, t.g ), t.b );\n\n        // Calculate the maximum delta in the direct neighborhood:\n        float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n        // Calculate left-left and top-top deltas:\n        vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n        t = abs( C - Cleftleft );\n        delta.z = max( max( t.r, t.g ), t.b );\n\n        vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n        t = abs( C - Ctoptop );\n        delta.w = max( max( t.r, t.g ), t.b );\n\n        // Calculate the final maximum delta:\n        maxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n        // Local contrast adaptation in action:\n        edges.xy *= step( maxDelta, float(${o.float(a.localConstrastAdaption)}) * delta.xy );\n\n        return vec4( edges, 0.0, 0.0 );\n      }\n\n      void main() {\n        gl_FragColor = SMAAColorEdgeDetectionPS( fTexCoord, fOffset, tColor );\n      }\n    `)),x.output===s.BlendWeight&&(c.attributes.add(d.POSITION,\"vec2\"),c.vertex.uniforms.add(new e(\"resolution\")),c.varyings.add(\"fTexCoord\",\"vec2\"),c.varyings.add(\"fOffset[3]\",\"vec4\"),c.varyings.add(\"fPixCoord\",\"vec2\"),c.vertex.code.add(o`\n      void SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n        fPixCoord = texcoord * resolution.zw;\n        fOffset[0] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\n        fOffset[1] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\n        fOffset[2] = vec4( fOffset[0].xz, fOffset[1].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( ${o.int(a.maxSearchSteps)} );\n      }\n\n      void main() {\n        fTexCoord = (position + 1.0 ) * 0.5;\n        gl_Position = vec4(position, 0, 1);\n        SMAABlendingWeightCalculationVS( fTexCoord );\n      }\n    `),c.fragment.uniforms.add(new r(\"tEdges\")),c.fragment.uniforms.add(new r(\"tArea\")),c.fragment.uniforms.add(new r(\"tSearch\")),c.fragment.uniforms.add(new r(\"tColor\")),c.fragment.uniforms.add(new e(\"resolution\")),c.fragment.code.add(o`\n      #define SMAA_AREATEX_PIXEL_SIZE ( 1.0 / vec2( 160.0, 560.0 ) )\n      #define SMAA_AREATEX_SUBTEX_SIZE ( 1.0 / 7.0 )\n\n      vec4 SMAASampleLevelZeroOffset(sampler2D texture, vec2 coord, vec2 offset) {\n        return texture2D(texture, coord + offset.x * resolution.xy, 0.0);\n      }\n\n      vec2 round( vec2 x ) {\n        return sign( x ) * floor( abs( x ) + 0.5 );\n      }\n\n      float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n        e.r = bias + e.r * scale;\n        return 255.0 * texture2D( searchTex, e, 0.0 ).r;\n      }\n\n      float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 2.0, 0.0 ) * resolution.xy;\n          if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x += 0.25 * resolution.x;\n        texcoord.x += resolution.x;\n        texcoord.x += 2.0 * resolution.x;\n        texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n        return texcoord.x;\n      }\n\n      float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 2.0, 0.0 ) * resolution.xy;\n          if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x -= 0.25 * resolution.x;\n        texcoord.x -= resolution.x;\n        texcoord.x -= 2.0 * resolution.x;\n        texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n        return texcoord.x;\n      }\n\n      float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 0.0, 2.0 ) * resolution.xy;\n          if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y -= 0.25 * resolution.y;\n        texcoord.y -= resolution.y;\n        texcoord.y -= 2.0 * resolution.y;\n        texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );\n        return texcoord.y;\n      }\n\n      float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 0.0, 2.0 ) * resolution.xy;\n          if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y += 0.25 * resolution.y;\n        texcoord.y += resolution.y;\n        texcoord.y += 2.0 * resolution.y;\n        texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );\n        return texcoord.y;\n      }\n\n      vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n        vec2 texcoord = float( ${o.int(a.maxDistanceAreaTex)} ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n        texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n        texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n        return texture2D( areaTex, texcoord, 0.0 ).rg;\n      }\n\n      vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n        vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n        vec2 e = texture2D( edgesTex, texcoord ).rg;\n        if ( e.g > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n          coords.y = offset[ 1 ].y;\n          d.x = coords.x;\n          float e1 = texture2D( edgesTex, coords, 0.0 ).r;\n          coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n          d.y = coords.x;\n          d = d * resolution.z - pixcoord.x;\n          vec2 sqrt_d = sqrt( abs( d ) );\n          coords.y -= 1.0 * resolution.y;\n          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 1.0, 0.0 ) ).r;\n          weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n        }\n\n        if ( e.r > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n          coords.x = offset[ 0 ].x;\n          d.x = coords.y;\n          float e1 = texture2D( edgesTex, coords, 0.0 ).g;\n          coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n          d.y = coords.y;\n          d = d * resolution.w - pixcoord.y;\n          vec2 sqrt_d = sqrt( abs( d ) );\n          coords.y -= 1.0 * resolution.y;\n          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 0.0, 1.0 ) ).g;\n          weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\n          // for some reason the following lines are necessary to prevent\n          // texture lookup precision issues on some Intel integrated graphics chips\n          vec4 dbg = (offset[ 0 ]+offset[ 1 ]+offset[ 2 ] + coords.xyyx);\n          weights.r += 0.00000001 * dot(vec4(0,1,0,1),dbg);\n        }\n        return weights;\n      }\n\n      void main() {\n        gl_FragColor = SMAABlendingWeightCalculationPS( fTexCoord, fPixCoord, fOffset, tEdges, tArea, tSearch, ivec4( 0.0 ) );\n      }\n    `)),x.output===s.Blur&&(c.attributes.add(d.POSITION,\"vec2\"),c.vertex.uniforms.add(new e(\"resolution\")),c.varyings.add(\"fTexCoord\",\"vec2\"),c.varyings.add(\"fOffset[2]\",\"vec4\"),c.vertex.code.add(o`void SMAANeighborhoodBlendingVS( vec2 texcoord ) {\nfOffset[0] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );\nfOffset[1] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );\n}\nvoid main() {\nfTexCoord = (position + 1.0 ) * 0.5;\ngl_Position = vec4(position, 0, 1);\nSMAANeighborhoodBlendingVS(fTexCoord);\n}`),c.fragment.uniforms.add(new r(\"tBlendWeights\")),c.fragment.uniforms.add(new r(\"tColor\")),c.fragment.uniforms.add(new e(\"resolution\")),c.fragment.code.add(o`vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\nvec4 a;\na.xz = texture2D( blendTex, texcoord ).xz;\na.y = texture2D( blendTex, offset[ 1 ].zw ).g;\na.w = texture2D( blendTex, offset[ 1 ].xy ).a;\nif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\nreturn texture2D( colorTex, texcoord, 0.0 );\n} else {\nvec2 offset;\noffset.x = a.a > a.b ? a.a : -a.b;\noffset.y = a.g > a.r ? -a.g : a.r;\nif ( abs( offset.x ) > abs( offset.y )) {\noffset.y = 0.0;\n} else {\noffset.x = 0.0;\n}\nvec4 C = texture2D( colorTex, texcoord, 0.0 );\ntexcoord += sign( offset ) * resolution.xy;\nvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\nfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\nvec4 mixed = mix(C, Cop, s);\nreturn mixed;\n}\n}\nvoid main() {\ngl_FragColor = SMAANeighborhoodBlendingPS( fTexCoord, fOffset, tColor, tBlendWeights );\n}`)),c}const c=Object.freeze(Object.defineProperty({__proto__:null,build:x},Symbol.toStringTag,{value:\"Module\"}));export{c as S,x as b};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,aAAa,IAAIC,CAAxB,QAA8B,8DAA9B;AAA6F,SAAOC,IAAI,IAAIC,CAAf,QAAqB,2DAArB;AAAiF,SAAOC,aAAa,IAAIC,CAAxB,QAA8B,8DAA9B;AAA6F,SAAOC,gBAAgB,IAAIC,CAA3B,QAAiC,iEAAjC;AAAmG,SAAOC,UAAU,IAAIC,CAArB,QAA2B,4DAA3B;AAAwF,SAAOC,eAAe,IAAIC,CAA1B,QAAgC,iDAAhC;AAAkF,MAAMC,CAAC,GAAC;EAACC,SAAS,EAAC,GAAX;EAAeC,sBAAsB,EAAC,CAAtC;EAAwCC,cAAc,EAAC,CAAvD;EAAyDC,kBAAkB,EAAC;AAA5E,CAAR;;AAAwF,SAASC,CAAT,CAAWA,CAAX,EAAa;EAAC,MAAMC,CAAC,GAAC,IAAIb,CAAJ,EAAR;EAAc,OAAOY,CAAC,CAACE,MAAF,KAAWV,CAAC,CAACW,YAAb,KAA4BF,CAAC,CAACG,UAAF,CAAaC,GAAb,CAAiBX,CAAC,CAACY,QAAnB,EAA4B,MAA5B,GAAoCL,CAAC,CAACM,MAAF,CAASC,QAAT,CAAkBH,GAAlB,CAAsB,IAAIrB,CAAJ,CAAM,YAAN,CAAtB,CAApC,EAA+EiB,CAAC,CAACQ,QAAF,CAAWJ,GAAX,CAAe,WAAf,EAA2B,MAA3B,CAA/E,EAAkHJ,CAAC,CAACQ,QAAF,CAAWJ,GAAX,CAAe,YAAf,EAA4B,MAA5B,CAAlH,EAAsJJ,CAAC,CAACM,MAAF,CAASG,IAAT,CAAcL,GAAd,CAAkBnB,CAAE;AACz1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EATq0B,CAAtJ,EAS3qBe,CAAC,CAACU,QAAF,CAAWH,QAAX,CAAoBH,GAApB,CAAwB,IAAIf,CAAJ,CAAM,QAAN,CAAxB,CAT2qB,EASloBW,CAAC,CAACU,QAAF,CAAWD,IAAX,CAAgBL,GAAhB,CAAoBnB,CAAE;AACnE;AACA,iCAAiCA,CAAC,CAAC0B,KAAF,CAAQjB,CAAC,CAACC,SAAV,CAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4CV,CAAC,CAAC0B,KAAF,CAAQjB,CAAC,CAACE,sBAAV,CAAkC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAxD6C,CATsmB,GAiE3oBG,CAAC,CAACE,MAAF,KAAWV,CAAC,CAACqB,WAAb,KAA2BZ,CAAC,CAACG,UAAF,CAAaC,GAAb,CAAiBX,CAAC,CAACY,QAAnB,EAA4B,MAA5B,GAAoCL,CAAC,CAACM,MAAF,CAASC,QAAT,CAAkBH,GAAlB,CAAsB,IAAIrB,CAAJ,CAAM,YAAN,CAAtB,CAApC,EAA+EiB,CAAC,CAACQ,QAAF,CAAWJ,GAAX,CAAe,WAAf,EAA2B,MAA3B,CAA/E,EAAkHJ,CAAC,CAACQ,QAAF,CAAWJ,GAAX,CAAe,YAAf,EAA4B,MAA5B,CAAlH,EAAsJJ,CAAC,CAACQ,QAAF,CAAWJ,GAAX,CAAe,WAAf,EAA2B,MAA3B,CAAtJ,EAAyLJ,CAAC,CAACM,MAAF,CAASG,IAAT,CAAcL,GAAd,CAAkBnB,CAAE;AAChP;AACA;AACA;AACA;AACA,sHAAsHA,CAAC,CAAC4B,GAAF,CAAMnB,CAAC,CAACG,cAAR,CAAwB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAb4N,CAAzL,EAa5BG,CAAC,CAACU,QAAF,CAAWH,QAAX,CAAoBH,GAApB,CAAwB,IAAIf,CAAJ,CAAM,QAAN,CAAxB,CAb4B,EAaaW,CAAC,CAACU,QAAF,CAAWH,QAAX,CAAoBH,GAApB,CAAwB,IAAIf,CAAJ,CAAM,OAAN,CAAxB,CAbb,EAaqDW,CAAC,CAACU,QAAF,CAAWH,QAAX,CAAoBH,GAApB,CAAwB,IAAIf,CAAJ,CAAM,SAAN,CAAxB,CAbrD,EAa+FW,CAAC,CAACU,QAAF,CAAWH,QAAX,CAAoBH,GAApB,CAAwB,IAAIf,CAAJ,CAAM,QAAN,CAAxB,CAb/F,EAawIW,CAAC,CAACU,QAAF,CAAWH,QAAX,CAAoBH,GAApB,CAAwB,IAAIrB,CAAJ,CAAM,YAAN,CAAxB,CAbxI,EAaqLiB,CAAC,CAACU,QAAF,CAAWD,IAAX,CAAgBL,GAAhB,CAAoBnB,CAAE;AAC9O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+BA,CAAC,CAAC4B,GAAF,CAAMnB,CAAC,CAACG,cAAR,CAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+BZ,CAAC,CAAC4B,GAAF,CAAMnB,CAAC,CAACG,cAAR,CAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+BZ,CAAC,CAAC4B,GAAF,CAAMnB,CAAC,CAACG,cAAR,CAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+BZ,CAAC,CAAC4B,GAAF,CAAMnB,CAAC,CAACG,cAAR,CAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiCZ,CAAC,CAAC4B,GAAF,CAAMnB,CAAC,CAACI,kBAAR,CAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KA7HwN,CAbhN,CAjE2oB,EA2M3oBC,CAAC,CAACE,MAAF,KAAWV,CAAC,CAACuB,IAAb,KAAoBd,CAAC,CAACG,UAAF,CAAaC,GAAb,CAAiBX,CAAC,CAACY,QAAnB,EAA4B,MAA5B,GAAoCL,CAAC,CAACM,MAAF,CAASC,QAAT,CAAkBH,GAAlB,CAAsB,IAAIrB,CAAJ,CAAM,YAAN,CAAtB,CAApC,EAA+EiB,CAAC,CAACQ,QAAF,CAAWJ,GAAX,CAAe,WAAf,EAA2B,MAA3B,CAA/E,EAAkHJ,CAAC,CAACQ,QAAF,CAAWJ,GAAX,CAAe,YAAf,EAA4B,MAA5B,CAAlH,EAAsJJ,CAAC,CAACM,MAAF,CAASG,IAAT,CAAcL,GAAd,CAAkBnB,CAAE;AACtM;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EARkL,CAAtJ,EAQxBe,CAAC,CAACU,QAAF,CAAWH,QAAX,CAAoBH,GAApB,CAAwB,IAAIf,CAAJ,CAAM,eAAN,CAAxB,CARwB,EAQwBW,CAAC,CAACU,QAAF,CAAWH,QAAX,CAAoBH,GAApB,CAAwB,IAAIf,CAAJ,CAAM,QAAN,CAAxB,CARxB,EAQiEW,CAAC,CAACU,QAAF,CAAWH,QAAX,CAAoBH,GAApB,CAAwB,IAAIrB,CAAJ,CAAM,YAAN,CAAxB,CARjE,EAQ8GiB,CAAC,CAACU,QAAF,CAAWD,IAAX,CAAgBL,GAAhB,CAAoBnB,CAAE;AAChK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EA1B0I,CARlI,CA3M2oB,EA6O9oBe,CA7OuoB;AA6OroB;;AAAA,MAAMA,CAAC,GAACe,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,cAAP,CAAsB;EAACC,SAAS,EAAC,IAAX;EAAgBC,KAAK,EAACpB;AAAtB,CAAtB,EAA+CqB,MAAM,CAACC,WAAtD,EAAkE;EAACC,KAAK,EAAC;AAAP,CAAlE,CAAd,CAAR;AAA2G,SAAOtB,CAAC,IAAIuB,CAAZ,EAAcxB,CAAC,IAAIyB,CAAnB"},"metadata":{},"sourceType":"module"}