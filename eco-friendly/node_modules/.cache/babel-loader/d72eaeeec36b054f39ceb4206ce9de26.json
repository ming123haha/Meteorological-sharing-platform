{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { c as t } from \"./mat3f64.js\";\nimport { RayMarchingSteps as e } from \"../views/3d/environment/CloudsTechniqueConfiguration.js\";\nimport { ATLAS_SIZE as a, TILE_ROWS as o, TILE_SIZE as i, TEXTURE_SCALE as n, WEATHER_MAP_SCALE as r } from \"../views/3d/environment/NoiseTextureAtlasDimensions.js\";\nimport { ScreenSpacePass as s } from \"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js\";\nimport { FloatUniform as l } from \"../views/3d/webgl-engine/core/shaderModules/FloatUniform.js\";\nimport { NoParameters as c, glsl as d } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix3DrawUniform as u } from \"../views/3d/webgl-engine/core/shaderModules/Matrix3DrawUniform.js\";\nimport { ShaderBuilder as f } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DUniform.js\";\n\nclass p extends c {\n  constructor() {\n    super(...arguments), this.viewMatrix = t();\n  }\n\n}\n\nfunction g(t) {\n  const c = new f();\n  return c.include(s, !1), c.fragment.uniforms.add(new l(\"cloudRadius\")), c.fragment.uniforms.add(new l(\"halfCubeMapSize\")), c.fragment.uniforms.add(new l(\"power\")), c.fragment.uniforms.add(new l(\"sigmaE\")), c.fragment.uniforms.add(new l(\"density\")), c.fragment.uniforms.add(new l(\"cloudSize\")), c.fragment.uniforms.add(new l(\"detailSize\")), c.fragment.uniforms.add(new l(\"smoothness\")), c.fragment.uniforms.add(new l(\"cloudHeight\")), c.fragment.uniforms.add(new l(\"coverage\")), c.fragment.uniforms.add(new u(\"view\", t => t.viewMatrix)), c.fragment.uniforms.add(new m(\"cloudShapeTexture\")), c.fragment.code.add(d`\n    const int STEPS = ${t.steps === e.SIXTEEN ? d`16` : t.steps === e.HUNDRED ? d`100` : d`200`};\n    const int STEPS_LIGHT = 6;\n    const float stepL = 300.0 / float(STEPS_LIGHT);\n    const float cloudStart = 1500.0;\n\n    vec3 rayDirection(vec2 fragCoord) {\n      vec2 xy = fragCoord - halfCubeMapSize;\n      return normalize(vec3(-xy, -halfCubeMapSize));\n    }\n\n    float remap(float x, float low1, float high1, float low2, float high2) {\n      return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n    }\n\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }`), c.fragment.code.add(d`\n    float getCloudShape(vec3 pos, float pOffset) {\n      const float textureWidth = ${d.float(a)};\n      const float dataWidth = ${d.float(a)};\n      const float tileRows = ${d.float(o)};\n      const vec3 atlasDimensions = vec3(${d.float(i)}, ${d.float(i)}, tileRows * tileRows);\n\n      //Change from Y being height to Z being height\n      vec3 p = float(${d.float(n)}) * pos.xzy;\n\n      //Pixel coordinates of point in the 3D data\n      vec3 coord = vec3(mod(p - pOffset * atlasDimensions, atlasDimensions));\n      float f = fract(coord.z);\n      float level = floor(coord.z);\n      float tileY = floor(level / tileRows);\n      float tileX = level - tileY * tileRows;\n\n      //The data coordinates are offset by the x and y tile, the two boundary cells between each tile pair and the initial boundary cell on the first row/column\n      vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n      vec2 pixel = coord.xy + offset;\n      vec2 data = texture2D(cloudShapeTexture, mod(pixel, dataWidth) / textureWidth).xy;\n\n      return 1.0 - mix(data.x, data.y, f);\n    }\n\n    float getCloudMap(vec2 p){\n      // Non-power-of-two textures can't be tiled using WebGL1\n      // Get fractional part of uv to tile\n      // Shift the texture center to origin to avoid seam artifacts\n      vec2 uv = fract((${d.float(r)} * p) / ${d.float(a)} + 0.5);\n\n      return texture2D(cloudShapeTexture, uv).a;\n    }\n    `), c.fragment.code.add(d`float clouds(vec3 p) {\nfloat cloud = saturate(0.5 * mix(0.0, 1.0, min(2.0 * coverage, 1.0)));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat cloudMap = getCloudMap(cloudSize * p.xy);\ncloud = mix(cloud, min(2.0 * (coverage), 1.0) * cloudMap, min(2.0 * (1.0 - coverage), 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat shape = getCloudShape(8.0 * cloudSize * p, 0.0);\ncloud = saturate(remap(cloud, smoothness * shape, 1.0, 0.0, 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat heightFraction = saturate((length(p) - cloudRadius - cloudStart) / cloudHeight);\ncloud *= saturate(remap(heightFraction, 0.0, 0.25, 0.0, 1.0)) * smoothstep(1.0, 0.25, heightFraction);\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nreturn density * saturate(remap(cloud, 0.35 * smoothness * getCloudShape(detailSize * p, 0.0), 1.0, 0.0, 1.0));\n}`), c.fragment.code.add(d`vec2 sphereIntersections(vec3 start, vec3 dir, float radius) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = dot(start, start) - (radius * radius);\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}\nfloat HenyeyGreenstein(float g, float costh) {\nreturn (1.0 / (4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * costh, 1.5));\n}`), c.fragment.code.add(\"\\n    vec3 multipleOctaves(float extinction, float mu, float stepL) {\\n      float attenuation = 1.0;\\n      float contribution = 1.0;\\n      float phaseAttenuation = 1.0;\\n      vec3 luminance = vec3(0);\\n\\n      for (int i = 0; i < 4; i++) {\\n        float phase = mix(HenyeyGreenstein(0.0, mu), HenyeyGreenstein(0.3 * phaseAttenuation, mu), 0.7);\\n        luminance += contribution * phase * exp(-stepL * extinction * sigmaE * attenuation);\\n        attenuation *= 0.2;\\n        contribution *= 0.6;\\n        phaseAttenuation *= 0.5;\\n      }\\n\\n      return luminance;\\n    }\"), c.fragment.code.add(d`vec3 lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 sunDirection) {\nfloat lightRayDensity = clouds(p);\nlightRayDensity += clouds(p + sunDirection * 1.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 2.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 3.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 4.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 5.0 * stepL);\nvec3 beersLaw = multipleOctaves(lightRayDensity, mu, stepL);\nreturn mix(beersLaw * 2.0 * (1.0 - (exp(-stepL * lightRayDensity * 2.0 * sigmaE ))), beersLaw, 0.5 + 0.5 * mu);\n}`), c.fragment.code.add(d`vec3 mainRay(vec3 org, vec3 dir, vec3 sunDirection, float distToStart, float totalDistance, out float totalTransmittance) {\nif (dir.z < 0.0) {\nreturn vec3(0);\n}\ntotalTransmittance = 1.0;\nfloat stepS = totalDistance / float(STEPS);\nfloat cameraHeight = length(org);\nfloat mu = 0.5 + 0.5 * dot(sunDirection, dir);\nfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\nvec3 p = org + distToStart  * dir;\nfloat dist = distToStart;\nvec3 color = vec3(0.0);\nfor (int i = 0; i < STEPS; i++) {\nfloat sampleDensity = clouds(p);\nfloat sampleSigmaE = sampleDensity * sigmaE;\nif (sampleDensity > 0.0 ) {\nfloat ambient = mix((1.2), (1.6), saturate((length(p) - cloudRadius - cloudStart) / cloudHeight));\nvec3 luminance = sampleDensity * (ambient + power * phaseFunction * lightRay(org, p, phaseFunction, mu, sunDirection));\nfloat transmittance = exp(-sampleSigmaE * stepS);\ncolor += totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE;\ntotalTransmittance *= transmittance;\nif (totalTransmittance <= 0.001) {\ntotalTransmittance = 0.0;\nbreak;\n}\n}\ndist += stepS;\np = org + dir * dist;\n}\nreturn color;\n}`), c.fragment.code.add(d`void main() {\nvec3 rayDir = rayDirection(gl_FragCoord.xy);\nrayDir = normalize(view * rayDir);\nvec3 viewPos = vec3(0, 0, cloudRadius + 1.0);\nbool hitsPlanet = rayDir.z < 0.0;\nif (hitsPlanet) {\ngl_FragColor = vec4(vec3(0), 1);\nreturn;\n}\nvec2 rayStartIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart);\nvec2 rayEndIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart + cloudHeight);\nfloat distToStart = rayStartIntersect.y;\nfloat totalDistance = rayEndIntersect.y - distToStart;\nfloat totalTransmittance = 1.0;\nvec3 sunDirection = normalize(vec3(0, 0, 1));\nvec3 col = 0.5 * mainRay(viewPos, rayDir, sunDirection, distToStart, totalDistance, totalTransmittance).rgb;\ngl_FragColor = vec4(col, totalTransmittance);\n}`), c;\n}\n\nconst h = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  CloudsDrawParameters: p,\n  build: g\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { p as C, h as a, g as b };","map":{"version":3,"names":["c","t","RayMarchingSteps","e","ATLAS_SIZE","a","TILE_ROWS","o","TILE_SIZE","i","TEXTURE_SCALE","n","WEATHER_MAP_SCALE","r","ScreenSpacePass","s","FloatUniform","l","NoParameters","glsl","d","Matrix3DrawUniform","u","ShaderBuilder","f","Texture2DUniform","m","p","constructor","arguments","viewMatrix","g","include","fragment","uniforms","add","code","steps","SIXTEEN","HUNDRED","float","h","Object","freeze","defineProperty","__proto__","CloudsDrawParameters","build","Symbol","toStringTag","value","C","b"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/chunks/Clouds.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{c as t}from\"./mat3f64.js\";import{RayMarchingSteps as e}from\"../views/3d/environment/CloudsTechniqueConfiguration.js\";import{ATLAS_SIZE as a,TILE_ROWS as o,TILE_SIZE as i,TEXTURE_SCALE as n,WEATHER_MAP_SCALE as r}from\"../views/3d/environment/NoiseTextureAtlasDimensions.js\";import{ScreenSpacePass as s}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js\";import{FloatUniform as l}from\"../views/3d/webgl-engine/core/shaderModules/FloatUniform.js\";import{NoParameters as c,glsl as d}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix3DrawUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Matrix3DrawUniform.js\";import{ShaderBuilder as f}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DUniform.js\";class p extends c{constructor(){super(...arguments),this.viewMatrix=t()}}function g(t){const c=new f;return c.include(s,!1),c.fragment.uniforms.add(new l(\"cloudRadius\")),c.fragment.uniforms.add(new l(\"halfCubeMapSize\")),c.fragment.uniforms.add(new l(\"power\")),c.fragment.uniforms.add(new l(\"sigmaE\")),c.fragment.uniforms.add(new l(\"density\")),c.fragment.uniforms.add(new l(\"cloudSize\")),c.fragment.uniforms.add(new l(\"detailSize\")),c.fragment.uniforms.add(new l(\"smoothness\")),c.fragment.uniforms.add(new l(\"cloudHeight\")),c.fragment.uniforms.add(new l(\"coverage\")),c.fragment.uniforms.add(new u(\"view\",(t=>t.viewMatrix))),c.fragment.uniforms.add(new m(\"cloudShapeTexture\")),c.fragment.code.add(d`\n    const int STEPS = ${t.steps===e.SIXTEEN?d`16`:t.steps===e.HUNDRED?d`100`:d`200`};\n    const int STEPS_LIGHT = 6;\n    const float stepL = 300.0 / float(STEPS_LIGHT);\n    const float cloudStart = 1500.0;\n\n    vec3 rayDirection(vec2 fragCoord) {\n      vec2 xy = fragCoord - halfCubeMapSize;\n      return normalize(vec3(-xy, -halfCubeMapSize));\n    }\n\n    float remap(float x, float low1, float high1, float low2, float high2) {\n      return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n    }\n\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }`),c.fragment.code.add(d`\n    float getCloudShape(vec3 pos, float pOffset) {\n      const float textureWidth = ${d.float(a)};\n      const float dataWidth = ${d.float(a)};\n      const float tileRows = ${d.float(o)};\n      const vec3 atlasDimensions = vec3(${d.float(i)}, ${d.float(i)}, tileRows * tileRows);\n\n      //Change from Y being height to Z being height\n      vec3 p = float(${d.float(n)}) * pos.xzy;\n\n      //Pixel coordinates of point in the 3D data\n      vec3 coord = vec3(mod(p - pOffset * atlasDimensions, atlasDimensions));\n      float f = fract(coord.z);\n      float level = floor(coord.z);\n      float tileY = floor(level / tileRows);\n      float tileX = level - tileY * tileRows;\n\n      //The data coordinates are offset by the x and y tile, the two boundary cells between each tile pair and the initial boundary cell on the first row/column\n      vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n      vec2 pixel = coord.xy + offset;\n      vec2 data = texture2D(cloudShapeTexture, mod(pixel, dataWidth) / textureWidth).xy;\n\n      return 1.0 - mix(data.x, data.y, f);\n    }\n\n    float getCloudMap(vec2 p){\n      // Non-power-of-two textures can't be tiled using WebGL1\n      // Get fractional part of uv to tile\n      // Shift the texture center to origin to avoid seam artifacts\n      vec2 uv = fract((${d.float(r)} * p) / ${d.float(a)} + 0.5);\n\n      return texture2D(cloudShapeTexture, uv).a;\n    }\n    `),c.fragment.code.add(d`float clouds(vec3 p) {\nfloat cloud = saturate(0.5 * mix(0.0, 1.0, min(2.0 * coverage, 1.0)));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat cloudMap = getCloudMap(cloudSize * p.xy);\ncloud = mix(cloud, min(2.0 * (coverage), 1.0) * cloudMap, min(2.0 * (1.0 - coverage), 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat shape = getCloudShape(8.0 * cloudSize * p, 0.0);\ncloud = saturate(remap(cloud, smoothness * shape, 1.0, 0.0, 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat heightFraction = saturate((length(p) - cloudRadius - cloudStart) / cloudHeight);\ncloud *= saturate(remap(heightFraction, 0.0, 0.25, 0.0, 1.0)) * smoothstep(1.0, 0.25, heightFraction);\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nreturn density * saturate(remap(cloud, 0.35 * smoothness * getCloudShape(detailSize * p, 0.0), 1.0, 0.0, 1.0));\n}`),c.fragment.code.add(d`vec2 sphereIntersections(vec3 start, vec3 dir, float radius) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = dot(start, start) - (radius * radius);\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}\nfloat HenyeyGreenstein(float g, float costh) {\nreturn (1.0 / (4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * costh, 1.5));\n}`),c.fragment.code.add(\"\\n    vec3 multipleOctaves(float extinction, float mu, float stepL) {\\n      float attenuation = 1.0;\\n      float contribution = 1.0;\\n      float phaseAttenuation = 1.0;\\n      vec3 luminance = vec3(0);\\n\\n      for (int i = 0; i < 4; i++) {\\n        float phase = mix(HenyeyGreenstein(0.0, mu), HenyeyGreenstein(0.3 * phaseAttenuation, mu), 0.7);\\n        luminance += contribution * phase * exp(-stepL * extinction * sigmaE * attenuation);\\n        attenuation *= 0.2;\\n        contribution *= 0.6;\\n        phaseAttenuation *= 0.5;\\n      }\\n\\n      return luminance;\\n    }\"),c.fragment.code.add(d`vec3 lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 sunDirection) {\nfloat lightRayDensity = clouds(p);\nlightRayDensity += clouds(p + sunDirection * 1.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 2.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 3.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 4.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 5.0 * stepL);\nvec3 beersLaw = multipleOctaves(lightRayDensity, mu, stepL);\nreturn mix(beersLaw * 2.0 * (1.0 - (exp(-stepL * lightRayDensity * 2.0 * sigmaE ))), beersLaw, 0.5 + 0.5 * mu);\n}`),c.fragment.code.add(d`vec3 mainRay(vec3 org, vec3 dir, vec3 sunDirection, float distToStart, float totalDistance, out float totalTransmittance) {\nif (dir.z < 0.0) {\nreturn vec3(0);\n}\ntotalTransmittance = 1.0;\nfloat stepS = totalDistance / float(STEPS);\nfloat cameraHeight = length(org);\nfloat mu = 0.5 + 0.5 * dot(sunDirection, dir);\nfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\nvec3 p = org + distToStart  * dir;\nfloat dist = distToStart;\nvec3 color = vec3(0.0);\nfor (int i = 0; i < STEPS; i++) {\nfloat sampleDensity = clouds(p);\nfloat sampleSigmaE = sampleDensity * sigmaE;\nif (sampleDensity > 0.0 ) {\nfloat ambient = mix((1.2), (1.6), saturate((length(p) - cloudRadius - cloudStart) / cloudHeight));\nvec3 luminance = sampleDensity * (ambient + power * phaseFunction * lightRay(org, p, phaseFunction, mu, sunDirection));\nfloat transmittance = exp(-sampleSigmaE * stepS);\ncolor += totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE;\ntotalTransmittance *= transmittance;\nif (totalTransmittance <= 0.001) {\ntotalTransmittance = 0.0;\nbreak;\n}\n}\ndist += stepS;\np = org + dir * dist;\n}\nreturn color;\n}`),c.fragment.code.add(d`void main() {\nvec3 rayDir = rayDirection(gl_FragCoord.xy);\nrayDir = normalize(view * rayDir);\nvec3 viewPos = vec3(0, 0, cloudRadius + 1.0);\nbool hitsPlanet = rayDir.z < 0.0;\nif (hitsPlanet) {\ngl_FragColor = vec4(vec3(0), 1);\nreturn;\n}\nvec2 rayStartIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart);\nvec2 rayEndIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart + cloudHeight);\nfloat distToStart = rayStartIntersect.y;\nfloat totalDistance = rayEndIntersect.y - distToStart;\nfloat totalTransmittance = 1.0;\nvec3 sunDirection = normalize(vec3(0, 0, 1));\nvec3 col = 0.5 * mainRay(viewPos, rayDir, sunDirection, distToStart, totalDistance, totalTransmittance).rgb;\ngl_FragColor = vec4(col, totalTransmittance);\n}`),c}const h=Object.freeze(Object.defineProperty({__proto__:null,CloudsDrawParameters:p,build:g},Symbol.toStringTag,{value:\"Module\"}));export{p as C,h as a,g as b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}