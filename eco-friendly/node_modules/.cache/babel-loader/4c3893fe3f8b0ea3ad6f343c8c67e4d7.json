{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport { c as e } from \"../../../../../../chunks/mat4f64.js\";\nimport { ReadLinearDepth as o } from \"../output/ReadLinearDepth.glsl.js\";\nimport { Float2PassUniform as t } from \"../../shaderModules/Float2PassUniform.js\";\nimport { FloatPassUniform as r } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as a } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as i } from \"../../shaderModules/Matrix4PassUniform.js\";\nimport { Texture2DPassUniform as d } from \"../../shaderModules/Texture2DPassUniform.js\";\n\nfunction n(e, n) {\n  const c = e.fragment.uniforms;\n  c.add(new t(\"nearFar\", (e, o) => o.camera.nearFar)), c.add(new d(\"depthMap\", (e, o) => o.linearDepthTexture)), c.add(new i(\"view\", (e, o) => o.ssr.camera.viewMatrix)), c.add(new i(\"proj\", (e, o) => o.ssr.camera.projectionMatrix)), c.add(new r(\"invResolutionHeight\", (e, o) => 1 / o.ssr.camera.height)), c.add(new d(\"lastFrameColorMap\", (e, o) => o.ssr.lastFrameColorTexture)), c.add(new i(\"reprojectionMatrix\", (e, o) => o.ssr.reprojectionMatrix)), e.fragment.include(o), e.fragment.code.add(a`\n  vec2 reprojectionCoordinate(vec3 projectionCoordinate)\n  {\n    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);\n    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);\n    reprojectedCoord.xy /= reprojectedCoord.w;\n    return reprojectedCoord.xy * 0.5 + 0.5;\n  }\n\n  const int maxSteps = ${n.highStepCount ? \"150;\" : \"75;\"}\n\n  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)\n  {\n    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);\n    projectedCoord.xy /= projectedCoord.w;\n    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;\n    return projectedCoord;\n  }\n\n  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)\n  {\n    vec3 viewPos = startPosition;\n    vec3 viewPosEnd = startPosition;\n\n    // Project the start position to the screen\n    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);\n    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space\n    float k0 = 1.0/ projectedCoordStart.w;\n\n    // advance the position in the direction of the reflection\n    viewPos += dir;\n\n    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);\n\n    // Project the advanced position to the screen\n    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);\n    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space\n    float k1 = 1.0/ projectedCoordEnd.w;\n\n    // calculate the reflection direction in the screen space\n    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);\n    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);\n\n    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);\n\n    float projectedCoordDirLength = length(projectedCoordDir);\n    float maxSt = float(maxSteps);\n\n    // normalize the projection direction depending on maximum steps\n    // this determines how blocky the reflection looks\n    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);\n\n    // Normalize the homogeneous camera space coordinates\n    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);\n    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);\n\n    // initialize the variables for ray marching\n    vec2 P = projectedCoordStart.xy;\n    vec3 Q = Q0;\n    float k = k0;\n    float rayStartZ = -startPosition.z; // estimated ray start depth value\n    float rayEndZ = -startPosition.z;   // estimated ray end depth value\n    float prevEstimateZ = -startPosition.z;\n    float rayDiffZ = 0.0;\n    float dDepth;\n    float depth;\n    float rayDiffZOld = 0.0;\n\n    // early outs\n    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)\n      return vec3(P, 0.0);\n\n    for(int i = 0; i < maxSteps-1; i++)\n    {\n      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer\n\n      // estimate depth of the marching ray\n      rayStartZ = prevEstimateZ;\n      dDepth = -rayStartZ - depth;\n      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));\n      rayDiffZ = rayEndZ- rayStartZ;\n      prevEstimateZ = rayEndZ;\n\n      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )\n      {\n        return vec3(P, 0.);\n      }\n\n      // If we detect a hit - return the intersection point, two conditions:\n      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth\n      //  - if difference between dDepth and rayDiffZOld is not too large\n      //  - if difference between dDepth and 0.025/abs(k) is not too large\n      //  - if the sampled depth is not behind far plane or in front of near plane\n\n      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)\n      {\n        return vec3(P, depth);\n      }\n\n      // continue with ray marching\n      P += dP;\n      Q.z += dQ.z;\n      k += dk;\n      rayDiffZOld = rayDiffZ;\n    }\n    return vec3(P, 0.0);\n  }\n  `);\n}\n\nclass c {\n  constructor() {\n    this.reprojectionMatrix = e();\n  }\n\n}\n\nexport { c as SSRUniforms, n as ScreenSpaceReflections };","map":{"version":3,"names":["c","e","ReadLinearDepth","o","Float2PassUniform","t","FloatPassUniform","r","glsl","a","Matrix4PassUniform","i","Texture2DPassUniform","d","n","fragment","uniforms","add","camera","nearFar","linearDepthTexture","ssr","viewMatrix","projectionMatrix","height","lastFrameColorTexture","reprojectionMatrix","include","code","highStepCount","constructor","SSRUniforms","ScreenSpaceReflections"],"sources":["C:/Users/hp/Desktop/eco-friendly atmosphere/Atmosphere/eco-friendly/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ScreenSpaceReflections.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{c as e}from\"../../../../../../chunks/mat4f64.js\";import{ReadLinearDepth as o}from\"../output/ReadLinearDepth.glsl.js\";import{Float2PassUniform as t}from\"../../shaderModules/Float2PassUniform.js\";import{FloatPassUniform as r}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as a}from\"../../shaderModules/interfaces.js\";import{Matrix4PassUniform as i}from\"../../shaderModules/Matrix4PassUniform.js\";import{Texture2DPassUniform as d}from\"../../shaderModules/Texture2DPassUniform.js\";function n(e,n){const c=e.fragment.uniforms;c.add(new t(\"nearFar\",((e,o)=>o.camera.nearFar))),c.add(new d(\"depthMap\",((e,o)=>o.linearDepthTexture))),c.add(new i(\"view\",((e,o)=>o.ssr.camera.viewMatrix))),c.add(new i(\"proj\",((e,o)=>o.ssr.camera.projectionMatrix))),c.add(new r(\"invResolutionHeight\",((e,o)=>1/o.ssr.camera.height))),c.add(new d(\"lastFrameColorMap\",((e,o)=>o.ssr.lastFrameColorTexture))),c.add(new i(\"reprojectionMatrix\",((e,o)=>o.ssr.reprojectionMatrix))),e.fragment.include(o),e.fragment.code.add(a`\n  vec2 reprojectionCoordinate(vec3 projectionCoordinate)\n  {\n    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);\n    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);\n    reprojectedCoord.xy /= reprojectedCoord.w;\n    return reprojectedCoord.xy * 0.5 + 0.5;\n  }\n\n  const int maxSteps = ${n.highStepCount?\"150;\":\"75;\"}\n\n  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)\n  {\n    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);\n    projectedCoord.xy /= projectedCoord.w;\n    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;\n    return projectedCoord;\n  }\n\n  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)\n  {\n    vec3 viewPos = startPosition;\n    vec3 viewPosEnd = startPosition;\n\n    // Project the start position to the screen\n    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);\n    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space\n    float k0 = 1.0/ projectedCoordStart.w;\n\n    // advance the position in the direction of the reflection\n    viewPos += dir;\n\n    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);\n\n    // Project the advanced position to the screen\n    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);\n    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space\n    float k1 = 1.0/ projectedCoordEnd.w;\n\n    // calculate the reflection direction in the screen space\n    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);\n    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);\n\n    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);\n\n    float projectedCoordDirLength = length(projectedCoordDir);\n    float maxSt = float(maxSteps);\n\n    // normalize the projection direction depending on maximum steps\n    // this determines how blocky the reflection looks\n    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);\n\n    // Normalize the homogeneous camera space coordinates\n    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);\n    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);\n\n    // initialize the variables for ray marching\n    vec2 P = projectedCoordStart.xy;\n    vec3 Q = Q0;\n    float k = k0;\n    float rayStartZ = -startPosition.z; // estimated ray start depth value\n    float rayEndZ = -startPosition.z;   // estimated ray end depth value\n    float prevEstimateZ = -startPosition.z;\n    float rayDiffZ = 0.0;\n    float dDepth;\n    float depth;\n    float rayDiffZOld = 0.0;\n\n    // early outs\n    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)\n      return vec3(P, 0.0);\n\n    for(int i = 0; i < maxSteps-1; i++)\n    {\n      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer\n\n      // estimate depth of the marching ray\n      rayStartZ = prevEstimateZ;\n      dDepth = -rayStartZ - depth;\n      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));\n      rayDiffZ = rayEndZ- rayStartZ;\n      prevEstimateZ = rayEndZ;\n\n      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )\n      {\n        return vec3(P, 0.);\n      }\n\n      // If we detect a hit - return the intersection point, two conditions:\n      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth\n      //  - if difference between dDepth and rayDiffZOld is not too large\n      //  - if difference between dDepth and 0.025/abs(k) is not too large\n      //  - if the sampled depth is not behind far plane or in front of near plane\n\n      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)\n      {\n        return vec3(P, depth);\n      }\n\n      // continue with ray marching\n      P += dP;\n      Q.z += dQ.z;\n      k += dk;\n      rayDiffZOld = rayDiffZ;\n    }\n    return vec3(P, 0.0);\n  }\n  `)}class c{constructor(){this.reprojectionMatrix=e()}}export{c as SSRUniforms,n as ScreenSpaceReflections};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,CAAC,IAAIC,CAAZ,QAAkB,qCAAlB;AAAwD,SAAOC,eAAe,IAAIC,CAA1B,QAAgC,mCAAhC;AAAoE,SAAOC,iBAAiB,IAAIC,CAA5B,QAAkC,0CAAlC;AAA6E,SAAOC,gBAAgB,IAAIC,CAA3B,QAAiC,yCAAjC;AAA2E,SAAOC,IAAI,IAAIC,CAAf,QAAqB,mCAArB;AAAyD,SAAOC,kBAAkB,IAAIC,CAA7B,QAAmC,2CAAnC;AAA+E,SAAOC,oBAAoB,IAAIC,CAA/B,QAAqC,6CAArC;;AAAmF,SAASC,CAAT,CAAWb,CAAX,EAAaa,CAAb,EAAe;EAAC,MAAMd,CAAC,GAACC,CAAC,CAACc,QAAF,CAAWC,QAAnB;EAA4BhB,CAAC,CAACiB,GAAF,CAAM,IAAIZ,CAAJ,CAAM,SAAN,EAAiB,CAACJ,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAACe,MAAF,CAASC,OAAjC,CAAN,GAAkDnB,CAAC,CAACiB,GAAF,CAAM,IAAIJ,CAAJ,CAAM,UAAN,EAAkB,CAACZ,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAACiB,kBAA3B,CAAN,CAAlD,EAAyGpB,CAAC,CAACiB,GAAF,CAAM,IAAIN,CAAJ,CAAM,MAAN,EAAc,CAACV,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAACkB,GAAF,CAAMH,MAAN,CAAaI,UAAlC,CAAN,CAAzG,EAA+JtB,CAAC,CAACiB,GAAF,CAAM,IAAIN,CAAJ,CAAM,MAAN,EAAc,CAACV,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAACkB,GAAF,CAAMH,MAAN,CAAaK,gBAAlC,CAAN,CAA/J,EAA2NvB,CAAC,CAACiB,GAAF,CAAM,IAAIV,CAAJ,CAAM,qBAAN,EAA6B,CAACN,CAAD,EAAGE,CAAH,KAAO,IAAEA,CAAC,CAACkB,GAAF,CAAMH,MAAN,CAAaM,MAAnD,CAAN,CAA3N,EAA8RxB,CAAC,CAACiB,GAAF,CAAM,IAAIJ,CAAJ,CAAM,mBAAN,EAA2B,CAACZ,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAACkB,GAAF,CAAMI,qBAAxC,CAAN,CAA9R,EAAqWzB,CAAC,CAACiB,GAAF,CAAM,IAAIN,CAAJ,CAAM,oBAAN,EAA4B,CAACV,CAAD,EAAGE,CAAH,KAAOA,CAAC,CAACkB,GAAF,CAAMK,kBAAzC,CAAN,CAArW,EAA0azB,CAAC,CAACc,QAAF,CAAWY,OAAX,CAAmBxB,CAAnB,CAA1a,EAAgcF,CAAC,CAACc,QAAF,CAAWa,IAAX,CAAgBX,GAAhB,CAAoBR,CAAE;AACj/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyBK,CAAC,CAACe,aAAF,GAAgB,MAAhB,GAAuB,KAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GA3G29B,CAAhc;AA2GthB;;AAAA,MAAM7B,CAAN,CAAO;EAAC8B,WAAW,GAAE;IAAC,KAAKJ,kBAAL,GAAwBzB,CAAC,EAAzB;EAA4B;;AAA3C;;AAA4C,SAAOD,CAAC,IAAI+B,WAAZ,EAAwBjB,CAAC,IAAIkB,sBAA7B"},"metadata":{},"sourceType":"module"}